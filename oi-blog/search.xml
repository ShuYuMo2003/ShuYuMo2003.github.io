<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>「学习总结」久月</title>
    <url>//%E3%80%8C%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93%E3%80%8D%E4%B9%85%E6%9C%88/</url>
    <content><![CDATA[<div class="note warning"><p>久月也是个可爱的月份呢 QAQ~</p>
</div>
<a id="more"></a>
<h2 id="点分治">点分治</h2>
<p>点分治三连： - Grt( o ): 找到结点 o 所在子树的 <mark class="label success">重心</mark>。 - solve( o ): 在以结点 o 为根的子树中，处理经过<mark class="label warning">根节点</mark>的<mark class="label success">路径或点对</mark>。 - divide( o ): 点分治主函数，调用 <code>solve(o)</code> 处理以 o 为根 经过点 o 的信息，然后删除点 o ，递归处理其儿子（<code>divide(ex)</code>）</p>
<div class="note danger"><h4 id="注意">注意</h4>
<ul>
<li>应保证 <code>solve(o)</code> 在执行过程中严格 <span class="math inline">\(O(\text{size}_o)\)</span> 否则会导致总时间复杂度不正确。</li>
<li>应保证 两次执行 <code>Grt()</code> 第二次调用只是为了确定以重心为根节点的子树大小。</li>
<li><code>solve(o)</code>中往往是在考虑所有之前访问过的子树结点 到 当前刚刚访问的结点 之间统计答案。</li>
</ul>
</div>
<h3 id="例题-1">例题 1</h3>
<div class="note info"><p>给定一棵有 <span class="math inline">\(n\)</span> 个点的树，询问树上距离为 <span class="math inline">\(k\)</span> 的点对是否存在。</p>
</div>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">int sum;
int si[_N];
bool vis[_N];
bool judge[int(1e7 + 100)];
int qer[_N];
int MX[_N];
int ans[int(1e7 + 100)];
int rt;

void grt(int o, int f)
&#123;
    si[o] &#x3D; 1;
    MX[o] &#x3D; 0;
    int MAX &#x3D; 0;
    for (int i &#x3D; head[o]; i; i &#x3D; edge[i].nxt)
    &#123;
        int ex &#x3D; edge[i].node;
        if (ex &#x3D;&#x3D; f || vis[ex])
            continue;
        grt(ex, o);
        si[o] +&#x3D; si[ex];
        MAX &#x3D; max(si[ex], MAX);
    &#125;
    MAX &#x3D; max(MAX, sum - si[o]);
    MX[o] &#x3D; MAX;
    if (MAX &lt; MX[rt])
        rt &#x3D; o;
&#125;

int cnt &#x3D; 0;
int tmp[_N];
void GetAllDis(int o, int f, int dis)
&#123;
    if (dis &gt; 1e7)
        return;
    tmp[++cnt] &#x3D; dis;
    for (int i &#x3D; head[o]; i; i &#x3D; edge[i].nxt)
    &#123;
        int ex &#x3D; edge[i].node;
        if (ex &#x3D;&#x3D; f || vis[ex])
            continue;
        GetAllDis(ex, o, dis + edge[i].w);
    &#125;
&#125;

queue&lt;int&gt; Q;
void solve(int o)
&#123;
    judge[0] &#x3D; true;
    for (int i &#x3D; head[o]; i; i &#x3D; edge[i].nxt)
    &#123;
        int ex &#x3D; edge[i].node;
        if (vis[ex])
            continue;
        cnt &#x3D; 0;
        GetAllDis(ex, 0, edge[i].w);
        for (int j &#x3D; 1; j &lt;&#x3D; cnt; j++)
        &#123;
            for (int k &#x3D; 1; k &lt;&#x3D; m; k++)
            &#123;
                if (qer[k] &gt;&#x3D; tmp[j])
                    ans[k] |&#x3D; judge[qer[k] - tmp[j]];
            &#125;
        &#125;
        for (int j &#x3D; 1; j &lt;&#x3D; cnt; j++)
        &#123;
            judge[tmp[j]] &#x3D; 1;
            Q.push(tmp[j]);
        &#125;
    &#125;
    while (!Q.empty())
    &#123;
        judge[Q.front()] &#x3D; 0;
        Q.pop();
    &#125;
&#125;

void divide(int o)
&#123;
    vis[o] &#x3D; 1;
    solve(o);
    for (int i &#x3D; head[o]; i; i &#x3D; edge[i].nxt)
    &#123;
        int ex &#x3D; edge[i].node;
        if (vis[ex])
            continue;
        sum &#x3D; si[ex];
        MX[rt &#x3D; 0] &#x3D; INT_MAX;
        grt(ex, 0);
        grt(rt, 0);
        divide(rt);
    &#125;
&#125;
int main()
&#123;
    n &#x3D; read(), m &#x3D; read();
    for (int i &#x3D; 1; i &lt; n; i++)
    &#123;
        int u &#x3D; read(), v &#x3D; read(), w &#x3D; read();
        add(u, v, w);
        add(v, u, w);
    &#125;
    for (int i &#x3D; 1; i &lt;&#x3D; m; i++)
        qer[i] &#x3D; read();
    sum &#x3D; n;
    MX[rt &#x3D; 0] &#x3D; INT_MAX;
    grt(1, 0);
    grt(rt, 0);
    divide(rt);
    for (int i &#x3D; 1; i &lt;&#x3D; m; i++)
    &#123;
        if (ans[i])
            puts(&quot;AYE&quot;);
        else
            puts(&quot;NAY&quot;);
    &#125;
    return 0;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h3 id="例题-2">例题 2</h3>
<div class="note info"><h4 id="luogu-p2634国家集训队聪聪可可">「luogu-P2634」「国家集训队」聪聪可可</h4>
<p>给出一个带权树，求出所有满足长度为 <span class="math inline">\(3\)</span> 的倍数的简单路径数量。</p>
</div>
<div class="note success"><p>统计时，统计每个子树内，分别统计 根到子树中结点的路径长度 <span class="math inline">\(\text{mod}\ 3\)</span> 后，不同值的数量。 在根节点拼接即可。</p>
</div>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">int n;
bool vis[_N];
namespace GetCenter
&#123;
    int sum;
    int si[_N];
    int MX[_N];
    int rt;
    void dfs(int o, int f)
    &#123;
        si[o] &#x3D; 1;
        MX[o] &#x3D; 0;
        int MAX &#x3D; 0;
        for (int i &#x3D; head[o]; i; i &#x3D; edge[i].nxt)
        &#123;
            int ex &#x3D; edge[i].node;
            if (ex &#x3D;&#x3D; f || vis[ex])
                continue;
            dfs(ex, o);
            si[o] +&#x3D; si[ex];
            MAX &#x3D; max(MAX, si[ex]);
        &#125;
        MAX &#x3D; max(MAX, sum - si[o]);
        MX[o] &#x3D; MAX;
        if (MX[rt] &gt; MX[o])
            rt &#x3D; o;
    &#125;
    int grt(int o, int _sum)
    &#123;
        MX[rt &#x3D; 0] &#x3D; INT_MAX;
        sum &#x3D; _sum;
        dfs(o, 0);
        dfs(rt, 0);
        return rt;
    &#125;
&#125; &#x2F;&#x2F; namespace GetCenter
using GetCenter::grt;
using GetCenter::si;

int ans &#x3D; 0;
int cnt[3];
void GetDis(int o, int f, int dis)
&#123;
    cnt[dis % 3]++;
    for (int i &#x3D; head[o]; i; i &#x3D; edge[i].nxt)
    &#123;
        int ex &#x3D; edge[i].node;
        if (ex &#x3D;&#x3D; f || vis[ex])
            continue;
        GetDis(ex, o, dis + edge[i].w);
    &#125;
&#125;
int Bef[3];
void solve(int o)
&#123;
    Bef[0] &#x3D; 1;
    for (int i &#x3D; head[o]; i; i &#x3D; edge[i].nxt)
    &#123;
        int ex &#x3D; edge[i].node;
        if (vis[ex])
            continue;
        memset(cnt, 0, sizeof(cnt));
        GetDis(ex, 0, edge[i].w);
        for (int i &#x3D; 0; i &lt; 3; i++)
            ans +&#x3D; Bef[i] * cnt[(3 - i) % 3] * 2;

        for (int i &#x3D; 0; i &lt; 3; i++)
            Bef[i] +&#x3D; cnt[i];
    &#125;
    memset(Bef, 0, sizeof(Bef));
&#125;

void divide(int o)
&#123;
    vis[o] &#x3D; true;
    solve(o);
    for (int i &#x3D; head[o]; i; i &#x3D; edge[i].nxt)
    &#123;
        int ex &#x3D; edge[i].node;
        if (vis[ex])
            continue;
        int rt &#x3D; grt(ex, si[ex]);
        divide(rt);
    &#125;
&#125;
int main()
&#123;
    n &#x3D; read();
    for (int i &#x3D; 1; i &lt; n; i++)
    &#123;
        int u &#x3D; read(), v &#x3D; read(), w &#x3D; read();
        add(u, v, w);
        add(v, u, w);
    &#125;
    int rt &#x3D; grt(1, n);
    divide(rt);
    ans +&#x3D; n;
    int A &#x3D; ans, B &#x3D; n * n;
    int g &#x3D; gcd(A, B);
    printf(&quot;%d&#x2F;%d\n&quot;, A &#x2F; g, B &#x2F; g);
    return 0;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h4 id="栗题-3">栗题 3</h4>
<div class="note info"><h4 id="luogu-p4178聪聪可可">「luogu-P4178」聪聪可可</h4>
<p>给定一棵 <span class="math inline">\(n\)</span> 个节点的树，每条边有边权，求出树上两点距离小于等于 <span class="math inline">\(k\)</span> 的点对数量</p>
</div>
<div class="note success"><p>对每个儿子统计所有可能的长度，乘法原理以此匹配即可。</p>
</div>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">int vis[_N];
namespace GetCenter
&#123;
    int si[_N];
    int MX[_N];
    int rt;
    int sum;
    void dfs(int o, int f)
    &#123;
        si[o] &#x3D; 1;
        int MAX &#x3D; INT_MIN;
        for (int i &#x3D; head[o]; i; i &#x3D; edge[i].nxt)
        &#123;
            int ex &#x3D; edge[i].node;
            if (ex &#x3D;&#x3D; f || vis[ex])
                continue;
            dfs(ex, o);
            si[o] +&#x3D; si[ex];
            MAX &#x3D; max(si[ex], MAX);
        &#125;
        MAX &#x3D; max(MAX, sum - si[o]);
        MX[o] &#x3D; MAX;
        if (MAX &lt; MX[rt])
            rt &#x3D; o;
    &#125;
    int grt(int o, int _sum)
    &#123;
        MX[rt &#x3D; 0] &#x3D; INT_MAX;
        sum &#x3D; _sum;
        dfs(o, 0);
        dfs(rt, 0);
        return rt;
    &#125;
&#125; &#x2F;&#x2F; namespace GetCenter
using GetCenter::grt;
using GetCenter::si;

int judge[_N], tjt &#x3D; 0;
int tmp[_N], ttt &#x3D; 0;
void GetDis(int o, int f, int w)
&#123;
    if (w &gt; k)
        return;
    tmp[++ttt] &#x3D; w;
    for (int i &#x3D; head[o]; i; i &#x3D; edge[i].nxt)
    &#123;
        int ex &#x3D; edge[i].node;
        if (ex &#x3D;&#x3D; f || vis[ex])
            continue;
        GetDis(ex, o, w + edge[i].w);
    &#125;
&#125;
int ans &#x3D; 0;
void solve(int o)
&#123;
    for (int i &#x3D; head[o]; i; i &#x3D; edge[i].nxt)
    &#123;
        int ex &#x3D; edge[i].node;
        if (vis[ex])
            continue;

        ttt &#x3D; 0;
        GetDis(ex, 0, edge[i].w);

        for (int i &#x3D; 1; i &lt;&#x3D; ttt; i++)
        &#123;
            int now &#x3D; k - tmp[i];
            int Q &#x3D; (upper_bound(judge + 1, judge + 1 + tjt, now) - judge - 1);
            ans +&#x3D; Q;
        &#125;
        for (int i &#x3D; 1; i &lt;&#x3D; ttt; i++)
            judge[++tjt] &#x3D; tmp[i];
        sort(judge + 1, judge + 1 + tjt);
    &#125;
    ans +&#x3D; (upper_bound(judge + 1, judge + 1 + tjt, k) - judge - 1);
    tjt &#x3D; 0;
&#125;

void divide(int o)
&#123;
    vis[o] &#x3D; true;
    solve(o);
    for (int i &#x3D; head[o]; i; i &#x3D; edge[i].nxt)
    &#123;
        int ex &#x3D; edge[i].node;
        if (vis[ex])
            continue;
        int rt &#x3D; grt(ex, si[ex]);
        divide(rt);
    &#125;
&#125;

int main()
&#123;
    n &#x3D; read();
    for (int i &#x3D; 1; i &lt;&#x3D; n - 1; i++)
    &#123;
        int u &#x3D; read(), v &#x3D; read(), w &#x3D; read();
        add(u, v, w);
        add(v, u, w);
    &#125;
    k &#x3D; read();
    int rt &#x3D; grt(1, n);
    divide(rt);
    printf(&quot;%d&quot;, ans);
    return 0;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="线段树合并">线段树合并</h2>
<h3 id="栗题">栗题</h3>
<div class="note info"><h4 id="luogu-p4556vani有约会雨天的尾巴">「luogu-P4556」「Vani有约会」雨天的尾巴</h4>
<p>首先村落里的一共有 <span class="math inline">\(n\)</span> 座房屋，并形成一个树状结构。然后救济粮分 <span class="math inline">\(m\)</span> 次发放，每次选择两个房屋 <span class="math inline">\((x , y)\)</span>，然后对于 <span class="math inline">\(x\)</span> 到 <span class="math inline">\(y\)</span> 的路径上(含 <span class="math inline">\(x\)</span> 和 <span class="math inline">\(y\)</span>)每座房子里发放一袋 <span class="math inline">\(z\)</span> 类型的救济粮。</p>
<p>然后深绘里想知道，当所有的救济粮发放完毕后，每座房子里存放的最多的是哪种救济粮。</p>
</div>
<div class="note success"><p>重点是维护树上差分，然后在每一个叶子结点，建立一棵线段树，到达每一个非叶子结点，合并其子节点的线段树。</p>
<p>线段树应动态开点，保证空间复杂度正确。</p>
</div>
<h4 id="marge">marge</h4>
<p>分情况讨论： <mark class="label danger">待填</mark> <pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">int marge(int x, int y, int nowl, int nowr)&#123;
    if(!x) return y;
    if(!y) return x;
    if(nowl &#x3D;&#x3D; nowr) return (Val[x].Max +&#x3D; Val[y].Max, x);
    int mid &#x3D; (nowl + nowr) &gt;&gt; 1;
    ls(x) &#x3D; marge(ls(x), ls(y), nowl, mid);
    rs(x) &#x3D; marge(rs(x), rs(y), mid + 1, nowr);
    maintain(x);
    return x;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></p>
]]></content>
      <categories>
        <category>学习总结</category>
      </categories>
      <tags>
        <tag>点分治</tag>
        <tag>线段树合并</tag>
      </tags>
  </entry>
  <entry>
    <title>二分图 and 网络流</title>
    <url>//%E3%80%8C%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93%E3%80%8D%E4%BA%8C%E5%88%86%E5%9B%BE-and-%E7%BD%91%E7%BB%9C%E6%B5%81/</url>
    <content><![CDATA[<p>一些简单的关于图论的定义和胡扯…</p>
<a id="more"></a>
<h2 id="总览">总览</h2>
<h3 id="二分图最大匹配">二分图最大匹配</h3>
<ul>
<li><span class="math inline">\(O(n m)\)</span></li>
<li>Dinic: <span class="math inline">\(O(m \sqrt(n))\)</span></li>
</ul>
<h3 id="二分图最大带权匹配">二分图最大带权匹配</h3>
<ul>
<li>KM算法 <span class="math inline">\(O(N^3)\)</span></li>
</ul>
<h3 id="定义">定义</h3>
<ul>
<li>最大独立集：在图里选最多的点，使得不存在两个选了的点之间有边。</li>
<li>最小点覆盖：在图里选最少的点，使得每个边连接的两个点至少一个点被选。</li>
<li>最长反链：点集 G 中一个极大的子集 W ， 使得 W 中的点互不可到达。</li>
<li>传递闭包：定义有向图 <span class="math inline">\(G\)</span> 的传递闭包为 <span class="math inline">\(\text{A[i, j]} = \text{[点 i 和 点 j 有通路]}\)</span> <!-- more --></li>
</ul>
<h3 id="定理">定理</h3>
<ul>
<li><span class="math inline">\(\text{最长反链} = \text{最小链覆盖}\)</span> （dilworth 定理）</li>
<li><span class="math inline">\(\text{二分图最小点覆盖} = \text{最大匹配}\)</span></li>
<li><span class="math inline">\(\text{最小点覆盖} + \text{最大独立集} = \text{点数}\)</span>,<code>最小覆盖集</code> 与 <code>最大独立集</code> 互为<code>补集</code>, 其<code>并集</code>为点集</li>
<li>Hall定理： 设一个二分图的左右部分分别为 X、Y, 且 |X| = |Y|</li>
<li>矩阵树定理证明：<a href="https://loj.ac/article/2458">有向图矩阵树定理的一个简单组合证明</a></li>
</ul>
<h3 id="小问题">小问题</h3>
<ul>
<li>求 DAG 最小链覆盖（最长反链）：传递闭包 + 拆点二分图匹配</li>
</ul>
<h2 id="栗题">栗题</h2>
<h3 id="loj">4.2（LOJ）</h3>
<div class="note info"><p>给出一个保证左部满匹配的二分图，保证左部每个点的度数不超过2，边有边权。 支持： - 修改边权 - 查询最大带权匹配 (强制保证任意时刻左侧满匹配)</p>
</div>
<p>对左侧点分类： - 度数为 1 ：这条边必须成为匹配边，可直接删除这个点和对应的右边点 - 度数为 2 ：左侧点 u 可直接删掉，在右侧对应的两个点之间直接连两条有向边，给这条边定向，只想哪个点就相当与选哪个点与点 u 相连的边。 - 不难发现这样形成的一张图应该是，若干个 树 和 基环树 组成的森林。根据查询给边定向，其中要求一个点入度数最多为一。树仅需选择一个边定向，在同一个树上的其他边都能被强制定向。对于基环树，环上边需要决定是顺时针还是逆时针，环外的边要指出环</p>
]]></content>
      <tags>
        <tag>图论</tag>
        <tag>网络流</tag>
        <tag>二分图</tag>
      </tags>
  </entry>
  <entry>
    <title>「学习总结」容斥原理</title>
    <url>//%E3%80%8C%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93%E3%80%8D%E5%AE%B9%E6%96%A5%E5%8E%9F%E7%90%86/</url>
    <content><![CDATA[<p><strong>容斥原理</strong> 用于解决一类，在已知任意 <span class="math inline">\(m\)</span> 个集合交集大小的情况下，多个集合求并集大小的问题。 <a id="more"></a></p>
<h1 id="容斥原理">容斥原理</h1>
<h2 id="定义及证明">定义及证明</h2>
<p>设 <span class="math inline">\(U\)</span> 中元素有 <span class="math inline">\(n\)</span> 种不同的属性，而第 <span class="math inline">\(i\)</span> 种属性称为 <span class="math inline">\(P_i\)</span> ，拥有属性 <span class="math inline">\(P_i\)</span> 的元素构成集合 <span class="math inline">\(S_i\)</span> ，那么</p>
<p><span class="math display">\[
\begin{equation}
\left|\bigcup_{i=1}^{n}S_i\right|=\sum_{m=1}^n(-1)^{m-1}\sum_{a_i&lt;a_{i+1} }\left|\bigcap_{i=1}^mS_{a_i}\right|
\end{equation}
\]</span> 其中 <span class="math inline">\(a\)</span> 为任意长度为 <span class="math inline">\(m\)</span> 且 值域为 <span class="math inline">\([1, n]\)</span> 的不重无序数列。</p>
<p>通过定义可知，<strong>容斥原理</strong> 用于解决一类，在已知任意 <span class="math inline">\(m\)</span> 个集合交集大小的情况下，多个集合求并集大小的问题。</p>
<p>对于有限制条件的计数问题，可以转化成求<strong>集合交并大小</strong>问题，进而通过<strong>容斥原理</strong>解决。</p>
<p>关于容斥原理的证明，其实就是要保证并集中的每一个元素对答案的贡献为 <span class="math inline">\(1\)</span> 。</p>
<p>对于元素 <span class="math inline">\(x\)</span>，假设它出现在 <span class="math inline">\(T_1,T_2,\cdots,T_m\)</span> 的集合中，那么它的出现次数为</p>
<p><span class="math display">\[
\begin{split}
Cnt=&amp;|\{T_i\}|-|\{T_i\cap T_j|i&lt;j\}|+\cdots+(-1)^{k-1}\left|\left\{\bigcap_{i=1}^{k}T_{a_i}|a_i&lt;a_{i+1}\right\}\right|\\
&amp;+\cdots+(-1)^{m-1}|\{T_1\cap\cdots\cap T_m\}|\\
=&amp;C_m^1-C_m^2+\cdots+(-1)^{m-1}C_m^m\\
=&amp;C_m^0-\sum_{i=0}^m(-1)^iC_m^i\\
=&amp;1-(1-1)^m=1
\end{split}
\]</span></p>
<h2 id="计数问题的转化">计数问题的转化</h2>
<p>可以考虑把具有相同属性的计数对象放入同一集合。然后根据题目要求，求出同时具有某些属性的技术对象个数（即：属性对应的集合交集）。 <span class="math display">\[
\begin{equation}
\left|\bigcap_{i=1}^{n}S_i\right|=|U|-\left|\bigcup_{i=1}^n\overline{S_i}\right|
\end{equation}
\]</span> 由于容斥原理本身是求集合并集大小，但是可以通过 上式 转化为求集合交集大小问题。</p>
<h2 id="容斥原理栗题们">容斥原理栗题（们）</h2>
<h3 id="栗题一">栗题一</h3>
<p>详见<a href="https://oi-wiki.org/math/inclusion-exclusion-principle/#_5">不定方程非负整数解计数</a>。</p>
<div class="note info"><p>对于限制元素数量下界的要求，处理方式都可以采用，直接对总数减去这个元素的下界，计算取值时直接不考虑下界即可。</p>
</div>
<h3 id="栗题二">栗题二</h3>
<div class="note info"><p>对于一个 <span class="math inline">\(1\)</span>~<span class="math inline">\(n\)</span> 的排列 <span class="math inline">\(P\)</span>，若 <span class="math inline">\(\forall i ,P_i \not = i\)</span> 则称其为错位排列。给出 <span class="math inline">\(n\)</span> ，求长度为 <span class="math inline">\(n\)</span> 的错位排列个数。</p>
</div>
<p>考虑全集 <span class="math inline">\(|\mathbb{U}|=n!\)</span> ，元素属性就是 <span class="math inline">\(P_i \not = i\)</span>，答案就是 <span class="math inline">\(\left|\bigcap_{i=1}^{n}\limits{S_i}\right|\)</span>。</p>
<p>考虑到： <span class="math display">\[
\begin{equation}
\left|\bigcap_{i=1}^{n}S_i\right|=|\mathbb{U}|-\left|\bigcup_{i=1}^n\overline{S_i}\right|
\end{equation}
\]</span> 易知：<span class="math inline">\(\overline{S_i}\)</span> 就是所有 <span class="math inline">\(P_i = i\)</span> 的排列。</p>
<p>考虑到： <span class="math display">\[
\begin{split}
\left|\bigcup_{i=1}^n\overline{S_i}\right|&amp;=\sum_{k=1}^{n}\limits{(-1)^{k-1}\sum_{a_1,\dots ,a_k}\limits{ \left|\bigcap_{i=1}^{k}\limits{S_{a_i}}\right|  }}\\
&amp;=\sum_{k=1}^{n}\limits{(-1)^{k-1}\dbinom{n}{k}(n-k)!}\\
\end{split}
\]</span> 综合上式，得出长度为 <span class="math inline">\(n\)</span> 的错位排列数为：</p>
<p><span class="math display">\[
D_n=n!-\sum_{k=1}^{n}\limits{(-1)^{k-1}\dbinom{n}{k}(n-k)!}
\]</span></p>
<h3 id="栗题三">栗题三</h3>
<div class="note info"><p>A 和 B 喜欢对图（不一定连通）进行染色，而他们的规则是，相邻的结点必须染同一种颜色。</p>
<p>今天 A 和 B 玩游戏，对于 <span class="math inline">\(n\)</span> 阶 <strong>完全图</strong> <span class="math inline">\(G=(V,E)\)</span> 。他们定义一个估价函数 <span class="math inline">\(F(S)\)</span> ，其中 S 是边集， <span class="math inline">\(S\subseteq E\)</span> .</p>
<p><span class="math inline">\(F(S)\)</span> 的值是对图 <span class="math inline">\(G&#39;=(V,S)\)</span> 用 <span class="math inline">\(m\)</span> 种颜色染色的总方案数。</p>
<p>他们的另一个规则是，如果 <span class="math inline">\(|S|\)</span> 是奇数，那么 A 的得分增加 <span class="math inline">\(F(S)\)</span> ，否则 B 的得分增加 <span class="math inline">\(F(S)\)</span> . 问 A 和 B 的得分差值。</p>
</div>
<p><del>出题人千辛万苦凑出的式子</del></p>
<p>考虑形式化的定义答案： <span class="math display">\[
Ans=\sum_{S\subseteq E}(-1)^{|S|-1}F(S)
\]</span> 设集合 <span class="math inline">\(Q_{(i, j)}\)</span> 中的元素为所有 <span class="math inline">\((i, j)\)</span> 有边相连的图的染色方案。考虑到相邻的节点（有边相连）必须染成相同的颜色，所以两节点 <span class="math inline">\(i, j\)</span> 有边相连即 节点 <span class="math inline">\(i, j\)</span> 染成相同的颜色。</p>
<p>易知： <span class="math display">\[
F(S)=\left|\bigcap_{e\in S}\limits{Q_e}\right|
\]</span> 带入原式即：（这里用到了容斥原理的逆用） <span class="math display">\[
\begin{split}
Ans&amp;=\sum_{S\subseteq E}(-1)^{|S|-1}\left|\bigcap_{e\in S}\limits{Q_e}\right|\\
&amp;=\left|\bigcup_{e\in E}\limits{Q_e}\right|
\end{split}
\]</span> 答案变成：对一张完全图染色，存在任意两个点同色的方案数。</p>
<p>考虑到两两点都异色的染色方案数为 <span class="math inline">\(A_m^n\)</span>。</p>
<p>所以答案为： <span class="math display">\[
m^n-A_m^n
\]</span> 其实容斥原理本质上是集合间交集和并集大小之间的转化。</p>
<h3 id="栗题四">栗题四</h3>
<div class="note info"><p>求出： <span class="math display">\[
\sum_{i=1}^n \sum_{j=1}^n \gcd(i, j)
\]</span> 其中：<span class="math inline">\(n \le 10^5\)</span></p>
</div>
<p>考虑枚举 <code>gcd</code> ，设函数 <span class="math inline">\(f(g)\)</span> 为 <strong>以 g 为最大公约数的数对个数</strong>。 易知： <span class="math display">\[
f(g) = \lfloor\frac{n}{g}\rfloor^2 - \sum_{i=2}^{i \times g \le n}f(i \times g)
\]</span> 考虑到当 <span class="math inline">\(g &gt; \frac{n}{2}\)</span> 时，可以直接得到答案。其余的值逆向递推即可。 ### 栗题五 <a href="https://oi-wiki.org/math/inclusion-exclusion-principle/#_14">容斥原理推导欧拉函数通项公式</a></p>
<h3 id="栗题六">栗题六</h3>
<div class="note info"><p>询问 <span class="math inline">\(1-n\)</span> 中有多少数字可以表示成 <span class="math inline">\(x^y, y &gt; 1\)</span> 的形式。其中 <span class="math inline">\(n \le 10^{18}\)</span></p>
</div>
<p>枚举 <span class="math inline">\(x\)</span> 的复杂度为 <span class="math inline">\(\mathcal{O}(\sqrt n)\)</span> 的。考虑枚举 <span class="math inline">\(y\)</span> ，这样的复杂度仅为 <span class="math inline">\(\mathcal{O}(\log n)\)</span>。枚举一个 <span class="math inline">\(y\)</span> 后，合法的数字有 <span class="math inline">\(\sqrt[y](n)\)</span> 个。</p>
<p>易知，当 <span class="math inline">\(y\)</span> 不等于质数积时，贡献为 0。例如 <span class="math inline">\(y=4\)</span> 时，这里的答案一定被 <span class="math inline">\(y=2\)</span> 时算过一次了。</p>
<p>其余的情况，根据容斥原理的套路，可以发现，容斥系数为 <span class="math inline">\(-\mu(y)\)</span> 。 <strong>莫比乌斯函数</strong>也被称之为<strong>数论容斥系数</strong>。</p>
<h3 id="栗题七">栗题七</h3>
<div class="note info"><p>DAG 计数。给出点数 <span class="math inline">\(n\)</span> ，输出 <span class="math inline">\(n\)</span> 个点的带标号 DAG 的数量，对大质数取模。 其中 <span class="math inline">\(n\le 5 \times 10^3\)</span></p>
</div>
<p>考虑到对于一个 DAG 来说，将其入度为 0 的点剖去之后，剩下的图也是一个 DAG 。这样就成功划分了子问题。</p>
<h4 id="朴素做法">朴素做法</h4>
<p>设 <span class="math inline">\(f(i, j)\)</span> 表示 <span class="math inline">\(i\)</span> 个点的 DAG，有 <span class="math inline">\(j\)</span> 个点的入度为 <span class="math inline">\(0\)</span>，考虑转移：枚举剥去这 <span class="math inline">\(j\)</span> 个点后会剩下多少个入度为 0 的点。 <span class="math display">\[
f(i, j) = \dbinom{i}{j} \sum_{k=1}^{i-j}\limits{(2^j-1)^k 2^{j(i-j-k)}f(i-j, k)}
\]</span> 后面的式子分别为：</p>
<ul>
<li><span class="math inline">\(\dbinom{i}{j}\)</span> ：在 <span class="math inline">\(i\)</span> 个标号中选出 <span class="math inline">\(j\)</span> 个充当入度为 <span class="math inline">\(0\)</span> 的点。</li>
<li><span class="math inline">\((2^j-1)^k\)</span>：对于这 <span class="math inline">\(k\)</span> 个入度为 0 的点，他们可以和之前的 <span class="math inline">\(j\)</span> 个点随意连边（除了不连任何边的情况）。</li>
<li><span class="math inline">\(2^{j(i-j-k)}\)</span>：对于这 <span class="math inline">\(j\)</span> 个点，还可以与除这 <span class="math inline">\(k\)</span> 个点剩下的 <span class="math inline">\(i-j-k\)</span> 个点任意连边，一共有 <span class="math inline">\(i \times (i-j-k)\)</span> 条边可以连。 这样的做法是 <span class="math inline">\(\mathcal{O}(n^3)\)</span> 的</li>
</ul>
<h4 id="优化做法">优化做法</h4>
<div class="note info"><p>容斥原理的一般化： 对于两个集合函数 <span class="math inline">\(f(S), g(S)\)</span>： <span class="math display">\[
f(S) = \sum_{T \subseteq S}\limits{g(T)}\ \ \Longleftrightarrow\ \ g(S) = \sum_{T \subseteq S}\limits{(-1)^{|S| - |T|}f(T)}
\]</span></p>
<p><span class="math display">\[
f(S) = \sum_{T \supseteq S}\limits{g(T)}\ \ \Longleftrightarrow\ \ g(S) = \sum_{T \supseteq S}\limits{(-1)^{|S| - |T|}f(T)}
\]</span> 前面的式子是 <code>FMT</code> 莫比乌斯变换所加速的式子。</p>
</div>
<p>设：<span class="math inline">\(f(n, S)\)</span> 为 <span class="math inline">\(n\)</span> 个点的 DAG 中 <span class="math inline">\(S\)</span> 中的点度数为 <span class="math inline">\(0\)</span>，类似地，<span class="math inline">\(g(n, S)\)</span> 为 <span class="math inline">\(n\)</span> 个点的 DAG 中 至少 <span class="math inline">\(S\)</span> 中的点度数为 <span class="math inline">\(0\)</span>（钦点）。 易知： <span class="math display">\[
\begin{equation}
g(n, S) = 2^{|S|(n - |S|)}g(n, \varnothing)
\end{equation}
\]</span></p>
<p>其中 <span class="math inline">\(g, f\)</span> 有如下关系。 <span class="math display">\[
\begin{equation}
g(n, S)=\sum_{T \supseteq S}f(n, T)
\end{equation}
\]</span> 根据容斥原理一般公式： <span class="math display">\[
\begin{equation}
f(n, S) = \sum_{T \supseteq S}(-1)^{|S| - |T|}g(n, T)
\end{equation}
\]</span></p>
<p>目的是求出 <span class="math inline">\(g(n, \varnothing)\)</span>： <span class="math display">\[
\begin{split}
g(n, \varnothing) &amp;=\sum_{T \not = \varnothing}f(n, T)\\
&amp;=\sum_{i=1}^{n}\sum_{T, |T|=i}f(n, T)
\end{split}
\]</span> 带入 <span class="math inline">\(g, f\)</span> 的关系式： <span class="math display">\[
\begin{split}
g(n, \varnothing) &amp;=\sum_{T \not = \varnothing}f(n, T)\\
&amp;=\sum_{i=1}^{n}\sum_{T, |T|=i}f(n, T)\\
&amp;=\sum_{i=1}^{n}\sum_{T, |T|=i}  \sum_{S \supseteq T}(-1)^{|S| - |T|}g(n, S)   \\
&amp;=\sum_{i=1}^{n}\sum_{T, |T|=i}  \sum_{S \supseteq T}(-1)^{|S| - |T|}2^{|S|(n-|S|)}g(n-|S|, \varnothing)   \\
&amp;=\sum_{i=1}^{n}\sum_{T, |T|=i}  \sum_{S \supseteq T}(-1)^{|S| - i}2^{|S|(n-|S|)}g(n-|S|, \varnothing)   \\
&amp;=\sum_{i=1}^{n}\sum_{T, |T|=i}  \sum_{k=i}^{n}\dbinom{n-i}{k-i}(-1)^{k - i}2^{k(n-k)}g(n-k, \varnothing)   \\
&amp;=\sum_{i=1}^{n} \dbinom{n}{i}  \sum_{k=i}^{n}\dbinom{n-i}{k-i}(-1)^{k - i}2^{k(n-k)}g(n-k, \varnothing)   \\\
&amp;=\sum_{k=1}^{n}2^{k(n-k)}g(n-k, \varnothing)\sum_{i=1}^{k}\dbinom{n}{i}\dbinom{n-i}{k-i}(-1)^{k-i} \\
&amp;=\sum_{k=1}^{n}2^{k(n-k)}g(n-k, \varnothing)\sum_{i=1}^{k}\dbinom{n}{k}\dbinom{k}{i}(-1)^{k-i} \\
&amp;=\sum_{k=1}^{n}2^{k(n-k)}g(n-k, \varnothing)\dbinom{n}{k}\sum_{i=1}^{k}\dbinom{k}{i}(-1)^{k-i} \\
&amp;=\sum_{k=1}^{n}2^{k(n-k)}g(n-k, \varnothing)\dbinom{n}{k}\left[\left (\sum_{i=0}^{k}\dbinom{k}{i}(-1)^{k-i}1^i \right)- (-1)^k\right] \\
&amp;=\sum_{k=1}^{n}2^{k(n-k)}g(n-k, \varnothing)\dbinom{n}{k}\left[\left ( 1-1 \right)^k- (-1)^k\right] \\
&amp;=\sum_{k=1}^{n}2^{k(n-k)}\dbinom{n}{k}(-1)^{k-1} g(n-k, \varnothing)\\
\end{split}
\]</span></p>
<p>这样的做法是 <span class="math inline">\(\mathcal{O}(n^2)\)</span> 的。</p>
<h2 id="扩展容斥原理">扩展容斥原理</h2>
<h2 id="min-max-容斥">Min-max 容斥</h2>
<p><span class="math display">\[
\begin{equation}\label{max_min}
\operatorname{max} S = \sum_{T \subseteq S} (-1)^{|T| - 1} \operatorname{min} T
\end{equation}
\]</span></p>
<p><span class="math display">\[
\begin{equation}
\operatorname{min} S = \sum_{T \subseteq S} (-1)^{|T| - 1} \operatorname{max} T
\end{equation}
\]</span></p>
<h3 id="pkuwc2018随机游走">「PKUWC2018」随机游走</h3>
<div class="note info"><p>给定一棵 <span class="math inline">\(n\)</span> 个结点的树，你从点 <span class="math inline">\(x\)</span> 出发，每次等概率随机选择一条与所在点相邻的边走过去。</p>
<p>有 <span class="math inline">\(Q\)</span> 次询问，每次询问给定一个集合 <span class="math inline">\(S\)</span>，求如果从 <span class="math inline">\(x\)</span> 出发一直随机游走，直到点集 <span class="math inline">\(S\)</span> 中所有点都至少经过一次的话，期望游走几步。</p>
<p>特别地，点 <span class="math inline">\(x\)</span>（即起点）视为一开始就被经过了一次。</p>
<p>答案对 $998244353 $ 取模。</p>
<p>对于 <span class="math inline">\(100\%\)</span> 的数据，有 <span class="math inline">\(1\leq n\leq 18\)</span>，<span class="math inline">\(1\leq Q\leq 5000\)</span>，<span class="math inline">\(1\leq k\leq n\)</span></p>
</div>
<p>设 <span class="math inline">\(A_i\)</span> 表示到达从 <span class="math inline">\(x\)</span> 点出发第一次到达点 <span class="math inline">\(i\)</span> 的期望时间。</p>
<p>易知：答案就是 <span class="math inline">\(E\left(\max_{i\in S}\limits{(x_i)}\right)\)</span>。需要注意的是： <span class="math inline">\(E\left(\max_{i\in S}\limits{(x_i)}\right) \not = \max_{i \in S}\limits{\left(E(x_i)\right)}\)</span>， 详见<a href="https://www.luogu.com.cn/blog/command-block/min-max-rong-chi-xiao-ji">博文</a></p>
<blockquote>
<p>这是非常有用的，因为期望下的 <span class="math inline">\(\max\)</span> 和 <span class="math inline">\(\min\)</span> 是很难求的。</p>
<p>假设有 <span class="math inline">\(a,b\)</span> 两个不相关变量，则 <span class="math inline">\(E(\max(a,b))≠\max(E(a),E(b))\)</span>。</p>
<p>例子：抛硬币，<span class="math inline">\(a=b=\begin{cases}0(50\%) \\ 1(50\%)\end{cases}\)</span> ,则 <span class="math inline">\(E(a)=E(b)=\dfrac{1}{2}\)</span></p>
<p>那么 <span class="math inline">\(\max(a,b)=\begin{cases}\max(0,0)(25\%)\\ \max(0,1)(25\%)\\ \max(1,0)(25\%)\\ \max(1,1)(25\%)\end{cases}\)</span> ,则 <span class="math inline">\(E(\max(a,b))=0.75\)</span></p>
<p>但是 <span class="math inline">\(\max(E(a),E(b))=0.5\)</span>所以期望不能大力拆 <span class="math inline">\(\max\)</span> 或 <span class="math inline">\(\min\)</span> 。</p>
<p>——引用自 command_block 的博客。</p>
</blockquote>
<p>由 <span class="math inline">\((\ref{max_min})\)</span> 可知： <span class="math display">\[
\begin{equation}
E\left(\max_{i \in S}\limits{x_i}\right)=\sum_{T \subseteq S}(-1)^{|T|-1}E\left(\min_{i \in T}x_i\right)
\end{equation}
\]</span></p>
<p>考虑如何求出 <span class="math inline">\(E\left(\min_{i \in T}\limits{x_i}\right)\)</span></p>
<p>相当于从点 <span class="math inline">\(x\)</span> 出发，首次到达 <span class="math inline">\(T\)</span> 中的任意一点的期望时间。</p>
<p>设 <span class="math inline">\(f(i)\)</span> 表示从结点 <span class="math inline">\(i\)</span> 出发，到达 <span class="math inline">\(T\)</span> 首次中的点的期望时间。</p>
<p>对于 <span class="math inline">\(i \in T, f(i)=0\)</span></p>
<p>对于 <span class="math inline">\(i \notin T, f(i) = \dfrac{1}{deg_i}\left(\sum_{v}\limits{\left(f(v) + 1\right)} + f(fa_i) + 1\right)\)</span></p>
<p><del>据说是</del>经典套路：</p>
<p>待定系数法，设 <span class="math inline">\(f(i)=A_i \times f(fa_i) + B_i\)</span> <span class="math display">\[
\begin{split}
f(i) &amp;= \dfrac{1}{deg_i}\left(\sum_{v}\limits{\left(f(v) + 1\right)} + f(fa_i) + 1\right) \\\\
&amp;= \dfrac{1}{deg_i}\left(\sum_{v}\limits{\left(A_vf(i)+B_v + 1\right)} + f(fa_i) + 1\right) \\\\
&amp;= \dfrac{1}{deg_i -\sum{A_v}} f(fa_i)+\dfrac{deg_i+\sum{B_v}}{deg_i-\sum{A_v}}
\end{split}
\]</span> 所以：<span class="math inline">\(A_i = \dfrac{1}{deg_i -\sum{A_v}}, B_i=\dfrac{deg_i+\sum{B_v}}{deg_i-\sum{A_v}}\)</span></p>
<p>特殊的：对于 <span class="math inline">\(i \in T\)</span> , <span class="math inline">\(A_i = B_i = 0\)</span>。</p>
<p>这里的 <span class="math inline">\(A, B\)</span> 可以直接通过树上 dp 求出。同时，可以递推出 <span class="math inline">\(f(i)\)</span> 的值。</p>
<p>设 <span class="math inline">\(F(T) = (-1)^{|T|-1}f(x)\)</span> ,答案就是 $ _{T S}$</p>
<p>考虑到这东西是子集和变换，使用 FMT (快速莫比乌斯变换) 预处理即可。然后 <span class="math inline">\(O(1)\)</span> 回答。</p>
]]></content>
      <categories>
        <category>学习总结</category>
      </categories>
      <tags>
        <tag>数学</tag>
        <tag>容斥原理</tag>
      </tags>
  </entry>
  <entry>
    <title>「学习总结」数据结构</title>
    <url>//%E3%80%8C%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93%E3%80%8D%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/</url>
    <content><![CDATA[<p><del>真的好爱 <code>Splay</code>!</del></p>
<p>好像只有 <code>LCT</code> 中才有必要写 <code>Splay</code> 吧…… 其实 <code>非旋 Treap</code> 真的是又短，有小，又快……</p>
<a id="more"></a>
<h1 id="数据结构">数据结构</h1>
<h2 id="平衡树">平衡树</h2>
<h3 id="splay">Splay</h3>
<ul>
<li>删除结点时，不是 <code>Splay</code> 到根然后合并两边的子树，而是将待删除的结点前驱 <code>Splay</code> 到根节点， 后继 <code>Splay</code> 到根节点右儿子，那么待删除的结点就在 <code>ls(rs(rt))</code> 上。这样可以删除集合内一个区间的元素，也方便后面维护序列。 <!-- more --> <pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">void erase(int v)&#123;
	PII pre &#x3D; _pred(v), nxt &#x3D; _nxtd(v);
	splay(pre.se); splay(nxt.se, rt);
	int &amp;target &#x3D; ls(rs(rt)); cnt[target] --; si[target]--;
	if(!cnt[target]) target &#x3D; 0;
	maintain(rs(rt)); maintain(ls(rt));  maintain(rt);
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li>
<li>如果空间要求较严格，可以考虑手写一个小的内存管理函数，删除时回收内存，新增元素时优先使用之前删除的结点内存。</li>
</ul>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">stack&lt;int&gt; Mem;
int make()&#123;
	int t; int o &#x3D; (Mem.empty() ? ++tot : (t &#x3D; Mem.top(), Mem.pop(), t));
	ch[o][1] &#x3D; ch[o][0] &#x3D; v[o] &#x3D; fa[o] &#x3D; 0;
	si[o] &#x3D; 1;
	return o;
&#125;
void recycle(int o &#x3D; -1) &#123; if(o &#x3D;&#x3D; -1) o &#x3D; rt; if(!o) return ; Mem.push(o); recycle(ls(o)); recycle(rs(o)); &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<ul>
<li>如果需要开多棵 <code>Splay</code>，可以考虑只封装每棵 <code>Splay</code> 的根节点，对于结点内存的申请和释放统一管理</li>
<li>一个很方便的调试 <code>Splay</code> 的函数： <pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">void dfs(int o &#x3D; -1, int indent &#x3D; 0)&#123;
	if(o &#x3D;&#x3D; -1) o &#x3D; rt;
	if(!o)  &#123; cerr &lt;&lt; string(indent, &#39; &#39;) &lt;&lt; &quot;# null&quot; &lt;&lt; endl; return ; &#125;
	push(o);
	assert(!rs(o) || fa[rs(o)] &#x3D;&#x3D; o); dfs(rs(o), indent + 10);
	cerr &lt;&lt; string(indent, &#39; &#39;) &lt;&lt; &quot;# v&#x3D;&quot; &lt;&lt; val[o] &lt;&lt; &quot; ans&#x3D;&quot; &lt;&lt; v[o].ans &lt;&lt; endl;
	assert(!ls(o) || fa[ls(o)] &#x3D;&#x3D; o); dfs(ls(o), indent + 10);
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li>
<li>建立哨兵结点作为整个 <code>Splay</code> 的最小最大值是一个通用技巧，删除操作依赖于前驱和后继结点，所以哨兵结点时必要的。维护序列时注意消除哨兵结点对答案的影响。</li>
</ul>
<h4 id="维护集合">维护集合</h4>
<p>一种动态维护集合元素，查询集合元素信息的解决方案。 - 为了优化常数和简化代码，查询前驱后继不再采用 <code>插入-删除</code> 式查询。查询元素排名之后直接选取前驱和后继即可。 <pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">PII _pred(int v)&#123;
	PII res &#x3D; rank(rt, v);
	return select(rt, res.fi - 1);
&#125; int pred(int v) &#123; PII res &#x3D; _pred(v); splay(res.se); return res.fi; &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre> - <code>rank</code> 和 <code>select</code> 返回值为 <code>pair&lt;int, int&gt;</code> 其中，前一个指答案，后一个是作用结点，方便后期获取结点信息（<code>Splay</code>）。 <code>int rank(int v) &#123; PII res = rank(rt, v); if(res.se) splay(res.se); return res.fi - 1; &#125;</code></p>
<details class="note info"><summary><p>普通平衡树</p>
</summary>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">struct Splay_t&#123;
	int ch[_][2], cnt[_], si[_], v[_], fa[_], tot, rt;
	typedef pair&lt;int, int&gt; PII;
	#define ls(o) (ch[o][0])
	#define rs(o) (ch[o][1])
	#define maintain(o) (si[o] &#x3D; si[ls(o)] + cnt[o] + si[rs(o)])
	#define get(o) (o &#x3D;&#x3D; ch[fa[o]][1])
	int make(int f, int V)&#123;
		tot++;
		ch[tot][1] &#x3D; ch[tot][0] &#x3D; 0;
		si[tot] &#x3D; cnt[tot] &#x3D; 1;
		fa[tot] &#x3D; f; v[tot] &#x3D; V;
		if(f) ch[f][v[f] &lt; V] &#x3D; tot;
		return tot;
	&#125;
	void rotate(int o)&#123;
		int p &#x3D; fa[o], gp &#x3D; fa[fa[o]], chk &#x3D; get(o);
		ch[p][chk] &#x3D; ch[o][chk^1]; fa[ch[o][chk^1]] &#x3D; p;
		ch[o][chk^1] &#x3D; p; fa[p] &#x3D; o;
		fa[o] &#x3D; gp; if(gp) ch[gp][ch[gp][1] &#x3D;&#x3D; p] &#x3D; o;
		maintain(p); maintain(o);
	&#125;
	void splay(int o, int tgp &#x3D; 0)&#123;
		for(int f &#x3D; fa[o]; f &#x3D; fa[o], f !&#x3D; tgp; rotate(o)) if(fa[f] !&#x3D; tgp) rotate(get(o) &#x3D;&#x3D; get(f) ? f : o);
		if(!tgp) rt &#x3D; o;
	&#125;
	int ins(int o, int f, int V)&#123;
		if(!o) return make(f, V);
		if(v[o] &#x3D;&#x3D; V) return (cnt[o]++, si[o]++, o);
		int r; return (r &#x3D; ins(V &lt; v[o] ? ls(o) : rs(o), o, V), maintain(o), r);
	&#125; void ins(int v) &#123; int t &#x3D; ins(rt, 0, v); splay(t); &#125;

	PII rank(int o, int V)&#123;
		if(!o) return mp(1, 0);
		if(V &#x3D;&#x3D; v[o]) return mp(si[ls(o)] + 1, o);
		PII res;
		if(V &lt; v[o]) return rank(ls(o), V);
		else return (res &#x3D; rank(rs(o), V), res.fi +&#x3D; cnt[o] + si[ls(o)], res);
	&#125; int rank(int v) &#123; PII res &#x3D; rank(rt, v); if(res.se) splay(res.se); return res.fi - 1; &#125;

	PII select(int o, int k)&#123;
		if(k &lt;&#x3D; si[ls(o)]) return select(ls(o), k);
		else &#123;
			if(k &lt;&#x3D; si[ls(o)] + cnt[o]) return mp(v[o], o);
			else return select(rs(o), k - cnt[o] - si[ls(o)]);
		&#125;
	&#125; int select(int k) &#123; PII res &#x3D; select(rt, k + 1); splay(res.se); return res.fi; &#125;

	PII _pred(int v)&#123;
		PII res &#x3D; rank(rt, v);
		return select(rt, res.fi - 1);
	&#125; int pred(int v) &#123; PII res &#x3D; _pred(v); splay(res.se); return res.fi; &#125;

	PII _nxtd(int v)&#123;
		PII res &#x3D; rank(rt, v);
		return select(rt, res.fi + cnt[res.se]);
	&#125; int nxtd(int v) &#123; PII res &#x3D; _nxtd(v); splay(res.se); return res.fi; &#125;

	void erase(int v)&#123;
		PII pre &#x3D; _pred(v), nxt &#x3D; _nxtd(v);
		splay(pre.se); splay(nxt.se, rt);
		int &amp;target &#x3D; ls(rs(rt)); cnt[target] --; si[target]--;
		if(!cnt[target]) target &#x3D; 0;
		maintain(rs(rt)); maintain(ls(rt));  maintain(rt);
	&#125;
	Splay_t()&#123; tot &#x3D; rt &#x3D; 0; ins(INT_MAX); ins(INT_MIN); &#125;
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

</details>
<h4 id="维护序列">维护序列</h4>
<p>一种支持增删元素的，线段树替代方案。 本质上和线段的思想很相似，一样采用信息合并和懒标记优化复杂度，每个结点也和线段树一样存储一个子区间的信息。 唯一不同的就是线段树是一种 <code>Leafy Tree</code>，即所有信息都只存储在叶子结点上，其结构导致无法删除和新增元素。 - 注意懒标记和线段树的定义是一样的，其作用节点的信息首先被修改。类比线段树的懒标记直接写就好了。 - 平衡树合并信息和线段树合并信息不同点在于：线段树是合并两边的信息，平衡树是先合并左子结点信息和中间结点信息再与有子结点合并，其实还是因为线段树是一种 <code>Leafy Tree</code> —— 和平衡树有本质区别。 - 因为 <code>Splay</code> 可以相对较好的控制树的形态，可以让一个子树组成任意区间，所以能够很好的维护序列。 - 核心操作： <pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">void Make_Range(int L, int R)&#123;
	int pre &#x3D; find(rt, L - 1), suf &#x3D; find(rt, R + 1);
	splay(pre); splay(suf, rt);
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre> <details class="note info"><summary><p>「NOI2005」维护数列</p>
</summary>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">const int _ &#x3D; 5e5 + 10;
struct Splay_t&#123;
	stack&lt;int&gt; Mem;
    #define none (-30000)
    struct data_t&#123;
        int sum, per, suf, ans;
        data_t()&#123; per &#x3D; suf &#x3D; ans &#x3D; -1e9; sum &#x3D; 0; &#125;;
        data_t(int V) &#123; sum &#x3D; per &#x3D; suf &#x3D; ans &#x3D; V; &#125;
        void ret(int v, int len)&#123;
            if(v &lt;&#x3D; 0) suf &#x3D; per &#x3D; ans &#x3D; v, sum &#x3D; v * len; &#x2F;&#x2F; changed &#96;sum &#x3D; v&#96; to &#96;sum &#x3D; v * len&#96;.
            else       sum &#x3D; suf &#x3D; per &#x3D; ans &#x3D; v * len;
        &#125;
        void rev() &#123; swap(per, suf); &#125;
        data_t operator + (const data_t &amp; B) &#123;
	        data_t A &#x3D; *this, res;
	        res.sum &#x3D; A.sum + B.sum;
	        res.per &#x3D; max(A.per, A.sum + B.per);
	        res.suf &#x3D; max(A.suf + B.sum, B.suf);
	        res.ans &#x3D; max(max(A.ans, B.ans), A.suf + B.per);
	        return res;
	    &#125;
    &#125;;

    int ch[_][2], fa[_], si[_], rt, tot; data_t v[_];
    short val[_];
	bool tag_rev[_]; short tag_ret[_];
    #define ls(o) (ch[o][0])
    #define rs(o) (ch[o][1])
    #define maintain(o) (si[o] &#x3D; si[ls(o)] + si[rs(o)] + 1, v[o] &#x3D; v[ls(o)] + data_t(val[o]) + v[rs(o)])
    #define get(o) (ch[fa[o]][1] &#x3D;&#x3D; o)
    int make()&#123;
    	if(!Mem.empty())&#123;
    		int o &#x3D; Mem.top(); Mem.pop();
    		tag_ret[o] &#x3D; none;
			tag_rev[o] &#x3D; false;
			ch[o][1] &#x3D; ch[o][0] &#x3D; si[o] &#x3D; val[o] &#x3D; fa[o] &#x3D; 0;
			v[o] &#x3D; data_t();
			return o;
		&#125; else &#123;
			tot++;
			tag_ret[tot] &#x3D; none;
			tag_rev[tot] &#x3D; false;
			ch[tot][1] &#x3D; ch[tot][0] &#x3D; si[tot] &#x3D; val[tot] &#x3D; fa[tot] &#x3D; 0;
			v[tot] &#x3D; data_t();
			return tot;
		&#125;

	&#125;
	void recycle(int o)&#123; if(!o) return ; Mem.push(o); recycle(ls(o)); recycle(rs(o)); &#125;

    Splay_t() &#123; rt &#x3D; tot &#x3D; 0; &#125;
    void tar_rev(int o)&#123;
        v[o].rev();
        swap(ls(o), rs(o));
        tag_rev[o] ^&#x3D; 1;
    &#125;
    void tar_ret(int o, int V)&#123;
        v[o].ret(V, si[o]);
		val[o] &#x3D; V;
        tag_ret[o] &#x3D; V;
    &#125;
    void push(int o)&#123;
        if(tag_ret[o] !&#x3D; none)&#123;
            if(ls(o)) tar_ret(ls(o), tag_ret[o]);
            if(rs(o)) tar_ret(rs(o), tag_ret[o]);
            tag_ret[o] &#x3D; none;
        &#125;
        if(tag_rev[o])&#123;
            if(ls(o))tar_rev(ls(o));
            if(rs(o))tar_rev(rs(o));
            tag_rev[o] &#x3D; 0;
        &#125;
    &#125;
    void rotate(int o)&#123;
        int p &#x3D; fa[o], gp &#x3D; fa[fa[o]], chk &#x3D; get(o);
        ch[p][chk] &#x3D; ch[o][chk ^ 1]; fa[ch[o][chk ^ 1]] &#x3D; p;
        ch[o][chk ^ 1] &#x3D; p; fa[p] &#x3D; o;
        fa[o] &#x3D; gp; if(gp) ch[gp][ch[gp][1] &#x3D;&#x3D; p] &#x3D; o;
        maintain(p); maintain(o);
    &#125;
    void splay(int o, int tgp &#x3D; 0)&#123;
        for(int f &#x3D; fa[o]; f &#x3D; fa[o], f !&#x3D; tgp; rotate(o))&#123;
            push(f); push(o);
            if(fa[f] !&#x3D; tgp) rotate(get(o) &#x3D;&#x3D; get(f) ? f : o);
        &#125;
        if(!tgp) rt &#x3D; o; &#x2F;&#x2F; changed &#96;rt &#x3D; tgp&#96;  to &#96;rt &#x3D; o&#96;.
    &#125;
    void build_sub(int &amp;o, int f, int L, int R, int *A)&#123;
        if(L &gt; R) return ;
        int mid &#x3D; (L + R) &gt;&gt; 1;
        o &#x3D; make(); fa[o] &#x3D; f; val[o] &#x3D; A[mid]; v[o] &#x3D; data_t(A[mid]); si[o] &#x3D; 1;
        if(L &#x3D;&#x3D; R) return ;
        if(L &lt;&#x3D; mid - 1) build_sub(ls(o), o, L, mid - 1, A);
        if(mid + 1 &lt;&#x3D; R) build_sub(rs(o), o, mid + 1, R, A);
        maintain(o);
    &#125;
	void build(int L, int R, int *A)&#123;
		build_sub(rt, 0, L, R, A);
	&#125;

    int insert(int &amp;o, int f, int target, int *A, int len)&#123;
        if(!o) return build_sub(o, f, 1, len, A), o;
        int r &#x3D; 0; push(o);
        if(target &lt;&#x3D; si[ls(o)]) r &#x3D; insert(ls(o), o, target, A, len);
        else r &#x3D; insert(rs(o), o, target - si[ls(o)] - 1, A, len);
        maintain(o); return r;
    &#125; void insert(int *A, int pos, int len) &#123; int r &#x3D; insert(rt, 0, pos, A, len); splay(r); &#125;

    int find(int o, int k)&#123;
        push(o);
        if(k &lt;&#x3D; si[ls(o)]) return find(ls(o), k);
        else &#123;
            if(k &lt;&#x3D; si[ls(o)] + 1) return o;
            else return find(rs(o), k - 1 - si[ls(o)]);
        &#125;
    &#125;
    void Make_Range(int L, int R)&#123;
        int per &#x3D; find(rt, L - 1), suf &#x3D; find(rt, R + 1);
        splay(per); splay(suf, rt);
    &#125;
    void erase(int L, int R)&#123;
        Make_Range(L, R);
        int &amp; target &#x3D; ls(rs(rt));
        recycle(target); target &#x3D; 0; maintain(rs(rt)); maintain(rt);
    &#125;
    void rev(int L, int R)&#123;
        Make_Range(L, R);
        int &amp; target &#x3D; ls(rs(rt));
        tar_rev(target); maintain(rs(rt)); maintain(rt);
    &#125;
    void ret(int L, int R, int V)&#123;
        Make_Range(L, R);
        int &amp; target &#x3D; ls(rs(rt));
        tar_ret(target, V); maintain(rs(rt)); maintain(rt);
    &#125;
    int query_sum(int L, int R)&#123;
        Make_Range(L, R);
        int &amp; target &#x3D; ls(rs(rt));
        return v[target].sum;
    &#125;
    int query_ans()&#123;
        return v[rt].ans;
    &#125;
   void dfs(int o &#x3D; -1, int indent &#x3D; 0)&#123;
   	if(o &#x3D;&#x3D; -1) o &#x3D; rt;
   	if(!o)  &#123; cerr &lt;&lt; string(indent, &#39; &#39;) &lt;&lt; &quot;# null&quot; &lt;&lt; endl; return ; &#125;
   	push(o);
   	if(rs(o)) assert(fa[rs(o)] &#x3D;&#x3D; o); dfs(rs(o), indent + 10);
   	cerr &lt;&lt; string(indent, &#39; &#39;) &lt;&lt; &quot;# v&#x3D;&quot; &lt;&lt; val[o] &lt;&lt; &quot; ans&#x3D;&quot; &lt;&lt; v[o].ans &lt;&lt; endl;
   	if(ls(o)) assert(fa[ls(o)] &#x3D;&#x3D; o); dfs(ls(o), indent + 10);
	&#125;
&#125;;
Splay_t t;
int A[_], n, m;
char opt[100];
int main()&#123; &#x2F;&#x2F;freopen(&quot;.in&quot;, &quot;r&quot;, stdin); freopen(&quot;.out&quot;, &quot;w&quot;, stdout);
    Read(n)(m); n +&#x3D; 2; rep(i, 2, n - 1) Read(A[i]);
	A[1] &#x3D; A[n] &#x3D; none; &#x2F;&#x2F; added line &#96;A[1] &#x3D; A[n] &#x3D; -inf&#96;.
    t.build(1, n, A);
    rep(tt, 1, m)&#123;
        scanf(&quot;%s&quot;, opt); char sign0 &#x3D; opt[0], sign1 &#x3D; opt[3];
        if(sign0 &#x3D;&#x3D; &#39;I&#39;) &#123; &#x2F;&#x2F; Insert a sequence.
            int pos, tot; Read(pos)(tot); rep(i, 1, tot) Read(A[i]); pos++;
            t.insert(A, pos, tot);
        &#125; else if(sign0 &#x3D;&#x3D; &#39;D&#39;)&#123; &#x2F;&#x2F; Delete a sequence.
            int pos, tot; Read(pos)(tot); pos++;
            t.erase(pos, pos + tot - 1);
        &#125; else if(sign0 &#x3D;&#x3D; &#39;R&#39;)&#123; &#x2F;&#x2F; Reverse a sequence.
            int pos, tot; Read(pos)(tot); pos++;
            t.rev(pos, tot + pos - 1);
        &#125; else if(sign0 &#x3D;&#x3D; &#39;G&#39;)&#123; &#x2F;&#x2F; calc the sum of sequence.
            int pos, tot; Read(pos)(tot); pos++;
            printf(&quot;%d\n&quot;, t.query_sum(pos, pos + tot - 1));
        &#125; else if(sign1 &#x3D;&#x3D; &#39;-&#39;)&#123; &#x2F;&#x2F; calc the max sum sub sequence.
            printf(&quot;%d\n&quot;, t.query_ans());
        &#125; else &#123; &#x2F;&#x2F; make same on the sequence.
            int pos, tot, c; Read(pos)(tot)(c); pos++;
            t.ret(pos, pos + tot - 1, c);
        &#125;
    &#125;
    return 0;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

</details></p>
<h3 id="非旋-treap">非旋 Treap</h3>
<p>udp：2021/01/02. u1s1，这东西又短 又小 又快。<code>splay</code> 可能真的只有 <code>LCT</code> 里面才出场了。 <pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">int rand()&#123;
	static int seed &#x3D; 1020031005;
	return seed &#x3D; ((seed +0ll+ 20031006) % 998244353);
&#125;
namespace FHQ&#123;
    const int _ &#x3D; 1e5 + 100;
    int ch[_][2], si[_], v[_], tot &#x3D; 0, rt &#x3D; 0;
    #define ls(o) (ch[o][0])
    #define rs(o) (ch[o][1])
    #define maintain(o) (void)(si[o] &#x3D; si[ls(o)] + si[rs(o)] + 1)
    #define make(vs) (++tot, v[tot] &#x3D; vs, si[tot] &#x3D; 1, ch[tot][0] &#x3D; ch[tot][1] &#x3D; 0, tot)
    #define mg(a, b, c) (merge(merge(a, b), c))
    void split(int o, int V, int &amp;x, int &amp;y)&#123;
        if(!o) return (void)(x &#x3D; y &#x3D; 0);
        if(v[o] &lt;&#x3D; V) return x &#x3D; o, split(rs(o), V, rs(o), y), maintain(o);
        return y &#x3D; o, split(ls(o), V, x, ls(o)), maintain(o);
    &#125;
    int merge(int x, int y)&#123;
        if(x &#x3D;&#x3D; 0 || y &#x3D;&#x3D; 0) return x + y;
        if(rand() % (si[x] + si[y]) + 1 &lt;&#x3D; si[x]) return rs(x) &#x3D; merge(rs(x), y), maintain(x), x;
        else return ls(y) &#x3D; merge(x, ls(y)), maintain(y), y;
    &#125;
    void ins(int x)&#123; int t0, t1 &#x3D; make(x), t2; split(rt, x, t0, t2); rt &#x3D; mg(t0, t1, t2); &#125;
    void erase(int V)&#123; int x, y, z; split(rt, V, y, z); split(y, V - 1, x, y); y &#x3D; merge(ls(y), rs(y)); rt &#x3D; mg(x, y, z); &#125;
    int rank(int V) &#123; int x, y; split(rt, V - 1, x, y); int res &#x3D; si[x]; rt &#x3D; merge(x, y); return res + 1; &#125;
    int select(int V, int o &#x3D; -1)&#123; if(o &#x3D;&#x3D; -1) o &#x3D; rt; if(V &lt;&#x3D; si[ls(o)]) return select(V, ls(o)); else &#123; if(V &lt;&#x3D; si[ls(o)] + 1) return v[o]; else return select(V - si[ls(o)] - 1, rs(o)); &#125; &#125;
    int pred(int V)&#123; int x, y; split(rt, V - 1, x, y); int res &#x3D; select(si[x], x); rt &#x3D; merge(x, y); return res; &#125;
    int succ(int V)&#123; int x, y; split(rt, V, x, y); int res &#x3D; select(1, y); rt &#x3D; merge(x, y); return res; &#125;
&#125; using FHQ:: ins ;using FHQ:: erase ;using FHQ:: select ;using FHQ:: rank ;using FHQ:: pred ;using FHQ:: succ ;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></p>
]]></content>
      <categories>
        <category>琐记</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>平衡树</tag>
      </tags>
  </entry>
  <entry>
    <title>「学习总结」数论再探</title>
    <url>//%E3%80%8C%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93%E3%80%8D%E6%95%B0%E8%AE%BA%E5%86%8D%E6%8E%A2/</url>
    <content><![CDATA[<p>结束了<a href="/oi-blog/「学习总结」整数模%20n%20乘法群">「学习总结」整数模 n 乘法群</a> 之后，发现数论还有很多东西妹学。 (T__T). 一直没有发表</p>
<a id="more"></a>
<h2 id="数论初探">数论初探</h2>
<p><a href="/oi-blog/「学习总结」数论">「学习总结」数论</a></p>
<h2 id="整数模-n-乘法群">整数模 n 乘法群</h2>
<p><a href="/oi-blog/「学习总结」整数模%20n%20乘法群">「学习总结」整数模 n 乘法群</a></p>
<h2 id="库默尔定理">库默尔定理</h2>
<p>令 <span class="math inline">\(V_p(n)\)</span> 表示 <span class="math inline">\(n\)</span> 中素因子 <span class="math inline">\(P\)</span> 的次数，有： <span class="math display">\[
V_p\left(\dbinom{n}{m}\right)
\]</span> 的值为 <span class="math inline">\(m\)</span> 与 <span class="math inline">\(n-m\)</span> 在 <span class="math inline">\(P\)</span> 进制下加法的进位次数。</p>
<p>另一个事实是，<span class="math inline">\(n!\)</span> 中质因子 <span class="math inline">\(p​\)</span> 的幂次为： <span class="math display">\[
\frac{n-f_p(n)}{p-1}
\]</span> <span class="math inline">\(f_p(n)\)</span> 为 <span class="math inline">\(n\)</span> 在 <span class="math inline">\(p\)</span> 进制下的数位和。</p>
<h2 id="二次剩余">二次剩余</h2>
<p>一个数 <span class="math inline">\(a\)</span>，如果不是 <span class="math inline">\(p\)</span> 的倍数且模 <span class="math inline">\(p\)</span> 同余于某个数的平方，则称 <span class="math inline">\(a\)</span> 为模 <span class="math inline">\(p\)</span> 的 <strong>二次剩余</strong>。</p>
<p>而一个不是 <span class="math inline">\(p\)</span> 的倍数的数 <span class="math inline">\(b\)</span>，不同余于任何数的平方，则称 <span class="math inline">\(b\)</span> 为模 <span class="math inline">\(p\)</span> 的 <strong>非二次剩余</strong>。</p>
<h3 id="勒让德符号">勒让德符号</h3>
<p><span class="math display">\[
\left(\frac{n}{p}\right)=
\begin{cases} 1 &amp;p\nmid n \text{且}n\text{是}p\text{的二次剩余}\\
-1&amp;p\nmid n \text{且}n\text{不是}p\text{的二次剩余}\\
0&amp;p\mid n
\end{cases}
\]</span></p>
<h3 id="欧拉准则">欧拉准则</h3>
<p><span class="math display">\[
\left(\frac{n}{p}\right)\equiv n^{\frac{p-1}{2}}\pmod p
\]</span></p>
<h3 id="剩余系开根">剩余系开根</h3>
<p><strong>Cipolla算法</strong></p>
<p>给出正整数 <span class="math inline">\(n\)</span> 求出模 <span class="math inline">\(p\)</span> 意义下的 <span class="math inline">\(\sqrt n\)</span>。</p>
<p>背过程：</p>
<p>随机一个 <span class="math inline">\(n\)</span> 的剩余系下整数 <span class="math inline">\(a\)</span> ，满足 <span class="math inline">\(a^2-n\)</span> 不是二次剩余。</p>
<p>设剩余系下虚数单位 <span class="math inline">\(\mathbf{i}=\sqrt{a^2-n}\)</span></p>
<p>则 <span class="math inline">\(\sqrt n \equiv (a + \mathbf{i})^{\frac{p+1}{2}} \pmod{p}\)</span></p>
<h4 id="一道例题">一道例题</h4>
<p><a href="https://www.luogu.com.cn/problem/P6610">Code+#7 同余方程</a></p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">int np[_], prime[_], tot, d[_], x;
void Prime(int n) &#123;
	for(int i &#x3D; 2; i &lt;&#x3D; n; i++)&#123;
		if(!np[i]) prime[++tot] &#x3D; i, d[i] &#x3D; i;
		for(int j &#x3D; 1; j &lt;&#x3D; tot &amp;&amp; (x &#x3D; prime[j] * i) &lt;&#x3D; n; j++)&#123;
			np[x] &#x3D; 1; d[x] &#x3D; prime[j];
			if(i % prime[j] &#x3D;&#x3D; 0) break;
		&#125;
	&#125;
&#125;
pair&lt;int, int&gt; IN[_];
int main()&#123;
	int n; IO &gt;&gt; n; int MAX &#x3D; 0;
	for(int i &#x3D; 1; i &lt;&#x3D; n; i++) (IO &gt;&gt; IN[i].first &gt;&gt; IN[i].second), MAX &#x3D; max(MAX, IN[i].first) ;
	Prime(MAX + 1);
	for(int i &#x3D; 1; i &lt;&#x3D; n; i++) &#123;
		int p &#x3D; IN[i].first, x &#x3D; IN[i].second; LL ret &#x3D; 1;
		while(p !&#x3D; 1)&#123;
			int now &#x3D; d[p];
			if(x % now &#x3D;&#x3D; 0) ret *&#x3D; (now % 4 &#x3D;&#x3D; 1 ? ((now &lt;&lt; 1) - 1) : 1);
			else ret *&#x3D; (((now % 4 &#x3D;&#x3D; 1) ? -1 : 1) + now);
			p &#x2F;&#x3D; d[p];
		&#125;
		printf(&quot;%lld\n&quot;, ret);
	&#125;
	return 0;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
]]></content>
      <categories>
        <category>学习总结</category>
      </categories>
      <tags>
        <tag>数学</tag>
        <tag>数论</tag>
      </tags>
  </entry>
  <entry>
    <title>「学习总结」整数模 n 乘法群</title>
    <url>//%E3%80%8C%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93%E3%80%8D%E6%95%B4%E6%95%B0%E6%A8%A1-n-%E4%B9%98%E6%B3%95%E7%BE%A4/</url>
    <content><![CDATA[<p>对于 <strong>任意</strong> 一个正整数 <span class="math inline">\(n\)</span> ，<span class="math inline">\(1 \sim n\)</span> 中与 <span class="math inline">\(n\)</span> 互质的 <span class="math inline">\(\varphi(n)\)</span> 个数字组成的集合记作 <span class="math inline">\(\mathbb{Z}^*_n\)</span>。</p>
<p>事实上，由 <span class="math inline">\(\mathbb{Z}_n^*\)</span> 和模 <span class="math inline">\(n\)</span> 意义下的乘法组成的代数系统 <span class="math inline">\((\mathbb{Z}^*_n, \times )\)</span> 是一个<a href="/oi-blog/「学习总结」群-置换群">群</a>。</p>
<p>从这一点出发理解原根和阶往往有很多奇妙的感受…</p>
<a id="more"></a>
<h2 id="几点补充">几点补充</h2>
<h3 id="欧拉函数">欧拉函数</h3>
<p><span class="math inline">\(n=\prod \limits{p_i^{e_i}}\)</span></p>
<p><span class="math display">\[
\varphi(n) = \prod\limits{p_i^{e_i-1}(p_i-1)}
\]</span></p>
<p><strong>欧拉函数</strong>是一个经典的积性函数。</p>
<h3 id="群的直积">群的直积</h3>
<p>又名 <strong>笛卡尔（Descartes）积</strong> ，其定义如下：</p>
<p>设 <span class="math inline">\((G_1, *) \times (G_2, \cdot) = (G, \oplus)\)</span></p>
<p>其中</p>
<ul>
<li><span class="math inline">\(\times\)</span> 为两个群的笛卡尔积。</li>
<li><span class="math inline">\(G = \{(a, b)\ | \ a \in G_1, b\in G_2\}\)</span></li>
<li><span class="math inline">\(\oplus\)</span> 定义为 <span class="math inline">\((a_1, b_1) \oplus (a_2, b_2) =(a_1 * a_2, b_1 \cdot b_2)\)</span></li>
</ul>
<h3 id="原根"><a href="/oi-blog/「学习总结」数论">原根</a></h3>
<p>若 <span class="math inline">\(g\)</span> 为 <span class="math inline">\(n\)</span> 的原根，等价于 <span class="math inline">\(g \perp n, g^0 \sim g^{\varphi(n)-1} \mod n\)</span> 互不相同，等价于 <span class="math inline">\(g \perp n,\ \forall i \in [1, \varphi(n)-1], g^i \not = 1\)</span>. （<span class="math inline">\(x \perp y\)</span> 表示 <span class="math inline">\(x, y\)</span> 互质）</p>
<p>一个数 <span class="math inline">\(n\)</span> 有原根当且仅当 <span class="math inline">\(n = 2,4,p^k, 2p^k\)</span> 其中 <span class="math inline">\(p\)</span> 为奇素数。</p>
<p>小结论：若一个正整数 <span class="math inline">\(n\)</span> 有原根，则其原根数量恰好为 <span class="math inline">\(\varphi(\varphi(n))\)</span> 。</p>
<h3 id="阶"><a href="/oi-blog/「学习总结」数论">阶</a></h3>
<p>若 <span class="math inline">\(a \perp n\)</span>，则使 <span class="math inline">\(a^k \equiv 1 \pmod n\)</span> 成立的 <strong>最小</strong> 正整数 <span class="math inline">\(k\)</span>，称为 <span class="math inline">\(a\)</span> 模 <span class="math inline">\(n\)</span> 意义下的阶，记作 <span class="math inline">\(\text{ord}_n(a)\)</span>。 可以发现若 <span class="math inline">\(g\)</span> 为模 <span class="math inline">\(n\)</span> 意义下原根，那么 <span class="math inline">\(\operatorname{ord}_n(g) = \varphi(n)\)</span>。</p>
<h2 id="整数模-n-乘法群">整数模 <span class="math inline">\(n\)</span> 乘法群</h2>
<h3 id="定义">定义</h3>
<p>对于 <strong>任意</strong> 一个正整数 <span class="math inline">\(n\)</span> ，<span class="math inline">\(1 \sim n\)</span> 中与 <span class="math inline">\(n\)</span> 互质的 <span class="math inline">\(\varphi(n)\)</span> 个数字组成的集合记作 <span class="math inline">\(\mathbb{Z}^*_n\)</span>。</p>
<p>事实上，由 <span class="math inline">\(\mathbb{Z}_n^*\)</span> 和模 <span class="math inline">\(n\)</span> 意义下的乘法组成的代数系统 <span class="math inline">\((\mathbb{Z}^*_n, \times )\)</span> 是一个<a href="/oi-blog/「学习总结」群%20置换群">群</a>。</p>
<p>这一点可以考虑 <span class="math inline">\(\mathbb{Z}^*_n\)</span> 中元素所包含的质因子，可以发现是显然的。</p>
<p>因为任意一个处于 <span class="math inline">\(n​\)</span> 的剩余系中且不与 <span class="math inline">\(n​\)</span> 互质的元素 <span class="math inline">\(x​\)</span>，都可以除掉 <span class="math inline">\(\gcd(x, n)​\)</span> 放到 <span class="math inline">\(\frac{n}{\gcd(n, x)}​\)</span> 的剩余系内考虑，所以这里只讨论 <span class="math inline">\(n​\)</span> 的剩余系中与 <span class="math inline">\(n​\)</span> 互质的元素组成的集合，即 <span class="math inline">\(\mathbb{Z}_n^*​\)</span>（称其为 <span class="math inline">\(n​\)</span> 的简化剩余系），当然也因为 <del>我不会</del> <span class="math inline">\(\mathbb{Z}_n^*​\)</span> 的性质实在是太美了。</p>
<h3 id="离散对数">离散对数</h3>
<p>若 <span class="math inline">\(n\)</span> 存在原根，取任意一个 <span class="math inline">\(n\)</span> 的原根 <span class="math inline">\(g\)</span> ，则对于 <span class="math inline">\(\mathbb{Z}^*_n\)</span> 中的一个每个元素 <span class="math inline">\(x\)</span> ，都存在唯一的 <span class="math inline">\(k \in [0, \varphi(n)-1]\)</span> ，使得 <span class="math inline">\(g^k =x​\)</span>。</p>
<p>可以得出 <span class="math inline">\([0, \varphi(n)-1] \cap \mathbb{Z}\)</span> 中的元素与 <span class="math inline">\(\mathbb{Z}_n^*\)</span> 中的元素之间一一对应。</p>
<p>可以建立函数 <span class="math inline">\(f(x)\)</span> 表示 <span class="math inline">\(\mathbb{Z}_n^*\)</span> 向 <span class="math inline">\([0, \varphi(n)-1] \cap \mathbb{Z}\)</span> 的映射。可以形象的称 <span class="math inline">\(f(x)\)</span> 为 <strong>离散对数</strong>。这里满足很多实数定义下对数的性质。需要注意离散对数间的运算是定义在 <span class="math inline">\(\mod \varphi(n)\)</span> 意义下的。</p>
<h3 id="原根不存在的剩余系下离散对数的定义">原根不存在的剩余系下离散对数的定义</h3>
<p>离散对数的取值依赖于原根的选取，所以只有 <span class="math inline">\(n​\)</span> 存在原根时， <span class="math inline">\(\mathbb{Z}_n^*​\)</span> 中的元素才存在 <strong>直接的</strong> 的离散对数。</p>
<p>可以利用类似于中国剩余定理的一般思想，将 <span class="math inline">\(n​\)</span> 分解为质数幂的形式，分别求出 <span class="math inline">\(x​\)</span> 在每个 <span class="math inline">\(p_i^k​\)</span> 剩余系下的离散对数 <span class="math inline">\(a_i​\)</span>，则可以用 <span class="math inline">\((a_0, a_1, a_2,\cdots )​\)</span> 这样的 "坐标" 来类似地定义 <span class="math inline">\(x​\)</span> 在 <span class="math inline">\(n​\)</span> 剩余系下的 “离散对数”。根据中国剩余定理，可以发现这样的 “坐标” 是能够实现和原数一一对应的。</p>
<p>可以先考虑原根存在的 <span class="math inline">\(\mathbb{Z}_n^*​\)</span>，对 <span class="math inline">\(\mathbb{Z}_n^*​\)</span> 中的每一个元素取离散对数（不妨设这里的原根取最小的原根）放入一个集合 <span class="math inline">\(G​\)</span>，然后重新定义群 乘法运算为模 <span class="math inline">\(\varphi(n)​\)</span> 意义下的 <strong>加法</strong>，这样 <span class="math inline">\((G, \times)​\)</span> 也能够形成一个群。不妨用 <span class="math inline">\(G_n​\)</span> 来表示这个群。</p>
<p>类似地定义原根不存在的 <span class="math inline">\(\mathbb{Z}_m^*\)</span>，设 <span class="math inline">\(m=\prod_{i=1}^{s}\limits{P_i^{e_i}}\)</span> 。</p>
<p>他们的 “离散对数” 形成的群可以表示为 <span class="math inline">\(G_{P_1^{e_1}}\times G_{P_2^{e_2}} \times G_{P_3^{e_3}}\times\cdots\times G_{P_s^{e_s}}\)</span> ，其中 <span class="math inline">\(\times​\)</span> 为定义在群上的直积。</p>
<p>值得一提的是：可以发现，两个群做直积，得到的群的阶为之前两个群的阶的乘积，可以发现，这和欧拉函数的积性是相符的。</p>
<p>这好像没有什么用，只是可以帮助理解或者得到一些小结论吧。</p>
<h3 id="模-2kk2-意义下的离散对数">模 <span class="math inline">\(2^k(k&gt;2)\)</span> 意义下的离散对数</h3>
<p>注意到，<span class="math inline">\(2^k(k&gt;2)\)</span> 也是没有原根的。</p>
<p>定义 <span class="math inline">\(2^k (k &gt; 2)​\)</span> 意义下的 “离散对数” 需要如下两个结论</p>
<p><span class="math display">\[
\operatorname{ord}_{2^k}(5)=2^{k-2}
\]</span></p>
<p>而且对于任意一个 <span class="math inline">\(2^k\)</span> 的简化剩余系下能表示成形如 <span class="math inline">\(5^\alpha\)</span> 的元素 <span class="math inline">\(x\)</span>，<span class="math inline">\(-x\)</span> 一定不能表示成形如 <span class="math inline">\(5^\alpha​\)</span> 的元素。</p>
<p><strong>一个栗子</strong></p>
<p>当 <span class="math inline">\(k=4\)</span> 时，即 <span class="math inline">\(16=2^4\)</span>。</p>
<p><span class="math inline">\(\mathbb{Z}_{16}^*=\{1, 3, 5, 7, 9, 11, 13, 15\}\)</span></p>
<p><span class="math inline">\(5^0=1, 5^1=5, 5^2=9, 5^3=13, 5^4=1\)</span></p>
<p><span class="math inline">\(\operatorname{ord}_{16}(5)=4=2^{k-2}=2^2\)</span></p>
<p>且 <span class="math inline">\(-1\equiv 15, -5\equiv 11, -9\equiv 7, -15\equiv 2\)</span> 这些数字都没有在上面出现过。</p>
<p>简单来说就是 <span class="math inline">\(2^k\)</span> 的简化剩余系下（大小为 <span class="math inline">\(2^{k-1}\)</span>），有恰好一半的数字可以表示成 <span class="math inline">\(5^\alpha \mod 2^k\)</span>，恰好一半不可以，这两部分元素一一对应，互为剩余系下的相反数。</p>
<p>所以，可以把模 <span class="math inline">\(2^k (k&gt;2)\)</span> 意义下的循环群看成是两个原根为 <span class="math inline">\(5\)</span> 和 <span class="math inline">\(-1\)</span> 的乘法群的直积。</p>
<p>其中的元素 <span class="math inline">\(x​\)</span> 的离散对数形如 <span class="math inline">\((a, b)​\)</span> 表示 <span class="math inline">\(5^a \times (-1)^b​\)</span>。</p>
<h3 id="从乘法群的角度考虑原根和阶">从乘法群的角度考虑原根和阶</h3>
<p>对于任意正整数 <span class="math inline">\(n​\)</span> ，<span class="math inline">\(n​\)</span> 的简化剩余系中的取任意一个数字 <span class="math inline">\(x​\)</span>。</p>
<p>设 <span class="math inline">\(S_x=\{x^0, x^1, x^2,\cdots\}\)</span> ，可以发现如果定义集合 <span class="math inline">\(S\)</span> 的乘法运算为模 <span class="math inline">\(n\)</span> 意义下的乘法，那么这东西就是 <span class="math inline">\((\mathbb{Z}_n^*, \times)\)</span> 的一个子群…这里 <span class="math inline">\(|S_x|\)</span> （群 <span class="math inline">\((S_x, \times)\)</span> 的阶）就可以称为 <span class="math inline">\(x\)</span> 在模 <span class="math inline">\(n\)</span> 意义下的阶。</p>
<p>把剩余系的环和群的环结合着理解一下，可以发现这个定义和原先的定义是等价的。</p>
<p>根据这个东西，不难发现： <span class="math display">\[
|S_x|=\frac{\varphi(n)}{\gcd(f(x), \varphi(n))}
\]</span></p>
<p>这里的 <span class="math inline">\(f(x)​\)</span> 为 <span class="math inline">\(x​\)</span> 在任意原根意义下的离散对数。</p>
<p>存在一个显然的事实：一个常数 <span class="math inline">\(x​\)</span> 的所有倍数模 <span class="math inline">\(m​\)</span> 能够取到所有形如 <span class="math inline">\(k\cdot\gcd(x, m)​\)</span> 的数（<span class="math inline">\(k \in \mathbb{Z^*}​\)</span>）。</p>
<p>从 <span class="math inline">\(n\)</span> 的某个原根意义下离散对数的角度考虑， <span class="math inline">\(S_x\)</span> 可以看作 “所有离散对数为 <span class="math inline">\(\gcd(f(x), \varphi(n))\)</span> 的倍数的元素” 组成的集合，这样的数字显然有 <span class="math inline">\(\frac{\varphi(n)}{\gcd(f(x), \varphi(n))}​\)</span> 个，也就是循环子群的阶数。</p>
<p>之后的问题中，如果不好考虑某个引理，可以转化为选取一个原根后，对每个元素，求其离散对数，然后扔到一个剩余系环上考虑。即使是关于原根本身的引理，也可以用这样的方法证明。</p>
<p>可以发现，我们想要的原根 <span class="math inline">\(x\)</span>，满足 <span class="math inline">\(x\)</span> 的循环子群能够取遍原来群中所有元素，即 <span class="math inline">\(f(x) \perp \varphi(n)\)</span> 。</p>
<p>考虑一下原根的数量，对于任意一个正整数 <span class="math inline">\(n\)</span> ，其简化剩余系阶为 <span class="math inline">\(\varphi(n)\)</span> ，每个数字取离散对数，指数和 <span class="math inline">\(\varphi(n)\)</span> 互质的即可成为原根，这样的数字有 <span class="math inline">\(\varphi(\varphi(n))\)</span> 个。事实上，这是原根数量的精确值。</p>
<p>对于 <strong>任意</strong> 一个正整数 <span class="math inline">\(n\)</span> ，若其剩余系存在原根，则原根数恰好为 <span class="math inline">\(\varphi(\varphi(n))\)</span>.</p>
<h2 id="实现上的相关问题">实现上的相关问题</h2>
<p>什么求原根、求阶和求离散对数之类的人间烟火，可以查看 <a href="/oi-blog/「学习总结」数论">「学习总结」数论</a></p>
<h2 id="相关栗题">相关栗题</h2>
<h3 id="debris">debris</h3>
<p>给定素数 <span class="math inline">\(P\)</span>，求满足 <span class="math inline">\(1 \le n, m\le P(P-1)\)</span> 且 <span class="math inline">\(n^m \equiv m^n \pmod{P}\)</span> 的数对 <span class="math inline">\((n, m)\)</span> 个数。</p>
<p>答案对素数 <span class="math inline">\(M\)</span> 取模。 数据组数 <span class="math inline">\(T \le 100, P \le 10^{12}, M \le 10^9​\)</span></p>
<p>如果 <span class="math inline">\(n, m\)</span> 一个为 <span class="math inline">\(P\)</span> 的倍数，另一个不是，那么显然这些方案都不合法。</p>
<p>分两种情况：</p>
<p>如果 <span class="math inline">\(n, m\)</span> 都是 <span class="math inline">\(P\)</span> 的倍数，那么这一部分的贡献是平凡的，就是 <span class="math inline">\((P-1)^2\)</span>。</p>
<p>如果 <span class="math inline">\(n, m\)</span> 都不是 <span class="math inline">\(P\)</span> 的倍数，可以取其离散对数：</p>
<p><span class="math display">\[
\begin{aligned}
n =g^a\pmod{P} \\
m =g^b\pmod{P} \\
n =c\pmod{P-1} \\
m =d\pmod{P-1}
\end{aligned}
\]</span></p>
<p>定义 <span class="math inline">\(n=(a, c),m=(b, d)\)</span>。任何一个数字 <span class="math inline">\(n,m\)</span> 都可以用形如 <span class="math inline">\((x, y)\)</span> 的数对表示。</p>
<p>同时<span class="math inline">\(\forall x,y \in [0, P-2]\ \ (x, y)\)</span> 的数对都唯一的对应一个在 <span class="math inline">\([1, P(P-1)]\)</span> 的数字。</p>
<p>原式化简： <span class="math display">\[
\begin{split}
\ &amp;n^m &amp;\equiv m^n &amp;\pmod{P} \\
\Rightarrow\ &amp;g^{am} &amp;\equiv g^{bn} &amp;\pmod{P}\\
\Rightarrow\ &amp;{am} &amp;\equiv {bn} &amp;\pmod{\varphi(P)}\\
\Rightarrow\ &amp;{ad} &amp;\equiv {bc} &amp;\pmod{P-1}\\
\end{split}
\]</span></p>
<p>问题转化为：</p>
<p>若 <span class="math inline">\(a, b, c, d\)</span> 可以在 <span class="math inline">\([0, P-1)\)</span> 内任取 ，方程 <span class="math inline">\(ad\equiv bc \pmod{P-1}\)</span> 的解 <span class="math inline">\((a, b, c, d)\)</span> 的数量。</p>
<p>根据乘法群的理论，把 <span class="math inline">\((\mathbb{Z}_{P-1}^*, \times)\)</span> 拆分成多个 <span class="math inline">\(p^k\)</span> 的群的直积。“坐标” 每一维行为独立。</p>
<p>分别求出每一个 <span class="math inline">\(ad\equiv bc \pmod{p^k}\)</span> 的解数量相乘即可。</p>
<p>考虑如何求出形如 <span class="math inline">\(ab\equiv bc \pmod{p^k}\)</span> 的方程解数量。</p>
<p>仍然可以分两种情况：</p>
<ul>
<li>方程两边都与 <span class="math inline">\(p​\)</span> 互质，这样答案也是平凡的可以考虑其中三个数字任取，然后最后一个数字算逆元即可，答案就是 <span class="math inline">\(\varphi(p^k)^3​\)</span>。</li>
<li>方程两边与 <span class="math inline">\(p\)</span> 不互质，可以考虑方程一边的取值个数，考虑枚举 <span class="math inline">\(a, b\)</span> 中 <span class="math inline">\(p\)</span> 的次数，同时除去这个值，转化为互质的情况。需要注意如果其次数和大于 <span class="math inline">\(p^k\)</span> 两边 <span class="math inline">\(p\)</span> 的幂次没必要相等。</li>
</ul>
<h3 id="子">子</h3>
<p>求 <span class="math inline">\(x^k \bmod m\)</span> (<span class="math inline">\(x\)</span> 为非负整数)的不同值个数，答案对 <span class="math inline">\(10^9 + 7\)</span> 取模。</p>
<p><span class="math inline">\(m=\prod_{i=1}^{m_s}\limits{p_i^{a_i}}\)</span></p>
<p><span class="math inline">\(k=\prod_{i=1}^{k_s}\limits{q_i^{b_i}}\)</span></p>
<p><span class="math inline">\(m_s, k_s\le 2\times 10^5, p_i,q_i \le10^7, 1\le a_i,b_i \le 10^9\)</span></p>
<p>下辈子再学。</p>
<h3 id="小a与两位神仙"><a href="https://www.luogu.com.cn/problem/P5605">小A与两位神仙</a></h3>
<p>给定一个奇质数次幂 <span class="math inline">\(m\)</span>。</p>
<p><span class="math inline">\(n\)</span> 组询问，每组给定 <span class="math inline">\((x, y)\)</span> 满足 <span class="math inline">\(x\perp m, y\perp m\)</span></p>
<p>判定是否存在 <span class="math inline">\(x^a\equiv y\pmod{m}\)</span></p>
<p><span class="math inline">\(n \le 2\times 10^4,m\le 10^{18}\)</span></p>
<p>显然求离散对数非常舒服，直接算倍数即可。只可惜 <span class="math inline">\(m\)</span> 有亿点点大。</p>
<p>但是可以通过离散对数考虑，设 <span class="math inline">\(u, v\)</span> 分别为 <span class="math inline">\(x, y\)</span> 的离散对数。</p>
<p>显然我们希望： <span class="math display">\[
t \in \mathbb{Z}\ \ \  \text{s.t.}\ \  ut=v \pmod{\varphi(m)}
\]</span></p>
<p>即： <span class="math display">\[
\gcd(u, \varphi(m)) | v
\]</span> 其等价于： <span class="math display">\[
\gcd(u, \varphi(m)) | \gcd(v, \varphi(m))
\]</span> 由上面乘法群的推论： <span class="math display">\[
|S_x|=\frac{\varphi(m)}{\gcd(\varphi(m), f(x))}
\]</span></p>
<p>于是可以转化为： <span class="math display">\[
\frac{\varphi(m)}{|S_x|} \mid \frac{\varphi(m)}{|S_y|}
\]</span> 即： <span class="math display">\[
|S_y| \ \ \ \ \ \ |  \ \ \ \ \ \ |S_x|
\]</span> 所以只需要对原数 <span class="math inline">\(x, y\)</span> 分别求阶，然后判断 <span class="math inline">\(\operatorname{ord}_m(y) | \operatorname{ord}_m(x)\)</span> 即可。</p>
]]></content>
      <categories>
        <category>学习总结</category>
      </categories>
      <tags>
        <tag>数论</tag>
        <tag>群论</tag>
        <tag>剩余系</tag>
      </tags>
  </entry>
  <entry>
    <title>「学习总结」构造题选</title>
    <url>//%E3%80%8C%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93%E3%80%8D%E6%9E%84%E9%80%A0%E9%A2%98%E9%80%89/</url>
    <content><![CDATA[<p>构造题都是好题</p>
<a id="more"></a>
<h2 id="构造题选">构造题选</h2>
<h3 id="热身一">热身一</h3>
<p>构造三个长度为 <span class="math inline">\(n\)</span> ,的排列使得 <span class="math inline">\(a_i + b_i \equiv c_i \pmod n\)</span> 无解输出 -1</p>
<p>对等式两边分别求和。当 <span class="math inline">\(n\)</span> 为 偶数时，等式左边的值为 <span class="math inline">\(n(n-1) \equiv 0 \pmod n\)</span> ，等式右边的值为 <span class="math inline">\(\frac{n(n-1)}{2} \equiv \frac{n}{2} \pmod n\)</span> ，显然无解。<span class="math inline">\(n\)</span> 为奇数时，直接取 <span class="math inline">\(a=b={0, 1, 2,\cdots n-1}\)</span></p>
<h3 id="热身二">热身二</h3>
<p>一个 <span class="math inline">\(2n\)</span> 个点的完全图，把这些边分成 <span class="math inline">\(2n-1\)</span> 组，每组 <span class="math inline">\(n\)</span> 条边，且每组都是一个匹配。 （同一组内任意两条边没有公共点）。 <span class="math inline">\(n \le 1000\)</span></p>
<p>对于一条边 <span class="math inline">\((u, v)\)</span> ，放入 第 <span class="math inline">\((u, v)\pmod {2n-1}\)</span> 组即可。</p>
<h3 id="热身三">热身三</h3>
<p>一个 <span class="math inline">\(2^n - 1\)</span> 个点的完全图，你需要找出尽量多的不交三元环。<span class="math inline">\(n\le 10\)</span></p>
<p>分析答案上界 <span class="math inline">\(\frac{(2^n-1)(2^n-2)}{6}\)</span>.发现是整数，应该能取到。</p>
<p>三元环可以用 <span class="math inline">\((u, v,w)\)</span> 表示，枚举 <span class="math inline">\(u, v\)</span> ，取出所有 <span class="math inline">\(u \oplus v\oplus w=0\)</span> 的三元环即可。考虑这样算出的答案需要除以 <span class="math inline">\(3!\)</span>。和上界相同，证明这种取法最优。</p>
<h3 id="栗题一">栗题一</h3>
<p>给出一张大小为 <span class="math inline">\(n\le 1000\)</span> 的完全图，给出一种方案，使得选出最多边互不相交的生成树.</p>
<p>分析答案上界为 <span class="math inline">\(\frac{n(n-1)}{2(n-1)} = \lfloor\frac{n}{2}\rfloor\)</span>。</p>
<p>归纳构造：</p>
<ul>
<li>假设 <span class="math inline">\(n=2k\)</span>个点已经构造好了，考虑加入一个点 <span class="math inline">\(n=2k+1\)</span>。这样就随便找 <span class="math inline">\(k\)</span> 个点，然后分别在每个点中选出不同的 <span class="math inline">\(k\)</span> 个树 和新点连边即可。</li>
<li>假设 <span class="math inline">\(n=2k\)</span>个点已经构造好了，考虑加入两个点 <span class="math inline">\(n=2k+2\)</span>，记作 <span class="math inline">\(a, b\)</span>。考虑将 <span class="math inline">\(n\)</span> 个点分为 <span class="math inline">\(A, B\)</span> 两组，<span class="math inline">\(a\)</span> 和 <span class="math inline">\(A\)</span> 中的点，<span class="math inline">\(b\)</span> 和 <span class="math inline">\(B\)</span> 中的点分别连边，然后考虑上界多出了一颗树，这时就可以：<span class="math inline">\(a\)</span> 连 <span class="math inline">\(b\)</span> ，然后 <span class="math inline">\(a\)</span> 连 <span class="math inline">\(B\)</span> ，<span class="math inline">\(b\)</span> 连 <span class="math inline">\(A\)</span>。就多构造了一棵树。</li>
</ul>
<h3 id="栗题二">栗题二</h3>
<p>平面上有 <span class="math inline">\(n \le 100\)</span> 个蓝色的点，需要加上 <span class="math inline">\(k\)</span> 个红色的点，使得任意三个蓝点组成的三角形内部都必须至少有一个红点，红点必须在内部，不能在边上。最小化 <span class="math inline">\(k\)</span> 的大小。</p>
<p>分析出答案下界为 <span class="math inline">\((2n-2-\text{凸包上的点数})\)</span>.</p>
<p>考虑到，一堆点，依次求出凸包，对于相邻两层凸包之间进行三角剖分，三角形个数为相邻两凸包点数和。最内层的凸包能划分出 <span class="math inline">\(n-2\)</span> 个三角形，设 <span class="math inline">\(l_i\)</span> 为从外到内第 <span class="math inline">\(i\)</span> 层凸包上的点数。考虑到答案为 <span class="math inline">\((l_1+l_2) + (l_2+l_3)+(l_3+l_4) +\cdots+(l_{k-1}+l_k)+(l_k - 2)=2n-2-l_1\)</span>。因为这样划分出来的三角形两两不交，所以这一定是答案的一个下界。</p>
<p>考虑如何构造能到达答案的下界。</p>
<p>随机一个向量<span class="math inline">\((x_0, y_0)\)</span>，长度为无限小，在每一个点 <span class="math inline">\((x_i, y_i) \pm (x_0, y_0)\)</span> 处放置两个红点，这样的答案是 <span class="math inline">\(2n\)</span> 的，因为 三角形内角和为 <span class="math inline">\(180^o\)</span> ，一个点和与其对应的两个红点构成的角，角度为 <span class="math inline">\(180^o\)</span> ，在随机意义下，每个三角形内部必然有且仅有一个点。对于凸包外的点可以删除，易知，可删的点有 <span class="math inline">\(\text{凸包上的点数}-2\)</span> 个。这样构造可以达到下界。</p>
<h3 id="栗题三">栗题三</h3>
<p>给出一张 <span class="math inline">\(n\times n\)</span> （<span class="math inline">\(n\le 40\)</span>）的方格表，每个格子里面有一个字母。每次可以把某一行所有字母右循环平移若干格，某一列的所有字母下循环平移若干格。若某行有连续的三个字母 <span class="math inline">\(k, e, y\)</span> 则形成一个键，在 <span class="math inline">\(10000\)</span> 次操作中最大化键的数量。</p>
<ul>
<li>当 <span class="math inline">\(3 \not | \ n\)</span> 时，方法显然，每一行一定要形成 <span class="math inline">\(keykeykey\cdots\)</span> 的形式，考虑像魔方一样的依次把每一列填成该填的字母，注意如果这一个格子无法填成想要的字母（后面没有这样的字母了），优先把后面与 <span class="math inline">\(k, e, y\)</span> 不同的<del>垃圾</del>字母填入。</li>
<li>当 <span class="math inline">\(3\ |\ n\)</span> 时，前面的操作一样做，只需要特殊考虑最后一列怎么做，如果只剩下最后一列没有排好，相当于考虑如何交换最后一列的任意两个格子上的字母。考虑将倒数第二列的最后一行当作转移点，对最后一列执行交换操作，就跟某种排序算法一样即可。</li>
</ul>
<h3 id="栗题四">栗题四</h3>
<p>给定一个 <span class="math inline">\(1\)</span> ~ <span class="math inline">\(n^2+n\)</span> 的排列，选出一个长度为 <span class="math inline">\(2n\)</span> 的子序列，使得子序列中 <span class="math inline">\(\forall k\in n\)</span> 有第 <span class="math inline">\(2k\)</span> 小的和 <span class="math inline">\(2k-1\)</span> 小的数字相邻。</p>
<p>把排列分成 <span class="math inline">\(n\)</span> 段，每段 <span class="math inline">\(n+1\)</span> 个数字。依次求出每段里面最小和次小值。找到次小值最小的一段，把这一段的最小值和次小值放入答案序列，然后删除这一段。再把其他段中比这个次小值小的数字删除，重复上面的操作。可以证明，最后的删除操作，会在每一段中至多删去 <span class="math inline">\(1\)</span> 个数字（由于选定的段是次小值最小的一段），所以保证答案存在。</p>
<h3 id="栗题五">栗题五</h3>
<p>给出一个 <span class="math inline">\(2n\times m\)</span> 的棋盘，有 <span class="math inline">\(n\times m\)</span> 个红格子，有 <span class="math inline">\(n\times m\)</span> 个蓝格子，保证右下角为蓝色，左上角为红色，任意两个同色的格子中心都有一条边。要求给每条边定向，需要保证最后所有边的矢量和为 <span class="math inline">\(0\)</span>.</p>
<ul>
<li><span class="math inline">\(n\times m\)</span> 为奇数，对蓝色和红色的连通块，分别跑欧拉回路。</li>
<li><span class="math inline">\(n\times m\)</span> 为偶数，去掉左上和右下的格点，剩下的点跑欧拉回路，然后考虑所有端点为左上、右下格点的边的方向。依次考虑每一对关于棋盘中心对称的点对。
<ul>
<li>若两个点对颜色不同，分别和左上、右下的格点连边即可抵消</li>
<li>若两个点对颜色相同，则同时向自己颜色的格点连边。这样连边，两个向量和为指向这个颜色的顶点的对角线。易知这样的点对数量相同，所以最后也可以相互抵消。</li>
</ul></li>
</ul>
<h3 id="栗题六">栗题六</h3>
<p>给定一个环，环上的每个点是三种颜色 (RGB) 之一，若一个点左右两边的点颜色不一样，就可以将这个点改变成任意颜色。给出两个环，问能否在 <span class="math inline">\(10n\)</span> 次操作内把一个环变成另一个，给出方案 。 <span class="math inline">\(5 \le n \le 10^5\)</span>。</p>
<p>一个经典套路就是，考虑到操作可逆，可以考虑如何把两个环同时操作，变成同一个。</p>
<p>先考虑把两个环变成 “每个位置都可以操作的形式”，从某个可操作的位置开始操作，让它变成与左右两边距离为 <span class="math inline">\(2\)</span> 的点颜色不同的颜色。然后再操作左或右边的点，依次进行这样的操作，就可以把这个环变成“每个位置都可以操作的形式”。</p>
<p>然后依次考虑把其中一个环的每个位置变成另外一个环的对应位置的颜色。同时需要保证任意一个位置的颜色可变，即：保证任意距离为 2 的位置颜色不同。为了方便考虑，可以把一个环根据位置下标的奇偶拆成两个环，问题变成了修改一个位置的颜色后，和两边位置的颜色都不同，如果改后不能保证，可以先修改两边位置的颜色。由于目标环也保证了任意位置颜色可逆，所以对于当前环的这种策略的操作，一定存在合法地操作。</p>
<h3 id="栗题七">栗题七</h3>
<p><img src="D:\ShuYuMo\Passage%20Text\Passage\images\gouzao_0.png" /></p>
<p>nb 题目不做评价……</p>
<p>想办法每次把最大值放到右下角，每次从没排好序的最后一行开始，依次让每行的最后一列成为一行中的最大值，然后对最后一列当成行，把最大值移动到第一行的最后一列，然后转一圈，移动到没排好序的右下角。注意没有保证任意元素不同，判断比较麻烦。</p>
<h3 id="栗题八">栗题八</h3>
<p>存在 <span class="math inline">\(n\)</span> 个数字。给出 <span class="math inline">\(n\)</span>，和 <span class="math inline">\(m\)</span> 个限制，限制形如 <span class="math inline">\(a_i, a_j\)</span> 两个数字的最大值或最小值为 <span class="math inline">\(w\)</span>。构造一种合法的方案。 <span class="math inline">\(n \le 10^5\)</span>。</p>
<p>根据每个限制，可以给每个数字确定一个上界和下界。一定存在一种赋值方案，使得每个变量要么取上界，要么取下界。因为如果一个数字取下界和上界构成的开区间中的值，这个数字没有贡献，所以取要么取上界要么取下界的方案一定合法。</p>
<p>直接 2-SAT，判断每个数值取上界还是下界。</p>
<h3 id="栗题九">栗题九</h3>
<p>给出一张 DAG，保证每个点入度不超过 <span class="math inline">\(2\)</span>，保证出度为 <span class="math inline">\(0\)</span> 的点有且仅有一个。每个点都有一些权值，这些权值均为 (0 / 1)，初始时，每个入度为 <span class="math inline">\(0\)</span> 的节点有一个权值，其他点的权值为其他两个子节点权值的与非（先取 and 再取 not）， 钦定一些入度为 <span class="math inline">\(0\)</span> 的节点权值，使其满足如下条件。（设：叶子节点为入度为 0 的点，根节点为出度为 0 的点 233） - 没有钦定的叶子节点全取 <span class="math inline">\(1\)</span> 时，和叶子节点全取 <span class="math inline">\(1\)</span> 时，根节点取值相同。 - 没有钦定的叶子节点全取 <span class="math inline">\(0\)</span> 时，和叶子节点全取 <span class="math inline">\(0\)</span> 时，根节点取值相同。 构造一种钦定方案，使得钦定的点数量尽可能多。</p>
<p>首先确定一下：叶子节点全部取 <span class="math inline">\(0\)</span> 时，根节点的取值 <span class="math inline">\(A\)</span>。叶子节点全取 <span class="math inline">\(1\)</span> 时，根点的取值 <span class="math inline">\(B\)</span>。 - 如果 <span class="math inline">\(A = B\)</span>，那么最优答案一定是钦定所有叶子节点为同一值。 - 如果 <span class="math inline">\(A\not = B\)</span>，设 <span class="math inline">\(f(i)\)</span> 表示，当编号小于等于 <span class="math inline">\(i\)</span> 的叶子赋值为 <span class="math inline">\(1\)</span> 其余的赋值为 <span class="math inline">\(0\)</span> 时根节点的取值。试图确定一个 <span class="math inline">\(i\)</span> 使得 <span class="math inline">\(f(i) = A\)</span> 且 $ f(i + 1)=B$ 这时最优的方案就是钦定 <span class="math inline">\([1, i]\)</span> 和 <span class="math inline">\([i + 2, n]\)</span> 这些点，这样 钦定的点有 <span class="math inline">\(n - 1\)</span> 个，已经取到了当前情况下的最优解。 - 讨论一下 <span class="math inline">\(i\)</span> 的存在性，因为 <span class="math inline">\(f(0) \not = f(n)\)</span> 所以一定存在一个 <span class="math inline">\(i\)</span> 使得函数值发生改变。 - 考虑一下如何求这个 <span class="math inline">\(i\)</span> 值，可以<strong>二分</strong>。虽然函数不满足单调性，但是我们也不关心某个极值，只是希望快速求一个拐点，根据二分值处的函数取值，一样能够确定拐点一定在区间的哪边。(界值定理)</p>
<h3 id="栗题十">栗题十</h3>
<p>一个 <span class="math inline">\(n\)</span> 个点的简单无向图（无重边，无自环但不一定联通），你可以询问若干次，每次询问一棵 <span class="math inline">\(n\)</span> 个点的树，交互库会返回这棵树里面有多少边和无向图中的点有<strong>多少</strong>条边重合。</p>
<p>首先确定节点 <span class="math inline">\(1\)</span> 和哪些节点有边相连，只需要构造一个除掉节点 <span class="math inline">\(1\)</span> 的链，然后枚举 <span class="math inline">\(i\)</span>，让节点 <span class="math inline">\(1\)</span> 和 节点 <span class="math inline">\(i\)</span> 连边， 查询答案，考虑这些答案的最大值和最小值，取到最大值的边存在，取到最小值的边不存在 （若最大值最小值相同，则边要么都存在，要么都不存在，问一个菊花即可确定）。</p>
<p>考虑确定剩下的点 <span class="math inline">\(i\)</span> 和哪些点有连边，考虑像线段树一样查询 和下标为某一区间 <span class="math inline">\([l, r]\)</span> 的点是否有边相连，直接向这些点 <span class="math inline">\([l, r]\)</span> 连边，其余的点向 <span class="math inline">\(1\)</span> 连边，由于 <span class="math inline">\(1\)</span> 和哪些点有边相连是已知的，所以可以直接算出点 <span class="math inline">\(i\)</span> 向 <span class="math inline">\([l, r]\)</span> 中的点有无连边，依次递归即可。</p>
<h3 id="栗题十一">栗题十一</h3>
<p><a href="http://www.zhengruioi.com/contest/717/problem/1599">「正睿联赛集训」Round 2 矩阵</a></p>
<h3 id="栗题十一-1">栗题十一</h3>
<p>需要值域分块学后待补。</p>
<h3 id="栗题十二">栗题十二</h3>
<p>「CF1364E」给定一个 <span class="math inline">\([0, n-1]\)</span> 的排列 p，每次询问 <span class="math inline">\((i, j)\)</span>返回 <span class="math inline">\(p_i | p_j\)</span>，最多 <span class="math inline">\(4269\)</span> 次询问，推出这个排列。 <span class="math inline">\(n\le 2048\)</span>。</p>
<p>考虑到确定哪一个位置为 <span class="math inline">\(0\)</span> 即可确定所有位置的数字。</p>
<h4 id="做法一">做法一</h4>
<p>随机选择一个数字，让它或上其他所有数字，显然它和 <span class="math inline">\(0\)</span> 取或能够取到最小值。再随机一个数字让这个数字和这些上一次取到最小值的数字取或，继续找到最小值，重复以上操作，直到最小值唯一。 每次迭代，二进制中 <span class="math inline">\(1\)</span> 的个数期望减半，花费大概是 <span class="math inline">\(\mathcal{O}(n+\sqrt n + \cdots)\)</span> 常熟较大</p>
<h4 id="做法二">做法二</h4>
<p>从前往后扫一遍，同时维护两个位置 <span class="math inline">\(a, b\)</span> 表示前缀中可能为 <span class="math inline">\(0\)</span> 的位置为 <span class="math inline">\(a,b\)</span>， 考虑加入一个数字 <span class="math inline">\(c\)</span> 如何维护:</p>
<ul>
<li><span class="math inline">\(a | c &gt; a | b\)</span> 则 <span class="math inline">\(c\)</span> 不可能为 <span class="math inline">\(0\)</span>.</li>
<li><span class="math inline">\(a | c &lt; a | b\)</span> 则 <span class="math inline">\(b\)</span> 不可能为 <span class="math inline">\(0\)</span>.</li>
<li><span class="math inline">\(a | c = a | b\)</span> 则 <span class="math inline">\(a\)</span> 不可能为 <span class="math inline">\(0\)</span>.</li>
</ul>
<p>注意到其实前两种操作只需要询问一次，而后一种操作虽然需要询问多次，<span class="math inline">\(a|c = a|b\)</span> 的概率非常小。 可以考虑 <span class="math inline">\(random\_shuffle\)</span> 之后再做防止被卡。</p>
]]></content>
      <categories>
        <category>学习总结</category>
      </categories>
      <tags>
        <tag>构造题</tag>
      </tags>
  </entry>
  <entry>
    <title>「学习总结」正睿 计数选讲</title>
    <url>//%E3%80%8C%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93%E3%80%8D%E6%AD%A3%E7%9D%BF-%E8%AE%A1%E6%95%B0%E9%80%89%E8%AE%B2/</url>
    <content><![CDATA[<p>wzy哥哥的一些有趣计数题~</p>
<a id="more"></a>
<h2 id="例题壹">例题壹</h2>
<p>给定 <span class="math inline">\(n, m\)</span> ，构造 <span class="math inline">\(n\)</span> 堆石子，每堆石子的数量 <span class="math inline">\(\in[1, 2^m-1]\)</span>，每堆石子数目互不相同。求使得 Nim 先手必胜的构造方案数。</p>
<p><span class="math inline">\(n\le 10^7, m\le 10^9\)</span> 模数：<span class="math inline">\(10^9 + 7\)</span></p>
<p>考虑直接后手必胜的情况，即长度为 <span class="math inline">\(n\)</span> 的序列，异或和为 <span class="math inline">\(0\)</span>。</p>
<p>设长度为 <span class="math inline">\(n\)</span> 的方案数为 <span class="math inline">\(f(n)\)</span>。能够得到如下递推式： <span class="math display">\[
f(n) = (2^m-1)(2^m-2)(2^m-3) \cdots(2^m - n+1)\\
-f(n - 1)\\
-(2^m-1)(i-1)f(n-2)
\]</span> 考虑到前 <span class="math inline">\((n-1)\)</span> 位置个随意填上互不相同的值域为 <span class="math inline">\([1, 2^m-1]\)</span> 的数字。然后减去前面正好填出异或和为 <span class="math inline">\(0\)</span> 的方案（因为最后一个位置还要填数字）（即：<span class="math inline">\(f(n-1)\)</span>）。理论上，最后一个数字应该等于前面 <span class="math inline">\((n - 1)\)</span> 数字的异或和，但是可能不满足互不相同的条件，先枚举不合法的方案最后一个数字是什么，然后枚举和前面哪一个冲突，再乘上 <span class="math inline">\(f(n-2)\)</span>。</p>
<h2 id="例题贰">例题贰</h2>
<p>给出 <span class="math inline">\(n\)</span> 个正整数 <span class="math inline">\(a_i\)</span>，选出 <span class="math inline">\(n\)</span> 个正整数 <span class="math inline">\(b_i\)</span> ，<span class="math inline">\(n\)</span> 个正整数 <span class="math inline">\(d_i\)</span>，满足</p>
<p><span class="math inline">\(\forall i \in [1, n], d_i|b_i|a_i\)</span>，求有多少种选法满足 <span class="math inline">\(\prod_{i}^n d_i^2 \ge \prod_{i=1}^{n}b_i\)</span></p>
<p><span class="math inline">\(n\le 100, a_i \le 10^9​\)</span></p>
<p>对于任意一种方案 <span class="math inline">\(\prod_{i=1}^{n}d_i^2 &gt; \prod_{i=1}^{n}b_i​\)</span></p>
<p>试想把所有 <span class="math inline">\(d_i\)</span> 取成 <span class="math inline">\(\frac{b_i}{d_i}\)</span>，即： <span class="math inline">\(\prod_{i=1}^{n} \frac{b_i^2}{d_i^2} &gt; \prod_{i=1}^{n}b_i\)</span></p>
<p>即： <span class="math inline">\(\prod_{i=1}^{n}d_i^2 &lt; \prod_{i=1}^{n}b_i​\)</span></p>
<p>所以其实 <span class="math inline">\(\prod_{i=1}^{n}d_i^2 &lt; \prod_{i=1}^{n}b_i\)</span> 和 <span class="math inline">\(\prod_{i=1}^{n}d_i^2 &gt; \prod_{i=1}^{n}b_i\)</span> 的方案是一一对应的。</p>
<p>只需要求出 <span class="math inline">\(\prod_{i=1}^{n}d_i^2=b_i\)</span> 的方案数即可。这个可以对每一个质因子单独 dp。</p>
<h2 id="例题叁">例题叁</h2>
<p><a href="https://codeforces.com/contest/383/problem/D">CF383D</a></p>
<p><span class="math inline">\(n\)</span> 个位置排成一排,有 <span class="math inline">\(m\)</span> 个人依次进场选位置,每个人一开始选一个方向,从左到右/从右到左,并选择一个位置,然后按照她选择的方向进入场地,走到这个位置,如果有人,就继续按当前方向往后寻找,知道找到一个空位坐下,如果没有空位,他就会生气.</p>
<p>为每个人确定一个方向和选择的位置。求没有人生气的方案数。</p>
<p>考虑把序列首尾之间连接一个点 <span class="math inline">\(n+1\)</span> 转化成一个环，相当于每个人选择一个位置，然后选择一个方向转圈，方案不合法，当且仅当有一个人占据了 <span class="math inline">\(n+1\)</span> 这个位置。</p>
<p>因为是一个环，所以任意一个位置都是等价的，所以任意一个位置有人的概率为 <span class="math inline">\((1 -\frac{m}{n+1})​\)</span></p>
<p>答案就是 <span class="math inline">\((1 - \frac{m}{n + 1})2^m(n + 1) ^ m\)</span></p>
<h2 id="例题肆">例题肆</h2>
<p><a href="/oi-blog/「杂题记录」「CTSC2017」吉夫特">「杂题记录」「CTSC2017」吉夫特</a></p>
<h2 id="例题伍">例题伍</h2>
<p><a href="/oi-blog/「杂题记录」括号序列（格路计数）">「杂题记录」括号序列（格路计数）</a></p>
<h2 id="例题陆">例题陆</h2>
<p>一棵树，每条边的两个端点的大小关系给出，形如 <span class="math inline">\(a_u &gt; a_v\)</span> 或者 <span class="math inline">\(a_u &lt; a_v\)</span>。求有多少种满足条件的排列 <span class="math inline">\(a\)</span> 。 <span class="math inline">\(n \le 5000\)</span></p>
<h2 id="例题柒">例题柒</h2>
<p>给定一个字符串 <span class="math inline">\(S\)</span>，仅包含 <code>&lt;</code> 和 <code>&gt;</code> 两种字符。</p>
<p>你需要计算「使得 <span class="math inline">\(p_i &lt; p_{i+1}\)</span> <strong>当且仅当</strong> <span class="math inline">\(s_i\)</span>为 <code>&lt;</code> 的排列 <span class="math inline">\(p_1, p_2, \cdots p_{n+1}\)</span> 」的数量。</p>
<p>可以发现，答案可能很大，因此你只要输出它对 <span class="math inline">\(998244353\)</span> 取模的结果。</p>
<p>巧妙容斥。</p>
<p>先不考虑所有 <code>&gt;</code> 的限制，只考虑 <code>&lt;</code> 的限制，<code>&gt;</code> 处的偏序关系任意，将一段 <code>&lt;</code> 视为连续的一段，设每一连续的一段长度为 <span class="math inline">\(a_i\)</span> ，这样的方案数就是 <span class="math inline">\(\frac{n!}{\prod_{i}a_i!}\)</span>。</p>
<p>然后显然答案需要减去任意位置为 <code>&lt;</code> 的情况，对这个 <code>&lt;</code> 满足数量容斥即可。</p>
<p>考虑设 <span class="math inline">\(f(n)\)</span> 表示只考虑前 <span class="math inline">\(n\)</span> 个数字方案数。</p>
<p>考虑 <span class="math inline">\(f(n)\)</span> 的答案和 <span class="math inline">\(f(n-1)\)</span> 的答案的差别，枚举最后一段有多长即可。 <span class="math display">\[
f(n) = \sum_{i=1}^{i-1}\frac{[S_j = &#39;&gt;&#39;]}{(i-j)!}f(i)(-1)^{cnt_{i-1}-cnt_{j}}
\]</span> 这东西可以分治 <span class="math inline">\(NTT​\)</span> 优化。</p>
<h2 id="例题玐">例题玐</h2>
<p><span class="math inline">\(n\)</span> 阶 <strong>循环矩阵</strong>是一种形如： <span class="math display">\[
A=\begin{bmatrix}
a_0     &amp;   a_{n-1} &amp;\cdots     &amp;   a_2     &amp;   a_1\\
a_1     &amp;   a_{0}   &amp;a_{n-1}    &amp;           &amp;   a_2\\
\vdots  &amp;   a_1     &amp;a_0        &amp;   \ddots  &amp;   \vdots\\
a_{n-2} &amp;           &amp;\ddots     &amp;   \ddots  &amp;   a_{n-1}\\
a_{n-1} &amp;   a_{n-2} &amp;\cdots     &amp;   a_1     &amp;   a_0
\end{bmatrix}
\]</span> 的矩阵。</p>
<p>设 <span class="math inline">\(f(x)=\sum_{i=0}^{n-1}a_ix^i\)</span> 没必要拘泥于<span class="math inline">\(a_i\)</span> 的下标，取第一行依次排开即可，是等价的。</p>
<p>则：<span class="math inline">\(\det(A)=\prod_{i=0}^{n-1}\limits{f(\omega_i)}\)</span></p>
<p>即 对于循环矩阵，有快速的求值方式。</p>
<h2 id="lgv引理">LGV引理</h2>
<p>在一张 <code>DAG</code> 上，给定 <span class="math inline">\(n\)</span> 个起点 <span class="math inline">\(a_1,\cdots,a_n\)</span> ，<span class="math inline">\(n\)</span> 个终点 <span class="math inline">\(b_1,\cdots,b_n\)</span>，求选出 <span class="math inline">\(n\)</span> 条路径 <span class="math inline">\((a_i, b_i)​\)</span> 互不相交（不经过同一个点）的方案数。</p>
<p>设 <span class="math inline">\(f(a, b)\)</span> 表示从 <code>DAG</code> 上从 <span class="math inline">\(a\)</span> 走到 <span class="math inline">\(b\)</span> 的方案数。</p>
<p>构造矩阵 <span class="math inline">\(C\)</span>, 满足 <span class="math inline">\(c_{a, b}=f(a, b)\)</span>。</p>
<p><strong>LGV引理</strong>指出，其方案数为： <span class="math display">\[
\det(C)
\]</span> 考虑任意一个有交方案，都能够对应一种其他方案，对应奇偶排列，这些方案会被抵消。</p>
<h3 id="栗题">栗题</h3>
<p><span class="math inline">\(\mathbb{Y}\)</span> 轴正半轴上有 <span class="math inline">\(n\)</span> 个点 <span class="math inline">\((0, a_1),(0, a_2), \cdots,(0, a_n)\)</span>，他们每次可以向右或向下走一格，求最后分别走到 <span class="math inline">\((1, 0), (2, 0), \cdots, (n, 0)\)</span> 的方案数。 <span class="math inline">\(n, a_i \le 10^6\)</span></p>
<p>考虑这里的从 <span class="math inline">\((0, a_i)\)</span> 到 <span class="math inline">\((j, 0)\)</span> 的方案数为 <span class="math inline">\(\dbinom{a_i + j}{j}\)</span></p>
<p>构造行列式为： <span class="math display">\[
\begin{vmatrix}
\dbinom{a_1+1}{1}&amp;\cdots&amp;\dbinom{a_1+n}{n}\\
\vdots           &amp; \ddots&amp; \vdots\\
\dbinom{a_n+1}{1}&amp;\cdots&amp;\dbinom{a_n+n}{n}
\end{vmatrix}
\]</span> 对于每一列 <span class="math inline">\(j\)</span> 提出公因子 <span class="math inline">\(\frac{1}{j!}​\)</span>，得： <span class="math display">\[
\frac{1}{1!\ 2!\cdots n!}\begin{vmatrix}
(a_1+1)^{\underline{1}}&amp;\cdots&amp;(a_1+n)^{\underline{n}}\\
\vdots           &amp; \ddots&amp; \vdots\\
(a_n+1)^{\underline{1}}&amp;\cdots&amp;(a_n+1)^{\underline{n}}
\end{vmatrix}
\]</span> 对每一行 <span class="math inline">\(i\)</span> 提出公因子 <span class="math inline">\((a_i+1)\)</span> 得到： <span class="math display">\[
\frac{(a_1+1)(a_2+1)\cdots(a_n+1)}{1!\ 2!\cdots n!}
\begin{vmatrix}
1&amp;\cdots&amp;(a_1+n)^{\underline{n-1}}\\
\vdots           &amp; \ddots&amp; \vdots\\
1&amp;\cdots&amp;(a_n+1)^{\underline{n-1}}
\end{vmatrix}
\]</span> 类似于归纳法的消元方法，注意到每一列都是一系列形式相同的关于 <span class="math inline">\(a_i\)</span> 的多项式，考虑可以用前面的每一列来消这一列，使得这一列 <span class="math inline">\(i\)</span> 只剩下第 <span class="math inline">\(i\)</span> 次项。</p>
<p>最后能得到一个<strong>范德蒙行列式</strong>，形如： <span class="math display">\[
F=\begin{vmatrix}
1 &amp; a_1 &amp; a_1^2 &amp; \cdots &amp; a_1^{n-1} \\
\vdots &amp; &amp; &amp;\ddots &amp;\vdots\\
1 &amp; a_n &amp; a_n^2 &amp; \cdots &amp; a_n^{n-1} \\
\end{vmatrix}
\]</span> 范德蒙行列式的值有如下结论： <span class="math display">\[
\det(F)=\prod_{i &lt; j}(a_j - a_i)
\]</span> 注意按照归纳法推导过程，不难发现其实应该会推导出一个 <span class="math inline">\(\alpha F\)</span> 的形式，但是这里的 <span class="math inline">\(\alpha\)</span> 的值为 <span class="math inline">\(1​\)</span> ，可以忽略。</p>
<p>可以考虑枚举差值 <span class="math inline">\(k\)</span> ，计算有多少对数字差值为 <span class="math inline">\(k\)</span>。</p>
<p>记 <span class="math inline">\(g_i\)</span> 表示有多少 <span class="math inline">\(a\)</span> 等于 <span class="math inline">\(i\)</span>，构造 <span class="math inline">\(g_i\)</span> 的生成函数 <span class="math inline">\(G(x)\)</span>。</p>
<p>易知：<span class="math inline">\([x^k]\sum_{i=k}\limits{g_ig_{i-k}}\)</span> 就是所求。复杂度为 <span class="math inline">\(\mathcal{O}(a_i \log a_i)\)</span>。</p>
]]></content>
      <categories>
        <category>学习总结</category>
      </categories>
      <tags>
        <tag>数学</tag>
        <tag>计数</tag>
        <tag>组合数</tag>
      </tags>
  </entry>
  <entry>
    <title>「学习总结」群 置换群</title>
    <url>//%E3%80%8C%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93%E3%80%8D%E7%BE%A4-%E7%BD%AE%E6%8D%A2%E7%BE%A4/</url>
    <content><![CDATA[<p>群，一种特殊的代数结构，满足封闭性、结合律、存在幺元和对于每个元素存在逆元的四种性质。</p>
<p>置换群，一种特殊的群，其中的元素描述了一种交换操作。 <a id="more"></a> # 群论简介 ## 定义 称 集合 <span class="math inline">\(S\)</span> 和 <span class="math inline">\(S\)</span> 上运算 <span class="math inline">\(\cdot\)</span>，共同构成得代数结构记作 <span class="math inline">\((S, \cdot)\)</span>，为一个群，当且仅当其满足如下性质：</p>
<ul>
<li><span class="math inline">\(S \not = \varnothing\)</span></li>
<li>封闭性：<span class="math inline">\(\forall a, b\in S, a\cdot b \in S\)</span></li>
<li>结合律：<span class="math inline">\(\forall a, b, c\in S, a \cdot (b \cdot c)= (a \cdot b) \cdot c\)</span></li>
<li>幺元：<span class="math inline">\(\exists e \in S, \forall a \in S, e \cdot a = a \cdot e= a\)</span></li>
<li>逆元：<span class="math inline">\(\forall a \in S, \exists b \in S, a \cdot b = e\)</span></li>
</ul>
<h2 id="几个栗子">几个栗子</h2>
<ul>
<li>实数集与实数间的乘法 <span class="math inline">\((\mathbb{R}, \times)\)</span> 不是群，元素 <span class="math inline">\(0 \in \mathbb{R}\)</span>，但是 <span class="math inline">\(0\)</span> 不存在逆元。</li>
<li><span class="math inline">\((\mathbb{R&#39;}, \times)\)</span> 是一个群，幺元为 <span class="math inline">\(1\)</span>。 其中 <span class="math inline">\(\mathbb{R&#39;} = \\{\ x\ |\ x\in \mathbb{R}\ \land \ x \not = 0\ \\}\)</span></li>
<li><span class="math inline">\((\mathbb{Z}, +)\)</span> 是一个群，幺元是 <span class="math inline">\(0\)</span>。</li>
<li><span class="math inline">\((\mathbb{R}, +)\)</span> 是一个群，幺元是 <span class="math inline">\(0\)</span>。</li>
<li><span class="math inline">\((\mathbb{P}, \times)\)</span> 是一个群，幺元是 <span class="math inline">\(1\)</span> ，其中 <span class="math inline">\(P\)</span> 为某个质数的剩余系。</li>
</ul>
<h2 id="一类特殊的群">一类特殊的群</h2>
<ul>
<li><strong>阿贝尔群</strong>：除了满足群的性质，还需要满足 <span class="math inline">\(a \cdot b = b \cdot a\)</span> 即 <strong>交换律</strong>。</li>
</ul>
<h1 id="置换群">置换群</h1>
<h2 id="不严谨定义">不严谨定义</h2>
<p>把 <span class="math inline">\(1\)</span> ~ <span class="math inline">\(n\)</span> 个对象 进行交换操作的群，置换群中集合的元素描述了一种交换操作。 对应的，置换群的运算就是分别执行两种交换操作。</p>
<div class="note info"><p>一种描述交换操作（置换）的记号。</p>
<p><strong>举个栗子：</strong> 给执行交换操作前的元素依次编号为 <span class="math inline">\(1, 2, 3, 4\)</span>（对编号后，编号为 <span class="math inline">\(i\)</span> 元素简称元素 i） ，交换操作后变为 <span class="math inline">\(3, 1, 2, 4\)</span>。</p>
<p>可以描述成 <span class="math inline">\((1, 2, 3)(4)\)</span>，读作：将元素 <span class="math inline">\(1\)</span> 换到位置 <span class="math inline">\(2\)</span>，将元素 <span class="math inline">\(2\)</span>，换到位置 <span class="math inline">\(3\)</span>，将元素 <span class="math inline">\(3\)</span> 换至位置 <span class="math inline">\(1\)</span>，将元素 <span class="math inline">\(4\)</span> 换至位置 <span class="math inline">\(4\)</span>。</p>
<p><strong>可以考虑成：</strong> 一张包含 <span class="math inline">\(n\)</span> 个点的图，然后使 点<span class="math inline">\(i\)</span> 与 点<span class="math inline">\(a_i\)</span> 有边相连。对于每个连通块来说，图的形态一定是一个环，从环上一个点开始按照任意方向遍历图，得到的遍历顺序就是上面描述中的一个括号内的内容。联通块的个数就是上面描述中的括号数量，其实这个可以被称为轨道数。</p>
<p><strong>交换群的栗子</strong>： 一个对 <span class="math inline">\(3\)</span> 个元素的交换群：<span class="math inline">\(\\{e,(1,2)(3),(1,3)(2),(1,2,3),(1,3,2),(2,3)(1)\\}\)</span></p>
<p><span class="math inline">\((1)(2) \cdots (n)\)</span> 简记为 <span class="math inline">\(e\)</span> 即 对原元素不做交换。</p>
</div>
<h2 id="burnside-引理">burnside 引理</h2>
<details class="note danger"><summary><p>QAQ</p>
</summary>
<p><img src="/oi-blog/post_images/qun_0.png" /> <img src="/oi-blog/post_images/qun_1.png" /></p>

</details>
<h3 id="简化定义">简化定义</h3>
<p>设要对 <span class="math inline">\(n\)</span> 个元素用 <span class="math inline">\(m\)</span> 种颜色染色，对应置换群为 <span class="math inline">\(S\)</span>，在该置换群下任意一种得到的相同方案算同一种方案。求本质不同的染色方案数。</p>
<p>根据 burnside 引理，其答案为。 <span class="math display">\[
\begin{equation}
   ANS = \frac{1}{|S|}\sum_{s \in S}\limits{m^{\eta(s)}} \label{bns}
\end{equation}
\]</span> 其中 <span class="math inline">\(\eta(s)\)</span> 为置换方案 <span class="math inline">\(s\)</span> 的轨道数。 这是关于 burnside 引理的一个<strong>简化版</strong>定义。</p>
<div class="note info"><p><strong>一个栗题</strong>： <span class="math inline">\(n\)</span> 个排成一圈的点用 <span class="math inline">\(m\)</span> 种颜色染色，问方案数（旋转前后的方案为一种方案）.</p>
</div>
<details class="note success"><summary><p>solution</p>
</summary>
<p>显然需要解决两个问题： - 置换群的构造. - 置换群元素轨道数目.</p>
<p>考虑这个置换群的置换集合可以是什么： (假设 <span class="math inline">\(n\)</span> 为 <span class="math inline">\(6\)</span>). <span class="math display">\[
\begin{equation*}
S = \begin{Bmatrix}
(1)(2)(3)(4)(5)(6), \\\\
(1, 2, 3, 4, 5, 6), \\\\
(1, 3, 5) (2, 4, 6) \\\\
(1, 4) (2, 5) (3, 6) \\\\
(1, 5, 3) (2, 6, 4) \\\\
(1, 6, 5, 4, 3, 2) \\\\
\end{Bmatrix}
\end{equation*}
\]</span> 分别对应转动的位置个数为 <span class="math inline">\(0\)</span> ~ <span class="math inline">\(n - 1\)</span>。稍微模拟一下这个过程，显然移动 <span class="math inline">\(k\)</span> 个位置的方案，轨道数为 <span class="math inline">\(\operatorname{gcd}(k, n)\)</span>. 然后就一般化了.</p>

</details>
<h3 id="完整定义">完整定义</h3>
<div class="note danger"><p>设 <span class="math inline">\(A\)</span> 和 <span class="math inline">\(B\)</span> 为有限集合，<span class="math inline">\(X = B^A\)</span> 表示从 <span class="math inline">\(A\)</span> 到 <span class="math inline">\(B\)</span> 的映射。<span class="math inline">\(G\)</span> 是 <span class="math inline">\(A\)</span> 上置换群，<span class="math inline">\(X / G\)</span> 表示 <span class="math inline">\(G\)</span> 作用在 <span class="math inline">\(X\)</span> 上产生的所有等价类集合，若存在两种映射经过 <span class="math inline">\(G\)</span> 的置换作用后是相同的，则将两种映射视为同一种。 burnside 引理指出： <span class="math display">\[
\begin{equation}
|X / G| = \frac{1}{|G|}\sum_{g \in G} \limits{|X^g|} \label{burnside}
\end{equation}
\]</span> 其中 <span class="math inline">\(X^g\)</span> 表示在映射集合 <span class="math inline">\(X\)</span> 中有多少元素可以经过 <span class="math inline">\(g\)</span> 的变化，变成一样的。</p>
</div>
<p>考虑与之前定义 <span class="math inline">\((\ref{bns})\)</span> 的联系： - 一种染色方案可以看成 元素 和 颜色 的映射。 - 对于置换 <span class="math inline">\(s\)</span> ，如果要保证其作用前后映射方案相同，必须要保证其同轨道内的元素被映射到了同一元素，即 染成了相同的颜色。 - 那么考虑置换 <span class="math inline">\(s\)</span> 的每一条轨道 <span class="math inline">\(\eta\)</span>，每一条轨道颜色相同的方案数就是 <span class="math inline">\(m^{\eta(s)}\)</span> - 这与 <span class="math inline">\((\ref{burnside})\)</span> 的定义是相符的。</p>
<div class="note info"><p><strong>一道例题</strong> 众所周知，小葱同学擅长计算，尤其擅长计算组合数，但这个题和组合数没什么关系。</p>
<p>现在有一个迷宫，这个迷宫是由若干个正 <span class="math inline">\(n(=4,6)\)</span> 边形组成的k层迷宫。如果 <span class="math inline">\(k=1\)</span> ，那么该迷宫就由单独一个正 <span class="math inline">\(n\)</span> 边形组成；如果 <span class="math inline">\(k&gt;1\)</span>，则在 <span class="math inline">\(k−1\)</span> 层的基础上，沿着所有最外层的边增加一个正 <span class="math inline">\(n\)</span> 边形，新增加的正 <span class="math inline">\(n\)</span> 边形若有重叠，则保留其中一个即可。具体可以参考下图：</p>
<p><img src="/oi-blog/post_images/qun_2.png" /></p>
<p>现在为了打破迷宫的结界，你需要在迷宫的某些边上开一扇门。你总共需要开 <span class="math inline">\(r\)</span> 扇门，每条边最多打开一扇门。但是如果两种开门的方案通过旋转相同，那么视为同一种方案。以及由于是死亡迷宫，所以死了也是可以的，所以你并不需要保证你开门的方案能够让你走出去。求总共的方案数。</p>
</div>
<details class="note success"><summary><p>solution</p>
</summary>
<p>现在可以简化一下描述一种操作的语言，burnside 引理 不关心置换的具体对象，只关心置换的大小和出现次数。可以用简写 <span class="math inline">\((a)^b\)</span> 表示：有 <span class="math inline">\(b\)</span> 个长度为 <span class="math inline">\(a\)</span> 的轨道。 先特殊考虑一下 <span class="math inline">\(k = 2\)</span> 的情况，一共有 <span class="math inline">\(16\)</span> 条边。可以分为转 <span class="math inline">\(0^o,90^o,180^o, 270^o\)</span>. - 转 <span class="math inline">\(0^o\)</span> 的置换，可以描述为 <span class="math inline">\((1)^{16}\)</span>. - 转 <span class="math inline">\(90^o\)</span> 的置换，可以描述为 <span class="math inline">\((4)^4\)</span>. - 转 <span class="math inline">\(180^o\)</span> 的置换，可以描述为 <span class="math inline">\((2)^8\)</span>. - 转 <span class="math inline">\(270^o\)</span> 的置换，可以描述为 <span class="math inline">\((4)^4\)</span>.</p>
<p>特殊化一下，不难发现就是：（一共有 <span class="math inline">\(4k^2\)</span> 条边）</p>
<ul>
<li>转 <span class="math inline">\(0^o\)</span> 的置换，可以描述为 <span class="math inline">\((1)^{4k^2}\)</span>.</li>
<li>转 <span class="math inline">\(90^o\)</span> 的置换，可以描述为 <span class="math inline">\((4)^{k^2}\)</span>.</li>
<li>转 <span class="math inline">\(180^o\)</span> 的置换，可以描述为 <span class="math inline">\((2)^{2k^2}\)</span>.</li>
<li>转 <span class="math inline">\(270^o\)</span> 的置换，可以描述为 <span class="math inline">\((4)^{k^2}\)</span>.</li>
</ul>
<p>根据 <span class="math inline">\(X^g\)</span> 的定义——表示在映射集合 <span class="math inline">\(X\)</span> 中有多少元素可以经过 <span class="math inline">\(g\)</span> 的变化，变成一样的。我们始终要保证对于一种置换，同一轨道的元素完全相同. 所以对于第一种置换，贡献就是在轨道数中选出 <span class="math inline">\(r\)</span> 个让他们都变成 “有门存在” 的状态，即 <span class="math inline">\(\dbinom{4k^2}{r}\)</span>. 其余的同理，答案就是。 <span class="math display">\[
\begin{equation}
   \frac{1}{4}\sum_{g\in G}\limits{\dbinom{\eta(g)}{\frac{r}{t}}}
\end{equation}
\]</span> 其中 <span class="math inline">\(t\)</span> 为 轨道 <span class="math inline">\(g\)</span> 的循环长度。 当 <span class="math inline">\(\frac{r}{t}\)</span> 不是整数的时候，贡献为 <span class="math inline">\(0\)</span> ，因为 不存在某种染色方法，使得这种置换中同轨道的元素颜色相同.</p>

</details>
<h3 id="适用于立体图形的-burnside-引理">适用于立体图形的 burnside 引理</h3>
<p>包括对正 <span class="math inline">\(n\)</span> 面体和足球的 面，点或棱染色。 #### 立方体面染色 首先讨论置换群： 考虑正方体有 <span class="math inline">\(12\)</span> 条棱，<span class="math inline">\(6\)</span> 个面，<span class="math inline">\(8\)</span> 个点。</p>
<table>
<thead>
<tr class="header">
<th>旋转轴类型</th>
<th>角度</th>
<th>数量</th>
<th>置换</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>不转</td>
<td><span class="math inline">\(0^o\)</span></td>
<td>1</td>
<td><span class="math inline">\((1)^6\)</span></td>
</tr>
<tr class="even">
<td>面面</td>
<td><span class="math inline">\(90^o\)</span></td>
<td>3</td>
<td><span class="math inline">\((1)^2(4)^1\)</span></td>
</tr>
<tr class="odd">
<td>面面</td>
<td><span class="math inline">\(180^o\)</span></td>
<td>3</td>
<td><span class="math inline">\((1)^2(2)^2\)</span></td>
</tr>
<tr class="even">
<td>面面</td>
<td><span class="math inline">\(270^o\)</span></td>
<td>3</td>
<td><span class="math inline">\((1)^2 (4)^1\)</span></td>
</tr>
<tr class="odd">
<td>棱棱</td>
<td><span class="math inline">\(180^o\)</span></td>
<td>6</td>
<td><span class="math inline">\((2)^3\)</span></td>
</tr>
<tr class="even">
<td>点点</td>
<td><span class="math inline">\(120^o\)</span></td>
<td>4</td>
<td><span class="math inline">\((3)^2\)</span></td>
</tr>
<tr class="odd">
<td>点点</td>
<td><span class="math inline">\(240^o\)</span></td>
<td>4</td>
<td><span class="math inline">\((3)^2\)</span></td>
</tr>
</tbody>
</table>
<p>关于角度的确定：观察旋转轴图形周围的形状。数量为总数的一半。</p>
<h4 id="正十二面体染色">正十二面体染色</h4>
<p><span class="math inline">\(20\)</span> 个点，<span class="math inline">\(12\)</span> 个面，<span class="math inline">\(30\)</span> 条棱，面为五边形。 <div class="note warning"><p>循环节：即对于一种置换方案的轨道长度。简单理解为转多少次能够转到原来的位置。</p>
</div> | 旋转轴类型 | 角度 | 循环节 | 数量 | 面染色置换群 | 边染色置换群 | 点染色置换群 | | ---------- | ------- | ------ | ------ | ------------ | --------------- | ------------ | | 不转 | <span class="math inline">\(0^o\)</span> | 1 | 1 | <span class="math inline">\((1)^{12}\)</span> | <span class="math inline">\((1)^{30}\)</span> | <span class="math inline">\((1)^{20}\)</span> | | 面面轴 | <span class="math inline">\(72^o\)</span> | 5 | 6 | <span class="math inline">\((1)^2(5)^2\)</span> | <span class="math inline">\((5)^6\)</span> | <span class="math inline">\((5)^4\)</span> | | 面面轴 | <span class="math inline">\(144^o\)</span> | 5 | 6 | <span class="math inline">\((1)^2(5)^2\)</span> | <span class="math inline">\((5)^6\)</span> | <span class="math inline">\((5)^4\)</span> | | 面面轴 | <span class="math inline">\(216^o\)</span> | 5 | 6 | <span class="math inline">\((1)^2(5)^2\)</span> | <span class="math inline">\((5)^6\)</span> | <span class="math inline">\((5)^4\)</span> | | 点点轴 | <span class="math inline">\(120^o\)</span> | 3 | 10 | <span class="math inline">\((3)^4\)</span> | <span class="math inline">\((3)^{10}\)</span> | <span class="math inline">\((1)^2(3)^6\)</span> | | 点点轴 | <span class="math inline">\(240^o\)</span> | 3 | 10 | <span class="math inline">\((3)^4\)</span> | <span class="math inline">\((3)^{10}\)</span> | <span class="math inline">\((1)^2(3)^6\)</span> | | 棱棱轴 | <span class="math inline">\(180^o\)</span> | 2 | 15 | <span class="math inline">\((2)^6\)</span> | <span class="math inline">\((1)^2(2)^{14}\)</span> | <span class="math inline">\((2)^{10}\)</span> |</p>
<p>以某个对象为旋转轴，其置换群中必然有两个长度为 <span class="math inline">\(1\)</span> 的轨道，作为旋转轴的对象，旋转前后应该是重叠的。 然后剩下的根据轨道循环节直接算出即可。 可以发现这是一个无脑的工作</p>
<h4 id="足球的置换群">足球的置换群</h4>
<details class="note warning"><summary><p>qaq</p>
</summary>
<p>实在不想写了…… 足球的点数不好求，但是可以根据立体图形外角和公式求出： 立体图形外角和为 <span class="math inline">\(720^o\)</span> 。 即 <span class="math inline">\(\text{点数} \times \text{外角度} = 720^o\)</span>.</p>

</details>
<h1 id="例题">例题：</h1>
<p>待填。</p>
<h1 id="题外话">题外话</h1>
<details class="note danger"><summary><p>呵呵</p>
</summary>
<p><img src="/oi-blog/post_images/qun_3.png" /></p>

</details>
]]></content>
      <categories>
        <category>学习总结</category>
      </categories>
      <tags>
        <tag>数学</tag>
        <tag>群论</tag>
        <tag>计数</tag>
      </tags>
  </entry>
  <entry>
    <title>「杂题记录」Mex</title>
    <url>//%E3%80%8C%E6%9D%82%E9%A2%98%E8%AE%B0%E5%BD%95%E3%80%8DMex/</url>
    <content><![CDATA[<p>Mex 构造题 (P6852 )</p>
<p>给出一些限制，需要还原一个排列，限制形如：<span class="math inline">\([L, R]\)</span> <span class="math inline">\(v\)</span> ，表示排列 <span class="math inline">\([L, R]\)</span> 的Mex 为 <span class="math inline">\(v\)</span>。 给出任意一种构造方案. <span class="math inline">\(|P|\le 10^5\)</span> <a id="more"></a> ## 分析</p>
<p>分析 Mex 值为 <span class="math inline">\(v\)</span> 的限制，能够提供两种信息，一种是这段区间中 <span class="math inline">\(1\)</span>~<span class="math inline">\(v - 1\)</span> 全部存在，一种是不存在 <span class="math inline">\(v\)</span></p>
<p>考虑一个数字 <span class="math inline">\(x\)</span> 的存在位置有哪些限制，不难发现，所有 <span class="math inline">\(v\ge x\)</span> 的限制都会对这个值得位置产生限制。</p>
<p>其实就是所有 <span class="math inline">\(v\ge x\)</span> 的限制的交集。区间并不好维护，区间交要好维护的多。</p>
<p>从下到大确定 <span class="math inline">\(x\)</span> 的位置，可以发现可选区间单增，可以直接填数，能保证最优。</p>
<p>注意 Mex 的第二条限制，可以考虑用线段树或者 set 维护哪些地方没有被占用。</p>
]]></content>
      <categories>
        <category>杂题记录</category>
      </categories>
      <tags>
        <tag>Mex</tag>
        <tag>单调性</tag>
      </tags>
  </entry>
  <entry>
    <title>「CSP2019 校内6连测」Day2_Tree</title>
    <url>//%E3%80%8C%E6%9D%82%E9%A2%98%E8%AE%B0%E5%BD%95%E3%80%8D%E3%80%8CCSP2019-%E6%A0%A1%E5%86%856%E8%BF%9E%E6%B5%8B%E3%80%8DDay2_Tree/</url>
    <content><![CDATA[<p>一道趣题。 <a id="more"></a></p>
<h1 id="校内6连测day2">校内6连测Day2</h1>
<h2 id="tree">Tree</h2>
<p><a href="https://shuyumo-1258548314.cos.ap-beijing.myqcloud.com/OI/Contest/20191107/problem_day1.pdf">原题</a></p>
<p><img src="https://img-1258548314.cos.ap-beijing.myqcloud.com/PIC.jpg" /> 面向数据编程：</p>
<h3 id="subtask1">subtask1</h3>
<p>由于题目没有给定根，所以第一个想法就是枚举根，然后在每个点检查子树是否包含每一个颜色，更新答案。<br />
具体可以状压啊，（暴力统计也能过），需要注意的是状态压缩时，设置状态中<code>1 &lt;&lt; 50</code>这样的语句时不可以的。(应该为<code>1LL &lt;&lt; 50</code>)；<br />
### subtask2 只有一种颜色，找一个最长的链即可，就是树的直径。 ### subtask3 发现要是想要<code>AC</code>这道题，枚举根肯定是没前途的，除非可以确定一个根，然后直接<span class="math inline">\(O(1)\)</span>猜答案。</p>
<p>先随便找一个点作为临时的根，然后对于我们枚举到的一个点，我们考虑它作为 LCA的时候的最优答案，显然真正的根有两种情况： - 在当前点为根的子树中。 - 不在他的子树内。 对于这几种情况，我们都算一个最远的那个点离他多远，把最远的那个合法的点作为根就可以。</p>
<p>比如， 右边这个图，当真正的根是 <strong>6</strong>，当前点是<strong>3</strong>的时候，我们就需要知道，他的子树的点集 <strong>T={1,2,3,5,9,8}</strong>这个集合里面是否包含了每种颜色的点。</p>
<p><img src="https://img-1258548314.cos.ap-beijing.myqcloud.com/pic2.jpg" /></p>
<p>这是正解的弱化版本，树形<code>DP</code>， <code>f[i][j]</code>表示在树上结点<code>i</code>，颜色<code>j</code>的数量。</p>
<p>那么我们就可以用 <code>f[1]-f[4]</code>算得 <code>T</code> 中包含的每种颜色的点的个数。 我们对于每个点，枚举根在哪个方向， 算这个方向上最远的点， 复杂度是 <span class="math inline">\(O(n)\)</span>的。</p>
<p>算<span class="math inline">\(f[i][j]\)</span>的总复杂度是 <span class="math inline">\(O(nm)\)</span>的， 枚举根方向再算合不合法，复杂度也是 <span class="math inline">\(O(nm)\)</span>。所以总复杂度是 <span class="math inline">\(O(nm)\)</span>.</p>
<h1 id="subtask4">subtask4</h1>
<p>归纳上一个<code>subtask3</code>发现其实对于每一个点，只需要知道两个信息即可： - 这个点为根的子树是否包含所有的颜色 - 整棵树抛去这个点为根的子树是否包含所有的颜色（称之为这个点为根的子树的反树）</p>
<p>还是先选一个临时的根，分开考虑两种情况 - 到一个点之后判断 以 这个点为根的子树是否包含所有的颜色。设以某个点<span class="math inline">\(i\)</span>为根的子树所包含的元素种类数为<span class="math inline">\(W_i\)</span><br />
考虑一个点对这个点到根这条链上的贡献，每个点都会使得这个点到根这条链上的点所有点<span class="math inline">\(j\)</span>的<span class="math inline">\(W_j + 1\)</span>。 但是考虑两个相同颜色的点，对答案贡献之后，会使这两个点的<code>LCA</code>到根这条路径上的点都被<strong>加重复</strong>了一次。所以这条路径上的点都需要再<span class="math inline">\(-1\)</span>。<br />
树上的路径操作——树上差分即可完成。注意，需要对同一种颜色的点按照<code>DFS</code>序排序，然后两两求<code>LCA</code>可以发现，只有这样做才是对的。<br />
对这个树进行差分，然后能在<code>DFS</code>的过程中求得每个点为根的子树中的颜色种类数量。如果颜色种类数量为<span class="math inline">\(m\)</span>那就说明这个子树已经包含了所有的颜色，那么这个点就是题目要求的<code>LCA</code>之一，然后用向上最长链（可以预处理出来，其实不是向上的最长链，只要这条链的终点不在当前子树中即可，也就是选取这个链的终点当作真正的根）更新答案。 - 如何判断一个点为根的的子树的反树包含了所有的点。其实可以反过来想，一个反树包含所有的颜色，也就是某一种颜色并没有被当前子树全部包含。求出每种颜色全部点的<code>LCA</code>。显然，选取的能够更新答案的点不是这些<code>LCA</code>的祖先。 预处理每一个种颜色所有点的<code>LCA</code>，然后进行在那个点打标记。最后dfs上传标记即可，设当前点为<span class="math inline">\(now\)</span>，儿子结点为<span class="math inline">\(to\)</span>，那么标记数组<span class="math inline">\(f[i]\)</span>就等于<span class="math inline">\(f[now] |= f[to]\)</span>。 最后检查每一个没被打过标记的点，用向下最长链（可以预处理，也就是这个点往下和一个最深的叶子结点的距离，也就是选取这个最深的叶子结点当真正的根）更新答案。</p>
<p>这两种情况更新完答案就做完了</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">#include&lt;cstdio&gt;
#include&lt;iostream&gt;
#include&lt;cstring&gt;
#include&lt;cmath&gt;
#include&lt;algorithm&gt;
#include&lt;vector&gt;
#define _R register
using namespace std;
const int _N &#x3D; 1e6 + 100;
const int _M &#x3D; 2e6 + 100;
inline int read()
&#123;
    char c &#x3D; getchar(); int sign &#x3D; 1; int x &#x3D; 0;
    while(c &gt; &#39;9&#39; || c &lt; &#39;0&#39;) &#123; if(c&#x3D;&#x3D;&#39;-&#39;)sign &#x3D; -1; c &#x3D; getchar(); &#125;
    while(c &lt;&#x3D; &#39;9&#39; &amp;&amp; c &gt;&#x3D; &#39;0&#39;) &#123; x *&#x3D; 10; x +&#x3D; c - &#39;0&#39;; c &#x3D; getchar(); &#125;
    return x * sign;
&#125;
int head[_N];
struct edges&#123;
	int node;
	int nxt;
&#125;edge[_M];
int tot &#x3D; 0;
void add(int u, int v)&#123;
	edge[++tot].nxt &#x3D; head[u];
	head[u] &#x3D; tot;
	edge[tot].node &#x3D; v;
&#125;
int n, m;
int col[_N];
int root;
int MaxDeep[_N];
int MaxUp[_N];
void dfs1(int now, int fa)&#123;
	int Maxdp &#x3D; -1;
	for(_R int i &#x3D; head[now];i;i &#x3D; edge[i].nxt)&#123;
		int to &#x3D; edge[i].node;
		if(to &#x3D;&#x3D; fa) continue;
		dfs1(to, now);
		Maxdp &#x3D; max(Maxdp, MaxDeep[to]);
	&#125;
	MaxDeep[now] &#x3D; Maxdp + 1;
&#125;
void dfs2(int now, int fa)
&#123;
	int MaxVal1 &#x3D; -1;int MaxNode1;
	int MaxVal2 &#x3D; -1;int MaxNode2;
	for(_R int i &#x3D; head[now];i;i &#x3D; edge[i].nxt)&#123;
		int to &#x3D; edge[i].node;
		if(to &#x3D;&#x3D; fa) continue;
		if(MaxVal1 &lt; MaxDeep[to]) &#123;
			MaxVal2 &#x3D; MaxVal1;MaxNode2 &#x3D; MaxNode1;
			MaxVal1 &#x3D; MaxDeep[to];MaxNode1 &#x3D; to;
		&#125; else MaxVal2 &#x3D; max(MaxVal2, MaxDeep[to]);
	&#125;
	for(_R int i &#x3D; head[now];i;i &#x3D; edge[i].nxt)&#123;
		int to &#x3D; edge[i].node;
		if(to &#x3D;&#x3D; fa) continue;
		MaxUp[to] &#x3D; max((MaxDeep[to] &#x3D;&#x3D; MaxVal1 ? MaxVal2 + 2 : MaxVal1 + 2), MaxUp[now] + 1);
	&#125;
	for(_R int i &#x3D; head[now];i;i &#x3D; edge[i].nxt)&#123;
		int to &#x3D; edge[i].node;
		if(to &#x3D;&#x3D; fa) continue;
		dfs2(to, now);
	&#125;
&#125;
namespace LCA&#123;
	const int Log &#x3D; 20;
	int anc[_N][Log + 5];
	int deep[_N];
	void dfs(int now, int fa, int dp)&#123;
		anc[now][0] &#x3D; fa;
		deep[now] &#x3D; dp;
		for(_R int i &#x3D; head[now];i;i &#x3D; edge[i].nxt)&#123;
			int to &#x3D; edge[i].node;
			if(to &#x3D;&#x3D; fa) continue;
			dfs(to, now, dp + 1);
		&#125;
	&#125;
	void work()
	&#123;
		dfs(root, root, 1);
		for(_R int j &#x3D; 1;j &lt;&#x3D; Log;j++)&#123;
			for(_R int i &#x3D; 1;i &lt;&#x3D; n;i++)&#123;
				anc[i][j] &#x3D; anc[anc[i][j - 1]][j - 1];
			&#125;
		&#125;
	&#125;
	int query(int x, int y)&#123;
		if(deep[x] &lt; deep[y]) swap(x, y);
		int dis &#x3D; deep[x] - deep[y];
		int now &#x3D; 0;
		while(dis !&#x3D; 0)&#123;
			if(dis &amp; 1) x &#x3D; anc[x][now];
			now ++;
			dis &gt;&gt;&#x3D; 1;
		&#125;
		if(x &#x3D;&#x3D; y) return x;
		for(_R int i &#x3D; Log;i &gt;&#x3D; 0;i--)&#123;
			if(anc[x][i] &#x3D;&#x3D; anc[y][i])continue;
			x &#x3D; anc[x][i];
			y &#x3D; anc[y][i];
		&#125;
		return anc[x][0];
	&#125;
&#125;

int tar[_N];
int colorLCA[_N];
int ans &#x3D; 0;
namespace Status1&#123;
	int S[_N];
	int LCnd[_N];
	vector&lt;pair&lt;int, int&gt; &gt;dfn[_N];&#x2F;&#x2F;DFN Id
	int tot &#x3D; 0;
	void dfs_pre(int now, int fa)&#123;
		dfn[col[now]].push_back(make_pair(++tot, now));
		for(_R int i &#x3D; head[now];i;i &#x3D; edge[i].nxt)&#123;
			int to &#x3D; edge[i].node;
			if(to &#x3D;&#x3D; fa) continue;
			dfs_pre(to, now);
		&#125;
	&#125;
	int dfs(int now, int fa)&#123;
		int v &#x3D; S[now];
		for(_R int i &#x3D; head[now];i;i &#x3D; edge[i].nxt)&#123;
			int to &#x3D; edge[i].node;
			if(to &#x3D;&#x3D; fa) continue;
			v +&#x3D; dfs(to, now);
		&#125;
		if(v &#x3D;&#x3D; m) ans &#x3D; max(ans, MaxUp[now] + 1);
		return v;
	&#125;
	void work()&#123;
		dfs_pre(root, root);
		for(_R int i &#x3D; 1;i &lt;&#x3D; m;i++) sort(dfn[i].begin(), dfn[i].end());
		for(_R int i &#x3D; 1;i &lt;&#x3D; m;i++)&#123;
			S[dfn[i][0].second] ++;
			for(_R int j &#x3D; 1;j &lt; dfn[i].size();j++)&#123;
				S[LCA::query(dfn[i][j - 1].second, dfn[i][j].second)] --;
				S[dfn[i][j].second] ++;
			&#125;
		&#125;
		dfs(root, root);
	&#125;
&#125;

namespace Status2&#123;
	void dfs(int now, int fa)&#123;
		for(_R int i &#x3D; head[now];i;i &#x3D; edge[i].nxt)&#123;
			int to &#x3D; edge[i].node;
			if(to &#x3D;&#x3D; fa) continue;
			dfs(to, now);tar[now] |&#x3D; tar[to];
		&#125;
	&#125;
	void work()&#123;
		dfs(root, root);
		for(_R int i &#x3D; 1;i &lt;&#x3D; n;i++)&#123;
			if(tar[i] &#x3D;&#x3D; 0)&#123;&#x2F;&#x2F;反树 包含全集；
				ans &#x3D; max(ans, MaxDeep[i] + 2);
			&#125;
		&#125;
	&#125;
&#125;
signed main()
&#123;
	n &#x3D; read(), m &#x3D; read();
	int maxx &#x3D; -1;
	for(_R int i &#x3D; 1;i &lt;&#x3D; n;i++) col[i] &#x3D; read(), maxx &#x3D; max(maxx, col[i]);
	for(_R int i &#x3D; 1;i &lt; n;i++)&#123;
		int tmpx &#x3D; read(), tmpy &#x3D; read();
		add(tmpx, tmpy);
		add(tmpy, tmpx);
	&#125;
	root &#x3D; 1;
	dfs1(root, root);
	dfs2(root, root);
	LCA::work();
	for(_R int i &#x3D; 1;i &lt;&#x3D; n;i++)&#123;
		int &amp;cl &#x3D; colorLCA[col[i]];
		if(cl &#x3D;&#x3D; 0) cl &#x3D; i;
		else cl &#x3D; LCA::query(cl, i);
	&#125;
	for(_R int i &#x3D; 1;i &lt;&#x3D; m;i++) tar[colorLCA[i]] &#x3D; 1;

	Status1::work();

	Status2::work();

	cout &lt;&lt; ans &lt;&lt; endl;
	return 0;
 &#125; <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
]]></content>
      <categories>
        <category>杂题记录</category>
      </categories>
      <tags>
        <tag>树上问题</tag>
      </tags>
  </entry>
  <entry>
    <title>「杂题记录」「CTSC2017」吉夫特</title>
    <url>//%E3%80%8C%E6%9D%82%E9%A2%98%E8%AE%B0%E5%BD%95%E3%80%8D%E3%80%8CCTSC2017%E3%80%8D%E5%90%89%E5%A4%AB%E7%89%B9/</url>
    <content><![CDATA[<p>给出一个长度为 <span class="math inline">\(n\)</span> 的数列 <span class="math inline">\(A_i\)</span> ，求有多少个长度 <span class="math inline">\(k\)</span> 的子序列 <span class="math inline">\(A&#39;\)</span> (<span class="math inline">\(k\ge 2\)</span>)满足： <span class="math display">\[
\prod_{i=1}^{k-1}\dbinom{A&#39;_i}{A&#39;_{i+1}} &gt; 0 \pmod{2}
\]</span> <span class="math inline">\(n \le 211985, A_i \le 233333\)</span>。原题保证 <span class="math inline">\(A_i\)</span> 互不相同，但是不重要。</p>
<a id="more"></a>
<h2 id="分析">分析</h2>
<p>根据 Lucas 定理，就是求有多少 <span class="math inline">\(A\)</span> 的子序列 <span class="math inline">\(A&#39;\)</span> 满足: <span class="math display">\[
\forall i \in [1, k-1]，S(A_i) \subseteq S(A_{i+1})
\]</span> <span class="math inline">\(S(x)\)</span> 表示二进制数 <span class="math inline">\(x\)</span> 表示的集合。</p>
<p>这东西可以直接 dp ，设 <span class="math inline">\(f(i)\)</span> 表示以 <span class="math inline">\(i\)</span> 结尾的合法子序列有多少： <span class="math display">\[
f(n) \sum_{i=1}^{n-1} f(i)[A_i \operatorname{and}A_n=A_n]
\]</span> 直接暴力枚举是 <span class="math inline">\(\mathcal{O}(n^2)\)</span> 的。</p>
<p>考虑类似于分块一样的优化，考虑将 <span class="math inline">\(A_i\)</span> 拆开，设 <span class="math inline">\(A_i\)</span> 二进制下的前 9 位为 <span class="math inline">\(x\)</span>, 后 9 位为 <span class="math inline">\(y\)</span>。 <span class="math inline">\(g(x, y)\)</span> 表示前九位恰好为 <span class="math inline">\(x\)</span> ，后九位是 <span class="math inline">\(y\)</span> 的子集的 <span class="math inline">\(A_i\)</span> 的对应 <span class="math inline">\(f(i)\)</span> 之和。</p>
<p>考虑维护这个东西，求出一个 <span class="math inline">\(g(i)\)</span> 后枚举子集更新。</p>
<p>考虑使用这个东西，在求一个 <span class="math inline">\(g(i)\)</span> 时，枚举子集求出。</p>
<p>成功均摊了复杂度。 总复杂度 <span class="math inline">\(\mathcal{O}(2^{9}n)\)</span></p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">const int _ &#x3D; 241985;
const int MOD &#x3D; 1e9 + 7;
int A[_], n, f[_];
int g[1 &lt;&lt; 10][1 &lt;&lt; 10]; &#x2F;&#x2F; g[x][y]: 当前，所有满足 A_i 的前 9 位为 x ，后 9 位为 y 的超集。
inline int &amp; reduce(int &amp;x) &#123; if(x &gt;&#x3D; MOD) x-&#x3D; MOD; if(x &lt; 0) x +&#x3D; MOD; return x; &#125;
int main()&#123;
	ios::sync_with_stdio(false);
	cin &gt;&gt; n; rep(i, 1, n) cin &gt;&gt; A[i]; &#x2F;&#x2F; 要求前面的数字为后面的超集。
	register int LB &#x3D; (1 &lt;&lt; 9) - 1;
	register int All &#x3D; ((1 &lt;&lt; 9) - 1);
	f[1] &#x3D; 1;
	g[A[1] &gt;&gt; 9][0] +&#x3D; 1;
	register int S0 &#x3D; A[1] &amp; LB; for(register int S &#x3D; (S0); S; S &#x3D; (S - 1) &amp; (S0)) reduce(g[A[1] &gt;&gt; 9][S] +&#x3D; 1);
	register int $1;
	rep(i, 2, n) &#123;
		int now &#x3D; ((1 &lt;&lt; 9) - 1) ^ (A[i] &gt;&gt; 9);
		int &amp;ans &#x3D; f[i] &#x3D; 1 ;
		$1 &#x3D; A[i] &gt;&gt; 9;
		reduce(ans +&#x3D; g[$1][A[i] &amp; LB]);
		for(int S &#x3D; now; S; S &#x3D; (S - 1) &amp; (now)) reduce(ans +&#x3D; g[S | $1][A[i] &amp; LB]);
		reduce(g[$1][0] +&#x3D; ans);
		for(int S &#x3D; (A[i] &amp; LB); S; S &#x3D; (S - 1) &amp; (A[i] &amp; LB)) reduce(g[$1][S] +&#x3D; ans);
	&#125;
	int Ans &#x3D; 0;
	for(int i &#x3D; 1; i &lt;&#x3D; n; i++) reduce(Ans +&#x3D; f[i]); reduce(Ans +&#x3D; MOD - n);
	cout &lt;&lt; Ans &lt;&lt; endl;
	return 0;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
]]></content>
      <categories>
        <category>杂题记录</category>
      </categories>
      <tags>
        <tag>题解</tag>
        <tag>dp</tag>
        <tag>技巧</tag>
        <tag>分块</tag>
      </tags>
  </entry>
  <entry>
    <title>「杂题记录」「NOI 2018」屠龙勇士</title>
    <url>//%E3%80%8C%E6%9D%82%E9%A2%98%E8%AE%B0%E5%BD%95%E3%80%8D%E3%80%8CNOI-2018%E3%80%8D%E5%B1%A0%E9%BE%99%E5%8B%87%E5%A3%AB/</url>
    <content><![CDATA[<p>小 D 最近在网上发现了一款小游戏。游戏的规则如下：</p>
<a id="more"></a>
<ul>
<li>游戏的目标是按照编号 <span class="math inline">\(1 \rightarrow n\)</span> 顺序杀掉 <span class="math inline">\(n\)</span> 条巨龙，每条巨龙拥有一个初始的生命值 <span class="math inline">\(a_i\)</span> 。同时每条巨龙拥有恢复能力，当其使用恢复能力时，它的生命值就会每次增加 <span class="math inline">\(p_i\)</span> ，直至生命值非负。只有在攻击结束后且当生命值 <strong>恰好</strong> 为 <span class="math inline">\(0\)</span> 时它才会死去。</li>
<li>游戏开始时玩家拥有 <span class="math inline">\(m\)</span> 把攻击力已知的剑，每次面对巨龙时，玩家只能选择一把剑，当杀死巨龙后这把剑就会消失，但作为奖励，玩家会获得全新的一把剑。</li>
</ul>
<p>小 D 觉得这款游戏十分无聊，但最快通关的玩家可以获得 ION2018 的参赛资格，于是小 D 决定写一个笨笨的机器人帮她通关这款游戏，她写的机器人遵循以下规则：</p>
<ul>
<li>每次面对巨龙时，机器人会选择当前拥有的，攻击力不高于巨龙初始生命值中攻击力最大的一把剑作为武器。如果没有这样的剑，则选择 <strong>攻击力最低</strong> 的一把剑作为武器。</li>
<li>机器人面对每条巨龙，它都会使用上一步中选择的剑攻击巨龙固定的 <span class="math inline">\(x\)</span> 次，使巨龙的生命值减少 <span class="math inline">\(x \times ATK\)</span> 。</li>
<li>之后，巨龙会不断使用恢复能力，每次恢复 <span class="math inline">\(p_i\)</span> 生命值。若在使用恢复能力前或某一次恢复后其生命值为 <span class="math inline">\(0\)</span> ，则巨龙死亡，玩家通过本关。</li>
</ul>
<p>那么显然机器人的攻击次数是决定能否最快通关这款游戏的关键。小 D 现在得知了每条巨龙的所有属性，她想考考你，你知道应该将机器人的攻击次数 <span class="math inline">\(x\)</span> 设置为多少，才能用最少的攻击次数通关游戏吗？</p>
<p>当然如果无论设置成多少都无法通关游戏，输出 <span class="math inline">\(-1\)</span>.</p>
<table>
<thead>
<tr class="header">
<th>测试点编号</th>
<th><span class="math inline">\(n\)</span></th>
<th><span class="math inline">\(m\)</span></th>
<th><span class="math inline">\(p_i\)</span></th>
<th><span class="math inline">\(a_i\)</span></th>
<th>攻击力</th>
<th>其他限制</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>1</td>
<td><span class="math inline">\(\le 10^5\)</span></td>
<td><span class="math inline">\(=1\)</span></td>
<td><span class="math inline">\(=1\)</span></td>
<td><span class="math inline">\(\le 10^5\)</span></td>
<td><span class="math inline">\(=1\)</span></td>
<td>无</td>
</tr>
<tr class="even">
<td>2</td>
<td><span class="math inline">\(\le 10^5\)</span></td>
<td><span class="math inline">\(=1\)</span></td>
<td><span class="math inline">\(=1\)</span></td>
<td><span class="math inline">\(\le 10^5\)</span></td>
<td><span class="math inline">\(=1\)</span></td>
<td>无</td>
</tr>
<tr class="odd">
<td>3</td>
<td><span class="math inline">\(\le 10^5\)</span></td>
<td><span class="math inline">\(=1\)</span></td>
<td><span class="math inline">\(=1\)</span></td>
<td><span class="math inline">\(\le 10^5\)</span></td>
<td><span class="math inline">\(\le 10^5\)</span></td>
<td>无</td>
</tr>
<tr class="even">
<td>4</td>
<td><span class="math inline">\(\le 10^5\)</span></td>
<td><span class="math inline">\(=1\)</span></td>
<td><span class="math inline">\(=1\)</span></td>
<td><span class="math inline">\(\le 10^5\)</span></td>
<td><span class="math inline">\(\le 10^5\)</span></td>
<td>无</td>
</tr>
<tr class="odd">
<td>5</td>
<td><span class="math inline">\(\le 10^3\)</span></td>
<td><span class="math inline">\(\le 10^3\)</span></td>
<td><span class="math inline">\(\le 10^5\)</span></td>
<td><span class="math inline">\(\le 10^5\)</span></td>
<td><span class="math inline">\(\le 10^5\)</span></td>
<td>特性 1、特性 2</td>
</tr>
<tr class="even">
<td>6</td>
<td><span class="math inline">\(\le 10^3\)</span></td>
<td><span class="math inline">\(\le 10^3\)</span></td>
<td><span class="math inline">\(\le 10^5\)</span></td>
<td><span class="math inline">\(\le 10^5\)</span></td>
<td><span class="math inline">\(\le 10^5\)</span></td>
<td>特性 1、特性 2</td>
</tr>
<tr class="odd">
<td>7</td>
<td><span class="math inline">\(\le 10^3\)</span></td>
<td><span class="math inline">\(\le 10^3\)</span></td>
<td><span class="math inline">\(\le 10^5\)</span></td>
<td><span class="math inline">\(\le 10^5\)</span></td>
<td><span class="math inline">\(\le 10^5\)</span></td>
<td>特性 1、特性 2</td>
</tr>
<tr class="even">
<td>8</td>
<td><span class="math inline">\(=1\)</span></td>
<td><span class="math inline">\(=1\)</span></td>
<td><span class="math inline">\(\le 10^8\)</span></td>
<td><span class="math inline">\(\le 10^8\)</span></td>
<td><span class="math inline">\(\le 10^6\)</span></td>
<td>特性 1</td>
</tr>
<tr class="odd">
<td>9</td>
<td><span class="math inline">\(=1\)</span></td>
<td><span class="math inline">\(=1\)</span></td>
<td><span class="math inline">\(\le 10^8\)</span></td>
<td><span class="math inline">\(\le 10^8\)</span></td>
<td><span class="math inline">\(\le 10^6\)</span></td>
<td>特性 1</td>
</tr>
<tr class="even">
<td>10</td>
<td><span class="math inline">\(=1\)</span></td>
<td><span class="math inline">\(=1\)</span></td>
<td><span class="math inline">\(\le 10^8\)</span></td>
<td><span class="math inline">\(\le 10^8\)</span></td>
<td><span class="math inline">\(\le 10^6\)</span></td>
<td>特性 1</td>
</tr>
<tr class="odd">
<td>11</td>
<td><span class="math inline">\(=1\)</span></td>
<td><span class="math inline">\(=1\)</span></td>
<td><span class="math inline">\(\le 10^8\)</span></td>
<td><span class="math inline">\(\le 10^8\)</span></td>
<td><span class="math inline">\(\le 10^6\)</span></td>
<td>特性 1</td>
</tr>
<tr class="even">
<td>12</td>
<td><span class="math inline">\(=1\)</span></td>
<td><span class="math inline">\(=1\)</span></td>
<td><span class="math inline">\(\le 10^8\)</span></td>
<td><span class="math inline">\(\le 10^8\)</span></td>
<td><span class="math inline">\(\le 10^6\)</span></td>
<td>特性 1</td>
</tr>
<tr class="odd">
<td>13</td>
<td><span class="math inline">\(=1\)</span></td>
<td><span class="math inline">\(=1\)</span></td>
<td><span class="math inline">\(\le 10^8\)</span></td>
<td><span class="math inline">\(\le 10^8\)</span></td>
<td><span class="math inline">\(\le 10^6\)</span></td>
<td>特性 1</td>
</tr>
<tr class="even">
<td>14</td>
<td><span class="math inline">\(=10^5\)</span></td>
<td><span class="math inline">\(=10^5\)</span></td>
<td><span class="math inline">\(=1\)</span></td>
<td><span class="math inline">\(\le 10^8\)</span></td>
<td><span class="math inline">\(\le 10^6\)</span></td>
<td>无特殊限制</td>
</tr>
<tr class="odd">
<td>15</td>
<td><span class="math inline">\(=10^5\)</span></td>
<td><span class="math inline">\(=10^5\)</span></td>
<td><span class="math inline">\(=1\)</span></td>
<td><span class="math inline">\(\le 10^8\)</span></td>
<td><span class="math inline">\(\le 10^6\)</span></td>
<td>无特殊限制</td>
</tr>
<tr class="even">
<td>16</td>
<td><span class="math inline">\(\le 10^5\)</span></td>
<td><span class="math inline">\(\le 10^5\)</span></td>
<td>所有 <span class="math inline">\(p_i\)</span> 是质数</td>
<td><span class="math inline">\(\le 10^{12}\)</span></td>
<td><span class="math inline">\(\le 10^6\)</span></td>
<td>特性 1</td>
</tr>
<tr class="odd">
<td>17</td>
<td><span class="math inline">\(\le 10^5\)</span></td>
<td><span class="math inline">\(\le 10^5\)</span></td>
<td>所有 <span class="math inline">\(p_i\)</span> 是质数</td>
<td><span class="math inline">\(\le 10^{12}\)</span></td>
<td><span class="math inline">\(\le 10^6\)</span></td>
<td>特性 1</td>
</tr>
<tr class="even">
<td>18</td>
<td><span class="math inline">\(\le 10^5\)</span></td>
<td><span class="math inline">\(\le 10^5\)</span></td>
<td>无特殊限制</td>
<td><span class="math inline">\(\le 10^{12}\)</span></td>
<td><span class="math inline">\(\le 10^6\)</span></td>
<td>特性 1</td>
</tr>
<tr class="odd">
<td>19</td>
<td><span class="math inline">\(\le 10^5\)</span></td>
<td><span class="math inline">\(\le 10^5\)</span></td>
<td>无特殊限制</td>
<td><span class="math inline">\(\le 10^{12}\)</span></td>
<td><span class="math inline">\(\le 10^6\)</span></td>
<td>特性 1</td>
</tr>
<tr class="even">
<td>20</td>
<td><span class="math inline">\(\le 10^5\)</span></td>
<td><span class="math inline">\(\le 10^5\)</span></td>
<td>无特殊限制</td>
<td><span class="math inline">\(\le 10^{12}\)</span></td>
<td><span class="math inline">\(\le 10^6\)</span></td>
<td>特性 1</td>
</tr>
</tbody>
</table>
<p>特性 1 是指：对于任意的 <span class="math inline">\(i\)</span>，<span class="math inline">\(a_i \le p_i\)</span>。</p>
<p>特性 2 是指：<span class="math inline">\(\operatorname{lcm}(p_i) \le 10^6\)</span>，即所有 <span class="math inline">\(p_i\)</span> 的 <strong>最小公倍数</strong> 不大于 <span class="math inline">\(10^6\)</span>。</p>
<p>对于所有的测试点，<span class="math inline">\(T \le 5\)</span>，所有武器的攻击力 <span class="math inline">\(\le 10^6\)</span>，所有 <span class="math inline">\(p_i\)</span> 的最小公倍数 <span class="math inline">\(\le 10^{12}\)</span>。</p>
<p>保证 $ T, n, m $ 均为正整数。</p>
<h2 id="分析">分析</h2>
<p>易知这可以直接转化为 exCRT 问题。</p>
<p>主要记录一下不定方程的获取所有解问题。</p>
<p>不定方程形如： <span class="math display">\[
ax+by=c
\]</span> 其中 <span class="math inline">\(x, y\)</span> 为未知数， <span class="math inline">\(a, b\)</span> 为常数。</p>
<p><strong>裴蜀定理</strong> 指出：以上方程有整数解的充要条件为 <span class="math inline">\((a, b)|c\)</span>。</p>
<p><strong>扩展欧几里得</strong> 可以解出形如： <span class="math display">\[
ax+by=(a, b)
\]</span> 不定方程的一组整数解。</p>
<p>考虑构造以下式子： <span class="math display">\[
a\left(x+\frac{b}{(a, b)}\right)+b\left(y-\frac{a}{(a, b)}\right)=(a, b)
\]</span> 不难发现如果令： <span class="math inline">\(x&#39; = x+\frac{b}{(a, b)}, y&#39;=y-\frac{a}{(a, b)}\)</span>，这样构造出来的所有解 <span class="math inline">\(x&#39;, y&#39;\)</span> 都能成为不定方程的一组解，可以证明这样的构造方式的<em>调整系数</em>是最小的，能够取到所有解。（个人喜欢把 <span class="math inline">\(\frac{*}{(a, b)}\)</span> 称为<em>调整系数</em>）</p>
<p>考虑到上面的 <strong>扩展欧几里得</strong> 解出的方程常数项等于 <span class="math inline">\((a, b)\)</span>，而不是 <span class="math inline">\(c\)</span> ，考虑将解和 <span class="math inline">\((a, b)\)</span> 一同乘 <span class="math inline">\(\frac{c}{(a, b)}\)</span> 即可。</p>
<p>需要注意，乘完 <span class="math inline">\(\frac{c}{(a, b)}\)</span> 后，调整系数 <strong>不变</strong>。</p>
<p>关于题目，也没有题解里面说的那么卡…注意一下数据范围里面 <span class="math inline">\(P_i = 1\)</span> 的情况即可。</p>
<p>关于代码，换了一种 exCRT 的写法，应该会好背很多，。</p>
]]></content>
      <categories>
        <category>杂题记录</category>
      </categories>
      <tags>
        <tag>同余方程</tag>
        <tag>CRT</tag>
      </tags>
  </entry>
  <entry>
    <title>「杂题记录」「WC2020」猜数游戏</title>
    <url>//%E3%80%8C%E6%9D%82%E9%A2%98%E8%AE%B0%E5%BD%95%E3%80%8D%E3%80%8CWC2020%E3%80%8D%E7%8C%9C%E6%95%B0%E6%B8%B8%E6%88%8F/</url>
    <content><![CDATA[<p><a href="https://www.luogu.com.cn/problem/P6730">猜数游戏</a></p>
<p>给出一个长度为 <span class="math inline">\(n\)</span> 的序列和一个正整数 <span class="math inline">\(p\)</span>。</p>
<p>设 <span class="math inline">\(n\)</span> 中的元素组成一个集合 <span class="math inline">\(A\)</span>。</p>
<p>二人交互：</p>
<ul>
<li>一人选出一个 <span class="math inline">\(A\)</span> 的一个非空子集 <span class="math inline">\(S\)</span> ，</li>
<li>另一人选出一个极小的集合 <span class="math inline">\(S&#39; \subseteq S\)</span>，满足：<span class="math inline">\(\forall\ x \in S, \exists \ y \in S&#39;, s.t. x=y^m \pmod{p}\)</span>,代价为 <span class="math inline">\(|S&#39;|\)</span>.</li>
</ul>
<p>求代价的期望 <span class="math inline">\(\times 2^{n}-1 \mod 998244353\)</span>。</p>
<a id="more"></a>
<p>这里只是形式化的定义，不保证清晰。</p>
<p><span class="math inline">\(n\le 5000\)</span> ，<span class="math inline">\(p\)</span> 保证是奇素数幂的形式。</p>
<h2 id="分析">分析</h2>
<p>不难发现求期望就是在扯淡。</p>
<p>第一个人总共有 <span class="math inline">\(2^n-1\)</span> 种子集的选法，每种选法等概率。那么答案就是：<span class="math inline">\({每种选法的代价和} \times (2^n-1) / (2^n-1)\)</span> ，题目要求求出每种选法的代价和。</p>
<p>既然不能枚举子集，一一确定答案，就考虑算每个元素的贡献。</p>
<p>考虑建图，如果一个元素 <span class="math inline">\(y\)</span>, <span class="math inline">\(y^m \pmod{p}\)</span> 能够表示 <span class="math inline">\(x\)</span>，那么就让 <span class="math inline">\(y\)</span> 向 <span class="math inline">\(x\)</span> 连边。</p>
<p>考虑一种合法的最小子集选择方案,一定是靠近入度为 0 的一些点。换句话说，一个点 <span class="math inline">\(x\)</span> 能被选入极小集合 <span class="math inline">\(S&#39;\)</span> 当且仅当，没有别的选中的点可以走到这个点 <span class="math inline">\(x\)</span>.即：这个点对答案有贡献。</p>
<p>考虑一个点的贡献次数，也就是有多少种选点的方案使得任意一个选中的点都不能走到这个点，设可以走到这个点的点有 <span class="math inline">\(\operatorname{cnt}\)</span> 个，那么这个点对答案的贡献就是 <span class="math inline">\(2^{n-\operatorname{cnt}-1}\)</span>.</p>
<p>但是这个图是存在环的，也就是对于一个非空子集 <span class="math inline">\(S\)</span> 来说，存在多个最优集合，从原根的角度考虑连边条件。</p>
<p>设 <span class="math inline">\(p\)</span> 意义下的原根为 <span class="math inline">\(g\)</span>，点 <span class="math inline">\(A_i \equiv g^x \pmod{p},\ \ A_j \equiv g^y\pmod{p}\)</span> ，点 <span class="math inline">\(A_i\)</span> 与 <span class="math inline">\(A_j\)</span> 有边,需要满足：</p>
<p><span class="math display">\[
\exists m\in \mathbb{N},mx \equiv y \pmod{\varphi(p)}
\]</span></p>
<p>由于：</p>
<blockquote>
<p>"若 <span class="math inline">\(x\)</span> 是常数，那么 <span class="math inline">\(kx\)</span>模 <span class="math inline">\(m\)</span>能遍历所有形如 <span class="math inline">\(k(x,m)\)</span>的数" —— ckw,Mys.C.K.</p>
</blockquote>
<p>是会形成环的，所有形如 <span class="math inline">\(k(x, m)\)</span> 的元素之间两两有边。准确的说，每一个强连通分量都是一个团。</p>
<p>但是不重要，考虑每个环都可以任意定向，就是即使 <span class="math inline">\(x, y\)</span> 能相互表示，但是强制 <span class="math inline">\(x\)</span> 表示 <span class="math inline">\(y\)</span> 即可，这样对答案不会造成影响，相当于强制了一种最优集合的选择方式吧。</p>
<p>以上是对牌爷题解里 "<strong>显然</strong>" 的几点补充，建图方式参见<a href="https://www.luogu.com.cn/problem/solution/P6730">牌爷题解</a>，而且建图也没啥难的。</p>
]]></content>
      <categories>
        <category>杂题记录</category>
      </categories>
      <tags>
        <tag>数学</tag>
        <tag>数论</tag>
        <tag>建图</tag>
        <tag>原根</tag>
      </tags>
  </entry>
  <entry>
    <title>「杂题记录」「Ynoi」Y-fast trie</title>
    <url>//%E3%80%8C%E6%9D%82%E9%A2%98%E8%AE%B0%E5%BD%95%E3%80%8D%E3%80%8CYnoi%E3%80%8DY-fast-trie/</url>
    <content><![CDATA[<p>给定一个常数 <span class="math inline">\(C\)</span> ，维护一个集合 <span class="math inline">\(S\)</span> ，支持 <span class="math inline">\(n\)</span> 次操作：</p>
<ul>
<li>插入 <span class="math inline">\(x\)</span>，保证之前不存在 <span class="math inline">\(x\)</span>。</li>
<li>删除 <span class="math inline">\(x\)</span> ，保证之前存在 <span class="math inline">\(x\)</span>。</li>
</ul>
<p>每次操作后输出 <span class="math inline">\(\max_{i, j\in S, i \not = j}\limits{(i + j) \mod C}\)</span>。是指 <span class="math inline">\(\mod C\)</span> 意义下的最大值。</p>
<p>强制在线。</p>
<a id="more"></a>
<p><span class="math inline">\(n\le 5\times 10^5, 1 \le C \le 1073741823,0 \le x \le 1073741823\)</span></p>
<h2 id="分析">分析</h2>
<p>每个数字只能和两个数字匹配 可能成为最大值。</p>
]]></content>
      <categories>
        <category>杂题记录</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>Ynoi</tag>
      </tags>
  </entry>
  <entry>
    <title>「杂题记录」「YuGu P6018」「Ynoi」Fusion tree</title>
    <url>//%E3%80%8C%E6%9D%82%E9%A2%98%E8%AE%B0%E5%BD%95%E3%80%8D%E3%80%8CYuGu-P6018%E3%80%8D%E3%80%8CYnoi%E3%80%8DFusion-tree/</url>
    <content><![CDATA[<div class="note info"><p>给你一棵 <span class="math inline">\(n\)</span> 个结点的树，每个结点有权值。 <span class="math inline">\(m\)</span> 次操作。 需要支持以下操作。</p>
<ul>
<li>将树上与一个节点 <span class="math inline">\(x\)</span> 距离为 <span class="math inline">\(1\)</span> 的节点上的权值 <span class="math inline">\(+1\)</span> 。这里树上两点间的距离定义为从一点出发到另外一点的最短路径上边的条数。</li>
<li>在一个节点 <span class="math inline">\(x\)</span> 上的权值 <span class="math inline">\(-v\)</span> 。</li>
<li>询问树上与一个节点 <span class="math inline">\(x\)</span> 距离为 <span class="math inline">\(1\)</span> 的所有节点上的权值的异或和。 对于 <span class="math inline">\(100\%\)</span> 的数据，满足 <span class="math inline">\(1\le n \le 5\times 10^5\)</span> ， <span class="math inline">\(1\le m \le 5\times 10^5\)</span> ， <span class="math inline">\(0\le a_i \le 10^5\)</span> ， <span class="math inline">\(1 \le x \le n\)</span> ， <span class="math inline">\(opt\in\{1,2,3\}\)</span> 。 保证任意时刻每个节点的权值非负。</li>
</ul>
</div>
<a id="more"></a>
<div class="note success"><p>每个结点建立一棵 trie 维护其儿子的权值，trie 应该支持全局加一。 可以使用在每一个结点上设置懒标记来标记儿子的权值的增加量</p>
</div>
<h2 id="全局加一维护异或和">全局加一（维护异或和）</h2>
<p>这个不太好表述啊~<br />
<code>01-trie数</code> 是指字符集为 <span class="math inline">\(\{0,1\}\)</span> 的 Trie 树。<br />
<code>01-trie树</code>可以用来维护一堆数字的异或和，支持修改（删除+重新插入），和全部维护值加一。</p>
<p>如果要维护异或和，需要按值从低位到高位建立<code>trie</code>。</p>
<p><strong>一个约定</strong>：文中说当前节点<strong>往上</strong>指当前节点到根这条路径，当前节点<strong>往下</strong>指当前结点的子树。</p>
<h3 id="插入删除">插入&amp;删除</h3>
<p>如果要维护异或和，我们只需要知道某一位上<code>0</code>和<code>1</code>个数的奇偶性即可，也就是对于数字<code>1</code>来说，当且仅当这一位上数字<code>1</code>的个数为奇数时，这一位上的数字才是<code>1</code>。</p>
<p>对于每一个节点，我们需要记录以下三个量： - <code>ch[o][0/1]</code>指节点<code>o</code>的两个儿子，<code>ch[o][0]</code>指下一位是<code>0</code>，同理<code>ch[o][1]</code>指下一位是<code>0</code>。 - <code>w[o]</code>指节点<code>o</code>到其父亲节点这条边上数值的数量（权值）。每插入一个数字<code>x</code>，<code>x</code>二进制拆分后在 <code>trie</code>树上 路径的权值都会<code>+1</code>。 - <code>xorv[o]</code>指以<code>o</code>为根的子树维护的异或和。</p>
<p>具体维护结点的代码如下所示。</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">void maintain(int o)&#123;
		w[o] &#x3D; xorv[o] &#x3D; 0;
		if(ch[o][0])&#123; w[o] +&#x3D; w[ch[o][0]]; xorv[o] ^&#x3D;  xorv[ch[o][0]] &lt;&lt; 1; &#125;
		if(ch[o][1])&#123; w[o] +&#x3D; w[ch[o][1]]; xorv[o] ^&#x3D; (xorv[ch[o][1]] &lt;&lt; 1) | (w[ch[o][1]] &amp; 1); &#125;
		&#x2F;&#x2F;w[o] &#x3D; w[o] &amp; 1;
    	&#x2F;&#x2F;只需知道奇偶性即可，不需要具体的值。当然这句话删掉也可以，因为上文就只利用了他的奇偶性。
	&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>插入和删除的代码非常相似。</p>
<p>需要注意的地方就是：</p>
<ul>
<li><p>这里的<code>MAXH</code>指<code>trie</code>的深度，也就是强制让每一个叶子节点到根的距离为<code>MAXH</code>。对于一些比较小的值，可能有时候不需要建立这么深（例如：如果插入数字<code>4</code>，分解成二进制后为<code>100</code>， 从根开始插入<code>001</code>这三位即可），但是我们强制插入<code>MAXH</code>位。这样做的目的是为了便于全局<code>+1</code>时处理进位。例如：如果原数字是<code>3</code>（<code>11</code>），++之后变成<code>4</code>（<code>100</code>），如果当初插入<code>3</code>时只插入了<code>2</code>位，那这里的进位就没了。</p></li>
<li><p>插入和删除，只需要修改叶子节点的<code>w[]</code>即可，在回溯的过程中一路维护即可。</p></li>
</ul>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">namespace trie&#123;
	const int MAXH &#x3D; 21;
	int ch[_ * (MAXH + 1)][2], w[_ * (MAXH + 1)], xorv[_ * (MAXH + 1)];
	int tot &#x3D; 0;
	int mknode()&#123; ++tot; ch[tot][1] &#x3D; ch[tot][0] &#x3D; w[tot] &#x3D; xorv[tot] &#x3D; 0; return tot;&#125;
	void maintain(int o)&#123;
		w[o] &#x3D; xorv[o] &#x3D; 0;
		if(ch[o][0])&#123; w[o] +&#x3D; w[ch[o][0]]; xorv[o] ^&#x3D;  xorv[ch[o][0]] &lt;&lt; 1; &#125;
		if(ch[o][1])&#123; w[o] +&#x3D; w[ch[o][1]]; xorv[o] ^&#x3D; (xorv[ch[o][1]] &lt;&lt; 1) | (w[ch[o][1]] &amp; 1); &#125;
		w[o] &#x3D; w[o] &amp; 1;
	&#125;
	void insert(int &amp;o, int x, int dp)&#123;
		if(!o) o &#x3D; mknode();
		if(dp &gt; MAXH) return (void)(w[o] ++);
		insert(ch[o][ x&amp;1 ], x &gt;&gt; 1, dp + 1);
		maintain(o);
	&#125;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h3 id="全局加一">全局加一</h3>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">void addall(int o)&#123;
	swap(ch[o][0], ch[o][1]);
	if(ch[o][0]) addall(ch[o][0]);
	maintain(o);
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>不知道你能不能直接看懂呢？</p>
<p>我们思考一下二进制意义下<code>+1</code>是如何操作的。</p>
<p>我们只需要从低位到高位开始找第一个出现的<code>0</code>，把它变成<code>1</code>，然后这个位置后面的<code>1</code>都变成<code>0</code>即可。</p>
<p>下面给出几个例子感受一下。（括号内的数字表示其对应的十进制数字）</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">1000  (10)   + 1 &#x3D; 1001   (11)
10011 (19)   + 1 &#x3D; 10100  (20)
11111 (31)   + 1 &#x3D; 100000 (32)
10101 (21)   + 1 &#x3D; 10110  (22)
100000000111111(16447) + 1 &#x3D; 100000001000000(16448)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>回顾一下<code>w[o]</code>的定义：<code>w[o]</code>指节点<code>o</code>到其父亲节点这条边上数值的数量（权值）。</p>
<p>有没有感觉这个定义有点怪呢？如果在父亲结点存储到两个儿子的这条边的边权也许会更接近于习惯。但是在这里，在交换左右儿子的时候，在儿子结点存储到父亲这条边的距离，显然更加方便。</p>
<h2 id="trie合并"><code>01-trie</code>合并</h2>
<p>指的是将上述的两个<code>01-trie</code>进行合并，同时合并维护的信息。</p>
<p>我来编写此文字的初衷就是，合并<code>01-trie</code>的文字好像比较少？其实合并<code>01-trie</code>和合并线段树的思路非常相似。可以搜索<code>合并线段树</code>来学习如何合并<code>01-trie</code>。</p>
<p>其实合并<code>trie</code>非常简单，就是考虑一下我们有一个<code>int marge(int a, int b)</code>函数，这个函数传入两个<code>trie</code>树位于同一相对位置的结点编号，然后合并完成后返回合并完成的结点编号。</p>
<p>考虑怎么实现？</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">	int marge(int a, int b)&#123;
		if(!a) return b; &#x2F;&#x2F; 如果a没有这个位置上的结点，返回b
		if(!b) return a; &#x2F;&#x2F; 如果b没有这个位置上的结点，返回a
        &#x2F;&#x2F; 如果a, b都健在，那就把b的信息合并到a上，然后递归操作。
        &#x2F;&#x2F; 如果需要的合并是将a， b合并到一棵新树上，这里可以新建结点，然后进行合并。这里的代码实现仅仅是将b的信息合并到a上。
		w[a] &#x3D; w[a] + w[b];
		xorv[a] ^&#x3D; xorv[b];
&#x2F;&#x2F;不要使用maintain，maintain是根据a的两个儿子的数值进行信息合并，而这里需要a b两个节点进行信息合并
		ch[a][0] &#x3D; marge(ch[a][0], ch[b][0]);
		ch[a][1] &#x3D; marge(ch[a][1], ch[b][1]);
		return a;
	&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>顺便说一句，其实<code>trie</code>都可以合并，换句话说，<code>trie</code>合并不仅仅限于<code>01-trie</code>。</p>
<h1 id="code">Code</h1>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">

namespace trie&#123;
    const int _n &#x3D; _ * 25;
    int rt[_];
    int ch[_n][2];
    int w[_n];
    int xorv[_n];
&#x2F;&#x2F; w[i] is in order to save the weight of edge which is connect &#96;i&#96; and its &#96;parent&#96;.
    int tot &#x3D; 0;
    void maintain(int o)&#123;
        w[o] &#x3D; xorv[o] &#x3D; 0;
        if(ch[o][0])&#123; w[o] +&#x3D; w[ch[o][0]]; xorv[o] ^&#x3D;  xorv[ch[o][0]] &lt;&lt; 1; &#125;
        if(ch[o][1])&#123; w[o] +&#x3D; w[ch[o][1]]; xorv[o] ^&#x3D; (xorv[ch[o][1]] &lt;&lt; 1) | (w[ch[o][1]] &amp; 1); &#125;
    &#125;
    inline int mknode()&#123; ++tot; ch[tot][0] &#x3D; ch[tot][1] &#x3D; 0; w[tot] &#x3D; 0; return tot; &#125;
    void insert(int &amp;o, int x, int dp)&#123;
    	if(!o) o &#x3D; mknode();
        if(dp &gt; 20) return (void)(w[o] ++);
&#x2F;&#x2F;        if(dp &#x3D;&#x3D; 0)cerr &lt;&lt; &quot;New start&quot; &lt;&lt; endl;
&#x2F;&#x2F;        cerr &lt;&lt; &quot;inserted &quot; &lt;&lt; (x&amp;1) &lt;&lt; endl;
        insert(ch[o][ x&amp;1 ], x &gt;&gt; 1, dp + 1);
        maintain(o);
&#x2F;&#x2F;		cerr &lt;&lt; w[o] &lt;&lt; endl;
    &#125;
    void erase(int o, int x, int dp)&#123;
        if(dp &gt; 20) return (void )(w[o]--);
        erase(ch[o][ x&amp;1 ], x &gt;&gt; 1, dp + 1);
        maintain(o);
    &#125;
    void addall(int o)&#123;
        swap(ch[o][1], ch[o][0]);
        if(ch[o][0]) addall(ch[o][0]);
        maintain(o);
    &#125;
&#125;

int head[_];
struct edges&#123;
	int node;
	int nxt;
&#125;edge[_ &lt;&lt; 1];
int tot &#x3D; 0;
void add(int u, int v)&#123;
	edge[++tot].nxt &#x3D; head[u];
	head[u] &#x3D; tot;
	edge[tot].node &#x3D; v;
&#125;

int n, m;
int rt;
int lztar[_];
int fa[_];
void dfs0(int o, int f)&#123;
    fa[o] &#x3D; f;
    for(int i &#x3D; head[o];i;i &#x3D; edge[i].nxt)&#123;
        int node &#x3D; edge[i].node;
        if(node &#x3D;&#x3D; f) continue;
        dfs0(node, o);
    &#125;
&#125;
int V[_];
inline int get(int x)&#123; return (fa[x] &#x3D;&#x3D; -1 ? 0 : lztar[fa[x]]) + V[x]; &#125;
int main()
&#123;
#ifdef LOCAL_JUDGE
&#x2F;&#x2F;    freopen(&quot;in.in&quot;, &quot;r&quot;, stdin);
&#x2F;&#x2F;    freopen(&quot;out.txt&quot;, &quot;w&quot;, stdout);
#endif
&#x2F;&#x2F;	freopen(&quot;in.in&quot;, &quot;r&quot;, stdin);
    clock_t c1 &#x3D; clock();

    n &#x3D; read(), m &#x3D; read();
    for(int i &#x3D; 1;i &lt; n;i++)&#123;
        int u &#x3D; read(), v &#x3D; read(); &#x2F;&#x2F;read();
        add(u, v); add(rt &#x3D; v, u);
    &#125;
&#x2F;&#x2F;    show(rt);
    dfs0(rt, -1);
    for(int i &#x3D; 1;i &lt;&#x3D; n;i++) &#123; V[i] &#x3D; read(); if(fa[i] !&#x3D; -1)trie::insert(trie::rt[fa[i]], V[i], 0);  &#125;
&#x2F;&#x2F;    puts(&quot;OK&quot;);
    while(m--)&#123;
        int opt &#x3D; read(), x &#x3D; read(); &#x2F;&#x2F;cerr &lt;&lt; &quot;opt &#x3D; &quot; &lt;&lt; opt &lt;&lt; endl;
&#x2F;&#x2F;        if(get(x) &lt; 0) puts(&quot;data error&quot;);
        if(opt &#x3D;&#x3D; 1)&#123;
            lztar[x] ++; &#x2F;&#x2F;cerr &lt;&lt; &quot;add lztar[ &quot; &lt;&lt; x &lt;&lt; &quot; ]&quot; &lt;&lt; endl;
            if(x !&#x3D; rt) &#123;
            	if(fa[fa[x]])trie::erase(trie::rt[fa[fa[x]]], get(fa[x]), 0);
            	V[fa[x]] ++;
            	if(fa[fa[x]])trie::insert(trie::rt[fa[fa[x]]], get(fa[x]), 0);
			&#125;
            trie::addall(trie::rt[x]);
        &#125; else if(opt &#x3D;&#x3D; 2)&#123;
            int v &#x3D; read();
            if(x !&#x3D; rt) trie::erase(trie::rt[fa[x]], get(x), 0);
            V[x] -&#x3D; v;
            if(x !&#x3D; rt) trie::insert(trie::rt[fa[x]], get(x), 0);
        &#125; else &#123;
            int res &#x3D; 0;
            res &#x3D; trie::xorv[trie::rt[x]];
            res ^&#x3D; get(fa[x]);
            printf(&quot;%d\n&quot;, res);
        &#125;
    &#125;
    std::cerr &lt;&lt; &quot;\n\nTime:  &quot; &lt;&lt; clock() - c1 &lt;&lt; &quot;  ms&quot; &lt;&lt; std::endl;
	return 0;
&#125;
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
]]></content>
      <categories>
        <category>杂题记录</category>
      </categories>
      <tags>
        <tag>trie</tag>
      </tags>
  </entry>
  <entry>
    <title>「杂题记录」「YuGu P6623」「省选联考 2020 A 卷」 树</title>
    <url>//%E3%80%8C%E6%9D%82%E9%A2%98%E8%AE%B0%E5%BD%95%E3%80%8D%E3%80%8CYuGu-P6623%E3%80%8D%E3%80%8C%E7%9C%81%E9%80%89%E8%81%94%E8%80%83-2020-A-%E5%8D%B7%E3%80%8D-%E6%A0%91/</url>
    <content><![CDATA[<div class="note info"><p>给定一棵 <span class="math inline">\(n\)</span> 个结点的有根树 <span class="math inline">\(T\)</span> ，结点从 <span class="math inline">\(1\)</span> 开始编号，根结点为 <span class="math inline">\(1\)</span> 号结点，每个结点有一个正整数权值 <span class="math inline">\(v_i\)</span> 。</p>
<p>设 <span class="math inline">\(x\)</span> 号结点的子树内（包含 <span class="math inline">\(x\)</span> 自身）的所有结点编号为 <span class="math inline">\(c_1,c_2,\dots,c_k\)</span> ，定义 <span class="math inline">\(x\)</span> 的价值为：</p>
<p><span class="math inline">\(val(x)=(v_{c_1}+d(c_1,x)) \oplus (v_{c_2}+d(c_2,x)) \oplus \cdots \oplus (v_{c_k}+d(c_k, x))\)</span> 其中 <span class="math inline">\(d(x,y)\)</span> 。</p>
<p>表示树上 <span class="math inline">\(x\)</span> 号结点与 <span class="math inline">\(y\)</span> 号结点间唯一简单路径所包含的边数， <span class="math inline">\(d(x,x) = 0\)</span> 。 <span class="math inline">\(\oplus\)</span> 表示异或运算。</p>
<p>请你求出 <span class="math inline">\(\sum\limits_{i=1}^n val(i)\)</span> 的结果。</p>
</div>
<a id="more"></a>
<div class="note success"><p>考虑每个结点对其所有祖先的贡献。 每个结点建立 trie，初始先只存这个结点的权值，然后从底向上合并每个儿子结点上的 trie，然后再全局加一，完成后统计答案。</p>
</div>
<h2 id="全局加一维护异或和">全局加一（维护异或和）</h2>
<p>这个不太好表述啊~<br />
<code>01-trie数</code> 是指字符集为 <span class="math inline">\(\{0,1\}\)</span> 的 Trie 树。<br />
<code>01-trie树</code>可以用来维护一堆数字的异或和，支持修改（删除+重新插入），和全部维护值加一。</p>
<p>如果要维护异或和，需要按值从低位到高位建立<code>trie</code>。</p>
<p><strong>一个约定</strong>：文中说当前节点<strong>往上</strong>指当前节点到根这条路径，当前节点<strong>往下</strong>指当前结点的子树。</p>
<h3 id="插入删除">插入&amp;删除</h3>
<p>如果要维护异或和，我们只需要知道某一位上<code>0</code>和<code>1</code>个数的奇偶性即可，也就是对于数字<code>1</code>来说，当且仅当这一位上数字<code>1</code>的个数为奇数时，这一位上的数字才是<code>1</code>。</p>
<p>对于每一个节点，我们需要记录以下三个量： - <code>ch[o][0/1]</code>指节点<code>o</code>的两个儿子，<code>ch[o][0]</code>指下一位是<code>0</code>，同理<code>ch[o][1]</code>指下一位是<code>0</code>。 - <code>w[o]</code>指节点<code>o</code>到其父亲节点这条边上数值的数量（权值）。每插入一个数字<code>x</code>，<code>x</code>二进制拆分后在 <code>trie</code>树上 路径的权值都会<code>+1</code>。 - <code>xorv[o]</code>指以<code>o</code>为根的子树维护的异或和。</p>
<p>具体维护结点的代码如下所示。</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">void maintain(int o)&#123;
		w[o] &#x3D; xorv[o] &#x3D; 0;
		if(ch[o][0])&#123; w[o] +&#x3D; w[ch[o][0]]; xorv[o] ^&#x3D;  xorv[ch[o][0]] &lt;&lt; 1; &#125;
		if(ch[o][1])&#123; w[o] +&#x3D; w[ch[o][1]]; xorv[o] ^&#x3D; (xorv[ch[o][1]] &lt;&lt; 1) | (w[ch[o][1]] &amp; 1); &#125;
		&#x2F;&#x2F;w[o] &#x3D; w[o] &amp; 1;
    	&#x2F;&#x2F;只需知道奇偶性即可，不需要具体的值。当然这句话删掉也可以，因为上文就只利用了他的奇偶性。
	&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>插入和删除的代码非常相似。</p>
<p>需要注意的地方就是：</p>
<ul>
<li><p>这里的<code>MAXH</code>指<code>trie</code>的深度，也就是强制让每一个叶子节点到根的距离为<code>MAXH</code>。对于一些比较小的值，可能有时候不需要建立这么深（例如：如果插入数字<code>4</code>，分解成二进制后为<code>100</code>， 从根开始插入<code>001</code>这三位即可），但是我们强制插入<code>MAXH</code>位。这样做的目的是为了便于全局<code>+1</code>时处理进位。例如：如果原数字是<code>3</code>（<code>11</code>），++之后变成<code>4</code>（<code>100</code>），如果当初插入<code>3</code>时只插入了<code>2</code>位，那这里的进位就没了。</p></li>
<li><p>插入和删除，只需要修改叶子节点的<code>w[]</code>即可，在回溯的过程中一路维护即可。</p></li>
</ul>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">namespace trie&#123;
	const int MAXH &#x3D; 21;
	int ch[_ * (MAXH + 1)][2], w[_ * (MAXH + 1)], xorv[_ * (MAXH + 1)];
	int tot &#x3D; 0;
	int mknode()&#123; ++tot; ch[tot][1] &#x3D; ch[tot][0] &#x3D; w[tot] &#x3D; xorv[tot] &#x3D; 0; return tot;&#125;
	void maintain(int o)&#123;
		w[o] &#x3D; xorv[o] &#x3D; 0;
		if(ch[o][0])&#123; w[o] +&#x3D; w[ch[o][0]]; xorv[o] ^&#x3D;  xorv[ch[o][0]] &lt;&lt; 1; &#125;
		if(ch[o][1])&#123; w[o] +&#x3D; w[ch[o][1]]; xorv[o] ^&#x3D; (xorv[ch[o][1]] &lt;&lt; 1) | (w[ch[o][1]] &amp; 1); &#125;
		w[o] &#x3D; w[o] &amp; 1;
	&#125;
	void insert(int &amp;o, int x, int dp)&#123;
		if(!o) o &#x3D; mknode();
		if(dp &gt; MAXH) return (void)(w[o] ++);
		insert(ch[o][ x&amp;1 ], x &gt;&gt; 1, dp + 1);
		maintain(o);
	&#125;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h3 id="全局加一">全局加一</h3>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">void addall(int o)&#123;
	swap(ch[o][0], ch[o][1]);
	if(ch[o][0]) addall(ch[o][0]);
	maintain(o);
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>不知道你能不能直接看懂呢？</p>
<p>我们思考一下二进制意义下<code>+1</code>是如何操作的。</p>
<p>我们只需要从低位到高位开始找第一个出现的<code>0</code>，把它变成<code>1</code>，然后这个位置后面的<code>1</code>都变成<code>0</code>即可。</p>
<p>下面给出几个例子感受一下。（括号内的数字表示其对应的十进制数字）</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">1000  (10)   + 1 &#x3D; 1001   (11)
10011 (19)   + 1 &#x3D; 10100  (20)
11111 (31)   + 1 &#x3D; 100000 (32)
10101 (21)   + 1 &#x3D; 10110  (22)
100000000111111(16447) + 1 &#x3D; 100000001000000(16448)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>回顾一下<code>w[o]</code>的定义：<code>w[o]</code>指节点<code>o</code>到其父亲节点这条边上数值的数量（权值）。</p>
<p>有没有感觉这个定义有点怪呢？如果在父亲结点存储到两个儿子的这条边的边权也许会更接近于习惯。但是在这里，在交换左右儿子的时候，在儿子结点存储到父亲这条边的距离，显然更加方便。</p>
<h1 id="code">Code</h1>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">

namespace trie&#123;
    const int _n &#x3D; _ * 25;
    int rt[_];
    int ch[_n][2];
    int w[_n];
    int xorv[_n];
&#x2F;&#x2F; w[i] is in order to save the weight of edge which is connect &#96;i&#96; and its &#96;parent&#96;.
    int tot &#x3D; 0;
    void maintain(int o)&#123;
        w[o] &#x3D; xorv[o] &#x3D; 0;
        if(ch[o][0])&#123; w[o] +&#x3D; w[ch[o][0]]; xorv[o] ^&#x3D;  xorv[ch[o][0]] &lt;&lt; 1; &#125;
        if(ch[o][1])&#123; w[o] +&#x3D; w[ch[o][1]]; xorv[o] ^&#x3D; (xorv[ch[o][1]] &lt;&lt; 1) | (w[ch[o][1]] &amp; 1); &#125;
    &#125;
    inline int mknode()&#123; ++tot; ch[tot][0] &#x3D; ch[tot][1] &#x3D; 0; w[tot] &#x3D; 0; return tot; &#125;
    void insert(int &amp;o, int x, int dp)&#123;
    	if(!o) o &#x3D; mknode();
        if(dp &gt; 20) return (void)(w[o] ++);
&#x2F;&#x2F;        if(dp &#x3D;&#x3D; 0)cerr &lt;&lt; &quot;New start&quot; &lt;&lt; endl;
&#x2F;&#x2F;        cerr &lt;&lt; &quot;inserted &quot; &lt;&lt; (x&amp;1) &lt;&lt; endl;
        insert(ch[o][ x&amp;1 ], x &gt;&gt; 1, dp + 1);
        maintain(o);
&#x2F;&#x2F;		cerr &lt;&lt; w[o] &lt;&lt; endl;
    &#125;
    void erase(int o, int x, int dp)&#123;
        if(dp &gt; 20) return (void )(w[o]--);
        erase(ch[o][ x&amp;1 ], x &gt;&gt; 1, dp + 1);
        maintain(o);
    &#125;
    void addall(int o)&#123;
        swap(ch[o][1], ch[o][0]);
        if(ch[o][0]) addall(ch[o][0]);
        maintain(o);
    &#125;
&#125;

int head[_];
struct edges&#123;
	int node;
	int nxt;
&#125;edge[_ &lt;&lt; 1];
int tot &#x3D; 0;
void add(int u, int v)&#123;
	edge[++tot].nxt &#x3D; head[u];
	head[u] &#x3D; tot;
	edge[tot].node &#x3D; v;
&#125;

int n, m;
int rt;
int lztar[_];
int fa[_];
void dfs0(int o, int f)&#123;
    fa[o] &#x3D; f;
    for(int i &#x3D; head[o];i;i &#x3D; edge[i].nxt)&#123;
        int node &#x3D; edge[i].node;
        if(node &#x3D;&#x3D; f) continue;
        dfs0(node, o);
    &#125;
&#125;
int V[_];
inline int get(int x)&#123; return (fa[x] &#x3D;&#x3D; -1 ? 0 : lztar[fa[x]]) + V[x]; &#125;
int main()
&#123;
#ifdef LOCAL_JUDGE
&#x2F;&#x2F;    freopen(&quot;in.in&quot;, &quot;r&quot;, stdin);
&#x2F;&#x2F;    freopen(&quot;out.txt&quot;, &quot;w&quot;, stdout);
#endif
&#x2F;&#x2F;	freopen(&quot;in.in&quot;, &quot;r&quot;, stdin);
    clock_t c1 &#x3D; clock();

    n &#x3D; read(), m &#x3D; read();
    for(int i &#x3D; 1;i &lt; n;i++)&#123;
        int u &#x3D; read(), v &#x3D; read(); &#x2F;&#x2F;read();
        add(u, v); add(rt &#x3D; v, u);
    &#125;
&#x2F;&#x2F;    show(rt);
    dfs0(rt, -1);
    for(int i &#x3D; 1;i &lt;&#x3D; n;i++) &#123; V[i] &#x3D; read(); if(fa[i] !&#x3D; -1)trie::insert(trie::rt[fa[i]], V[i], 0);  &#125;
&#x2F;&#x2F;    puts(&quot;OK&quot;);
    while(m--)&#123;
        int opt &#x3D; read(), x &#x3D; read(); &#x2F;&#x2F;cerr &lt;&lt; &quot;opt &#x3D; &quot; &lt;&lt; opt &lt;&lt; endl;
&#x2F;&#x2F;        if(get(x) &lt; 0) puts(&quot;data error&quot;);
        if(opt &#x3D;&#x3D; 1)&#123;
            lztar[x] ++; &#x2F;&#x2F;cerr &lt;&lt; &quot;add lztar[ &quot; &lt;&lt; x &lt;&lt; &quot; ]&quot; &lt;&lt; endl;
            if(x !&#x3D; rt) &#123;
            	if(fa[fa[x]])trie::erase(trie::rt[fa[fa[x]]], get(fa[x]), 0);
            	V[fa[x]] ++;
            	if(fa[fa[x]])trie::insert(trie::rt[fa[fa[x]]], get(fa[x]), 0);
			&#125;
            trie::addall(trie::rt[x]);
        &#125; else if(opt &#x3D;&#x3D; 2)&#123;
            int v &#x3D; read();
            if(x !&#x3D; rt) trie::erase(trie::rt[fa[x]], get(x), 0);
            V[x] -&#x3D; v;
            if(x !&#x3D; rt) trie::insert(trie::rt[fa[x]], get(x), 0);
        &#125; else &#123;
            int res &#x3D; 0;
            res &#x3D; trie::xorv[trie::rt[x]];
            res ^&#x3D; get(fa[x]);
            printf(&quot;%d\n&quot;, res);
        &#125;
    &#125;
    std::cerr &lt;&lt; &quot;\n\nTime:  &quot; &lt;&lt; clock() - c1 &lt;&lt; &quot;  ms&quot; &lt;&lt; std::endl;
	return 0;
&#125;
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
]]></content>
      <categories>
        <category>杂题记录</category>
      </categories>
      <tags>
        <tag>trie</tag>
      </tags>
  </entry>
  <entry>
    <title>「杂题记录」出题人</title>
    <url>//%E3%80%8C%E6%9D%82%E9%A2%98%E8%AE%B0%E5%BD%95%E3%80%8D%E5%87%BA%E9%A2%98%E4%BA%BA/</url>
    <content><![CDATA[<p>给出长度为 <span class="math inline">\(n\)</span> 的序列 <span class="math inline">\(a_i\)</span> ，需要构造一个序列 <span class="math inline">\(b_i\)</span> ，使得 <span class="math inline">\(\forall i, \exists x,y \in [1, n],s.t.b_x + b_y = a_i\)</span> 要求输出序列 <span class="math inline">\(b_i\)</span> 和方案（<span class="math inline">\(a_i\)</span> 由哪两个 <span class="math inline">\(b_j\)</span> 构成） 。无解输出 <span class="math inline">\(-1\)</span>. d3A</p>
<p><span class="math inline">\(n \le 30\)</span></p>
<a id="more"></a>
<h2 id="分析">分析</h2>
<p>一道搜索<strong>模板题</strong>。</p>
<p>考虑如果能够构造出一个 <span class="math inline">\(a_i\)</span> 的一个子序列 <span class="math inline">\(a&#39;\)</span> 的对应长度的序列 <span class="math inline">\(b&#39;\)</span> 那么每次增加一个元素 <span class="math inline">\(a_k\)</span> 都可以直接构造 <span class="math inline">\(b_k\)</span>。</p>
<p>如果 <span class="math inline">\(a_i\)</span> 存在偶数，可以直接构造 <span class="math inline">\(b_i = \frac{a_i}{2}\)</span> 。其他的元素直接构造即可。</p>
<p>如果 <span class="math inline">\(a_i\)</span> 全部为奇数，考虑将 <span class="math inline">\(b_i\)</span> 中的元素看成点，<span class="math inline">\(a_i\)</span> 看成边，这样就有 <span class="math inline">\(n\)</span> 个点 <span class="math inline">\(n\)</span> 条边，一定存在一个环，只要找到这个环，剩下的元素就可以直接构造了</p>
<p>设：环上一个元素 <span class="math inline">\(b_k\)</span>，那么对于任意一个环外的元素 <span class="math inline">\(i\)</span> ，可以直接构造成 <span class="math inline">\(b_i = a_i - b_k\)</span>。</p>
<p>不妨设 环的大小为 <span class="math inline">\(k\)</span>， <span class="math inline">\(a_i = b_i + b_{i + 1}\)</span>，<span class="math inline">\(a_k = b_k + b_1\)</span> 。则：<span class="math inline">\(\sum_{i=1}^{k}a_i = 2 \sum_{i = 1}^{k}b_i\)</span>，易知： <span class="math inline">\(2 | k\)</span>。</p>
<p>可以直接拆成 <span class="math inline">\(a_1 + a_3 + \cdots+a_{k-1} = \sum_{i = 1}^{k}\limits{b_i}=a_2+a_4+\cdots a_k\)</span></p>
<p>传 统 艺 能 。直接搜索每个点 <span class="math inline">\(a_i\)</span> 是属于上式中的左边、右边 或者 不属于环上的点。要求满足左边的点权和等于右边的点权和。复杂度 <span class="math inline">\(\mathcal{O}(3^n)\)</span>.</p>
<p>考虑把 <span class="math inline">\(a_i\)</span> 拆成两段，分别搜索，记录最终方案，然后线性合并。即：折半搜索。</p>
<p>复杂度 <span class="math inline">\(\mathcal{O}(3^{n/2})\)</span> 。</p>
<p>赛后因为太菜不会线性合并，带了一个 <span class="math inline">\(\log\)</span> 卡成了 30 <del>体验很好</del>。后来写 hash 挂链优化掉了一个 <span class="math inline">\(\log\)</span> ，内存占用 <span class="math inline">\(2\operatorname{GiB}\)</span>，然后人就没了。至今任然 30。</p>
<pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">#include &lt;cstdio&gt;
#include &lt;cstring&gt;
#include &lt;iostream&gt;
#include &lt;algorithm&gt;
#include &lt;cmath&gt;
#include &lt;climits&gt;
#include &lt;map&gt;
#include &lt;vector&gt;
#define GG() return (void)puts(&quot;No&quot;)
using namespace std;
#define LL long long
#define int long long
const int _ &#x3D; 1e2 + 5;
int n, A[_];

namespace subtask0&#123;void work()&#123;
	int target &#x3D; 0;
	for(int i &#x3D; 1; i &lt;&#x3D; n; i++) if(A[i] % 2) ; else &#123; target &#x3D; i; break; &#125;
	cout &lt;&lt; (&quot;Yes&quot;) &lt;&lt; endl;
	for(int i &#x3D; 1; i &lt;&#x3D; n; i++)&#123;
		if(i &#x3D;&#x3D; target) &#123;
			cout &lt;&lt; (A[i] &#x2F; 2) &lt;&lt; &quot; &quot;;
		&#125; else &#123;
			cout &lt;&lt; (A[i] - (A[target] &#x2F; 2)) &lt;&lt; &quot; &quot;;
		&#125;
	&#125; cout &lt;&lt; endl;
	for(int i &#x3D; 1; i &lt;&#x3D; n; i++)&#123;
		if(i &#x3D;&#x3D; target) &#123;
			cout &lt;&lt; target &lt;&lt; &quot; &quot; &lt;&lt; target &lt;&lt; endl;
		&#125; else &#123;
			cout &lt;&lt; target &lt;&lt; &quot; &quot; &lt;&lt; i &lt;&lt; endl;
		&#125;
	&#125;
&#125;&#125;

namespace subtask1&#123;


struct status_t&#123;
	LL S;
	int A0; &#x2F;&#x2F; the sum of.
	int A1; &#x2F;&#x2F; the sum of.
	int sum0; &#x2F;&#x2F; the number of.
	int sum1; &#x2F;&#x2F; the number of.
	status_t() &#123; sum0 &#x3D; sum1 &#x3D; S &#x3D; A0 &#x3D; A1 &#x3D; 0; &#125;
&#125; ;

vector&lt;status_t&gt; reta, retb;

void d( int now, status_t st, const int &amp; ed, vector&lt;status_t&gt; &amp; ret)&#123;
	if(now &gt; ed) &#123;
		ret.push_back(st);
		return ;
	&#125;
	status_t ext;
	ext &#x3D; st; ext.S *&#x3D; 3; ext.S +&#x3D; 0; ext.A0 +&#x3D; A[now]; ext.sum0 ++;
	d(now + 1, ext, ed, ret);

	ext &#x3D; st; ext.S *&#x3D; 3; ext.S +&#x3D; 1; ext.A1 +&#x3D; A[now]; ext.sum1 ++;
	d(now + 1, ext, ed, ret);

	ext &#x3D; st; ext.S *&#x3D; 3; ext.S +&#x3D; 2;
	d(now + 1, ext, ed, ret);
&#125;



map&lt;pair&lt;int, int&gt;, status_t&gt; M;
#define none (-20031006)
int mid;

void output(status_t A, status_t B)&#123;
	vector&lt;int&gt; Node0, Node1, nodes;
	for(int i &#x3D; 0, id &#x3D; mid, tmp &#x3D; A.S;       i &lt; mid; i++, id--, tmp &#x2F;&#x3D; 3) &#123; if(tmp % 3 &#x3D;&#x3D; 0) Node0.push_back(id); if(tmp % 3 &#x3D;&#x3D; 1) Node1.push_back(id); &#125;
	for(int i &#x3D; 0, id &#x3D; n  , tmp &#x3D; B.S; i &lt; (n - mid); i++, id--, tmp &#x2F;&#x3D; 3) &#123; if(tmp % 3 &#x3D;&#x3D; 0) Node0.push_back(id); if(tmp % 3 &#x3D;&#x3D; 1) Node1.push_back(id); &#125;
	for(int i &#x3D; 0; i &lt; (int)Node0.size(); i++) nodes.push_back(Node0[i]), nodes.push_back(Node1[i]);
	static int Ans[_];  for(int i &#x3D; 1; i &lt;&#x3D; n; i++) Ans[i] &#x3D; none;
	static pair&lt;int, int&gt; Out[_];
	Ans[nodes[0]] &#x3D; 0;
	for(int i &#x3D; 0; i &lt; (int)nodes.size(); i++)&#123;
		Ans[nodes[(i + 1) % nodes.size()]] &#x3D; ::A[nodes[i]] - Ans[nodes[i]];
		Out[nodes[i]] &#x3D; make_pair(nodes[i], nodes[(i + 1) % nodes.size()]);
	&#125;
	static vector&lt;int&gt; ext;
	for(int i &#x3D; 1; i &lt;&#x3D; n; i++)&#123; if(Ans[i] !&#x3D; none) continue;
		Ans[i] &#x3D; ::A[i];
		Out[i] &#x3D; make_pair(nodes[0], i);
	&#125;
	cout &lt;&lt; (&quot;Yes&quot;) &lt;&lt; endl;
	for(int i &#x3D; 1; i &lt;&#x3D; n; i++) cout &lt;&lt; Ans[i] &lt;&lt; &quot; &quot;; cout &lt;&lt; endl;
	for(int i &#x3D; 1; i &lt;&#x3D; n; i++) cout &lt;&lt; Out[i].first &lt;&lt; &quot; &quot; &lt;&lt; Out[i].second &lt;&lt; endl;
&#125;


void work()&#123;
	mid &#x3D; (n &gt;&gt; 1);
	reta.clear(); retb.clear();
	d(1, status_t(), mid, reta);
	d(mid + 1, status_t(), n, retb);
	if(reta.size() &#x3D;&#x3D; 0 || retb.size() &#x3D;&#x3D; 0) GG();
	for(int i &#x3D; 0; i &lt; (int)reta.size(); i++) &#123; pair&lt;int, int&gt; Key; Key &#x3D; make_pair(reta[i].sum0 - reta[i].sum1, reta[i].A0 - reta[i].A1); M[Key] &#x3D; reta[i]; &#125;
	for(int i &#x3D; 0; i &lt; (int)retb.size(); i++) &#123;
		pair&lt;int, int&gt; Key; Key &#x3D; make_pair(retb[i].sum1 - retb[i].sum0, retb[i].A1 - retb[i].A0);
		if(M.count(Key)) ; else continue;
		status_t A &#x3D; M[Key], B &#x3D; retb[i];
		if(A.sum0 + A.sum1 &#x3D;&#x3D; 0 || B.sum0 + B.sum1 &#x3D;&#x3D; 0) continue;
		if((A.sum0 + B.sum0 + A.sum1 + B.sum1) % 2) ;
		else return output(A, B);
	&#125;
	GG();
&#125; &#125;
signed main()&#123;
	&#x2F;&#x2F; freopen(&quot;.in&quot;, &quot;r&quot;, stdin);
	ios::sync_with_stdio(false);
	cin &gt;&gt; n; for(int i &#x3D; 1; i &lt;&#x3D; n; i++) cin &gt;&gt; A[i];
	int pass &#x3D; false;
	for(int i &#x3D; 1; i &lt;&#x3D; n; i++) if(A[i] % 2) ; else &#123; pass &#x3D; true; break; &#125;
	if(pass) subtask0::work();
	else subtask1::work();
	return 0;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
]]></content>
      <categories>
        <category>杂题记录</category>
      </categories>
      <tags>
        <tag>搜索</tag>
        <tag>双向搜索</tag>
      </tags>
  </entry>
  <entry>
    <title>「杂题记录」彩色挂饰</title>
    <url>//%E3%80%8C%E6%9D%82%E9%A2%98%E8%AE%B0%E5%BD%95%E3%80%8D%E5%BD%A9%E8%89%B2%E6%8C%82%E9%A5%B0/</url>
    <content><![CDATA[<p>一道 dp + 图论 + 状压好题</p>
<a id="more"></a>
<h1 id="杂题记录彩色挂饰">「杂题记录」彩色挂饰</h1>
<h2 id="题意简述">题意简述</h2>
<p>给定一张 <span class="math inline">\(n\)</span> 个点 <span class="math inline">\(m\)</span> 条边的无向图，有一些点有颜色，定义颜色相同的点组成的连通块为同色连通块。需要对没有颜色的点进行染色，最小化同色连通块的数量。</p>
<p>无向图满足每个点双的大小 <span class="math inline">\(\le s\)</span> ，给出的颜色分别从为 <span class="math inline">\(1\)</span> 到 <span class="math inline">\(k\)</span> 编号。</p>
<p><span class="math inline">\(n\le 10^5, 2&lt;k\le 20,s\le 6, n-1\le m &lt; ns\)</span></p>
<p>对于 <span class="math inline">\(10\)</span> % 的数据，<span class="math inline">\(s = 2\)</span>.</p>
<h2 id="分析">分析</h2>
<p><span class="math inline">\(s=2\)</span> 是一档很有启发性的部分分，可以感受到这就是一个树。</p>
<p>不妨设根节点编号为 <span class="math inline">\(1\)</span> 直接树形 dp，设 <span class="math inline">\(f(u, c)\)</span> 为把以 <span class="math inline">\(u\)</span> 为根节点的子树，<span class="math inline">\(u\)</span> 染成颜色 <span class="math inline">\(c\)</span> ，其余的任意染，最小的同色连通块数量。 <span class="math display">\[
f(u, c) =1+\sum_{(u, v) \in E}\left(f(v, c) - 1\right)
\]</span> 一个图怎么做？考虑用圆方树将无向图转化为树，然后进行树形 dp。 <span class="math inline">\(f(u, c)\)</span> 的定义转化为以 <span class="math inline">\(u\)</span> 为根的子树，<strong>圆点</strong> 或 <strong>方点的父亲</strong>染成的颜色。感觉是一类圆方树上 dp 的标准套路。 对于圆点： <span class="math display">\[
f(u, c) =1+\sum_{(u, v) \in E}\left(f(v, c) - 1\right)
\]</span> 对于方点: <strong>简单dp</strong> 一下就可以了。 注意到 <span class="math inline">\(s\le 6\)</span> ，瞎搞一下就可以了。注意以下的集合均指每个将一个点双上的点编号离散后的编号点集。</p>
<p>设：定义在点上的函数 <span class="math inline">\(A(x)\)</span> 为与 <span class="math inline">\(x\)</span> 相连的点集。</p>
<p>设：定义在集合上的函数 <span class="math inline">\(C(S)\)</span> ，表示点集 <span class="math inline">\(S\)</span> 是否连通。 <span class="math display">\[
\begin{split}
C(\varnothing) &amp;= 1\\
C(S) &amp;= \or_{x\in S}(C(S / \{x\}) \operatorname{AND}(A(x) \cap S \not = \varnothing))
\end{split}
\]</span></p>
<p>设：函数 <span class="math inline">\(G(S, c)\)</span> 为将连通块 <span class="math inline">\(S\)</span> 涂成 <span class="math inline">\(c\)</span> ，最小代价。每个连通块对应的子树也算入答案。 <span class="math display">\[
G(S, c)=
\begin{cases}
\operatorname{INF}, &amp; C(S)=0 \\
1+\sum_{x\in S}\limits{(f(x, c)-1)}
\end{cases}
\]</span> 设：函数<span class="math inline">\(H(S)\)</span> 为将连通块 <span class="math inline">\(S\)</span> 涂上任意一种相同的颜色，最小代价。 <span class="math display">\[
H(S) = \min_{c=1}^{k}\limits{G(S, c)}.
\]</span> 设：函数 <span class="math inline">\(L(S)\)</span> 为将连通块 <span class="math inline">\(S\)</span> 切成若干块，每一块涂上相同的颜色，最小代价。 <span class="math display">\[
L(S) = \min\{H(S),\ \min_{s \subseteq S} L(s)+L(S / s)\}
\]</span> 就可以求出 <span class="math display">\[
f(u, c)= \min_{S, u \in S}\limits{G(S, c) + L(S_{补})}
\]</span> 转移只需要 80 行就写完了。</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">#include &lt;cstdio&gt;
#include &lt;cstring&gt;
#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;algorithm&gt;
#include &lt;stack&gt;
#include &lt;cassert&gt;
#include &lt;set&gt;

using namespace std;

const int _ &#x3D; 4e5 + 100;
const int _K &#x3D; 30;

int Col[_];
int n, m, k, s;
int head[_];
struct edges&#123; int node, nxt; &#125; edge[_ &lt;&lt; 1]; int tot &#x3D; 0;
void add(int u, int v)&#123; tot++; edge[tot].node &#x3D; v; edge[tot].nxt  &#x3D; head[u]; head[u] &#x3D; tot; &#125;

vector&lt;int&gt; G[_];
set&lt;int&gt; GG[_];

int dfn[_], low[_], dfc &#x3D; 0, tmp;
int cnt;
stack&lt;int&gt; S;
void tarjan(int now) &#123;
	dfn[now] &#x3D; low[now] &#x3D; ++dfc; S.push(now);
	for(int i &#x3D; 0; i &lt; (int)G[now].size(); i++) &#123;
		int ex &#x3D; G[now][i];
		if(!dfn[ex]) &#123;
			tarjan(ex);
			low[now] &#x3D; min(low[now], low[ex]);
			if(dfn[now] &#x3D;&#x3D; low[ex]) &#123;
				++cnt;
				add(now, cnt); add(cnt, now);
				do add(cnt, tmp &#x3D; S.top()), add(tmp, cnt), S.pop(); while(tmp !&#x3D; ex);
			&#125;
		&#125; else low[now] &#x3D; min(low[now], dfn[ex]);
	&#125;
&#125;
int popcnt(int S) &#123; int ans &#x3D; 0; while(S) ans +&#x3D; ((S &amp; 1) !&#x3D; 0), S &gt;&gt;&#x3D; 1; return S;  &#125;
int F[_][_K];
const int _S &#x3D; 15;
int ver &#x3D; 0;
int _INT_MAX_;
void d(int now, int fa)&#123;
	for(int i &#x3D; head[now]; i; i &#x3D; edge[i].nxt) &#123;
		int ex &#x3D; edge[i].node; if(ex &#x3D;&#x3D; fa) continue;
		d(ex, now);
	&#125;
	if(now &lt;&#x3D; n) &#123;
		for(int i &#x3D; 1; i &lt;&#x3D; k; i++) &#123;
			if(Col[now]) if(Col[now] !&#x3D; i) &#123; F[now][i] &#x3D; _INT_MAX_; continue; &#125;
			int &amp;ans &#x3D; F[now][i] &#x3D; 1;
			for(int j &#x3D; head[now]; j; j &#x3D; edge[j].nxt) &#123;
				if(edge[j].node &#x3D;&#x3D; fa) continue;
				ans +&#x3D; F[edge[j].node][i] - 1;
			&#125;
		&#125;
	&#125; else &#123;
		static int Link[_S], iLink[_], NodeCnt; NodeCnt &#x3D; 0;
		for(int i &#x3D; head[now]; i; i &#x3D; edge[i].nxt) &#123;
			int ex &#x3D; edge[i].node;
			Link[++NodeCnt] &#x3D; ex;
			iLink[ex] &#x3D; NodeCnt;
		&#125;
		static int A[_S]; static bool C[1 &lt;&lt; _S];
		for(int i &#x3D; 1; i &lt;&#x3D; NodeCnt; i++) &#123;
			int &amp;ans &#x3D; A[i] &#x3D; 0;
			for(int j &#x3D; 1; j &lt;&#x3D; NodeCnt; j++)&#123; if(i &#x3D;&#x3D; j) continue;
				int ex &#x3D; Link[j]; if(GG[Link[i]].find(ex) &#x3D;&#x3D; GG[Link[i]].end()) continue;
				ans |&#x3D; (1 &lt;&lt; (j - 1));
			&#125;
		&#125;
		for(int i &#x3D; 0; i &lt; (1 &lt;&lt; NodeCnt); i++) C[i] &#x3D; 0;
		C[0] &#x3D; 1; &#x2F;&#x2F; C[S] 重标号后的点集 S 是否连通.
		for(int i &#x3D; 1; i &lt;&#x3D; NodeCnt; i++) C[1 &lt;&lt; (i - 1)] &#x3D; 1;
		for(int i &#x3D; 1; i &lt; (1 &lt;&lt; NodeCnt); i++)&#123;
			bool &amp;ans &#x3D; C[i];
			for(int j &#x3D; 1; j &lt;&#x3D; NodeCnt; j++)&#123;
				if(i &amp; (1 &lt;&lt; (j - 1))) ; else continue;
				ans &#x3D; ( ans || (C[i ^ (1 &lt;&lt; (j - 1))] &amp;&amp; ((A[j] &amp; i) !&#x3D; 0)) );
			&#125;
		&#125;
		static int G[1 &lt;&lt; _S][_K]; &#x2F;&#x2F; G[S][c] 把联通块 S 涂上颜色 c. 需要的次数.
		for(int i &#x3D; 1; i &lt; (1 &lt;&lt; NodeCnt); i++)&#123;
			for(int j &#x3D; 1; j &lt;&#x3D; k; j++)&#123;
				int &amp;ans &#x3D; G[i][j];
				if(!C[i]) &#123; ans &#x3D; _INT_MAX_; continue; &#125;
				ans &#x3D; 1;
				for(int l &#x3D; 1; l &lt;&#x3D; NodeCnt; l++)&#123;
					if(i &amp; (1 &lt;&lt; (l - 1))) if(l !&#x3D; iLink[fa]) ans +&#x3D; F[Link[l]][j] - 1;&#x2F;&#x2F; , assert(F[Link[l]][j] &gt; 0);
				&#125;
			&#125;
		&#125;
		static int H[1 &lt;&lt; _S]; &#x2F;&#x2F; H[S] 把 连通块 S 涂上同一种颜色 所需要的 最小代价。
		H[0] &#x3D; 0;
		for(int i &#x3D; 1; i &lt; (1 &lt;&lt; NodeCnt); i++)&#123;
			int &amp;ans &#x3D; H[i] &#x3D; _INT_MAX_;
			for(int j &#x3D; 1; j &lt;&#x3D; k; j++) ans &#x3D; min(ans, G[i][j]);
		&#125;
		static int L[1 &lt;&lt; _S]; L[0] &#x3D; 0; &#x2F;&#x2F; L[S] 把 连通块 S 分成若干块，每一块分别涂上相同的颜色 最小代价。
		for(int i &#x3D; 1; i &lt; (1 &lt;&lt; NodeCnt); i++)&#123;
			int &amp;ans &#x3D; L[i] &#x3D; H[i];
			for(int S0 &#x3D; i; S0; S0 &#x3D; (S0 - 1) &amp; i)&#123;
				ans &#x3D; min(ans, L[S0] + L[i ^ S0]);
			&#125;
		&#125;
		for(int i &#x3D; 1; i &lt;&#x3D; k; i++)&#123;
			int &amp;ans &#x3D; F[now][i] &#x3D; _INT_MAX_;
			if(Col[fa]) if(Col[fa] !&#x3D; i) continue;
			int S &#x3D; (1 &lt;&lt; (NodeCnt)) - 1; S ^&#x3D; (1 &lt;&lt; (iLink[fa] - 1));
			ans &#x3D; min(ans, G[(1 &lt;&lt; (iLink[fa] - 1))][i] + L[S]);
			for(int j &#x3D; S; j ; j &#x3D; (j - 1) &amp; S)&#123;
				ans &#x3D; min(ans, G[j | (1 &lt;&lt; (iLink[fa] - 1))][i] + L[S ^ j]);
			&#125;
		&#125;
	&#125;
&#125;

int main()&#123;
	&#x2F;&#x2F; freopen(&quot;in.txt&quot;, &quot;r&quot;, stdin);
	ios::sync_with_stdio(false);
	cin &gt;&gt; n &gt;&gt; m &gt;&gt; k &gt;&gt; s; cnt &#x3D; n; _INT_MAX_ &#x3D; 3 * n;
	for(int i &#x3D; 1; i &lt;&#x3D; n; i++) cin &gt;&gt; Col[i];
	for(int i &#x3D; 1; i &lt;&#x3D; m; i++)&#123;
		int u, v; cin &gt;&gt; u &gt;&gt; v;
		G[u].push_back(v); GG[u].insert(v);
		G[v].push_back(u); GG[v].insert(u);
	&#125;
	tarjan(1);
	d(1, 1);
	int ans &#x3D; _INT_MAX_;
	for(int i &#x3D; 1; i &lt;&#x3D; k; i++) ans &#x3D; min(ans, F[1][i]);
	printf(&quot;%d&quot;, ans);
	return 0;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
]]></content>
      <categories>
        <category>杂题记录</category>
      </categories>
      <tags>
        <tag>dp</tag>
        <tag>园方树</tag>
      </tags>
  </entry>
  <entry>
    <title>「杂题记录」括号序列（格路计数）</title>
    <url>//%E3%80%8C%E6%9D%82%E9%A2%98%E8%AE%B0%E5%BD%95%E3%80%8D%E6%8B%AC%E5%8F%B7%E5%BA%8F%E5%88%97%EF%BC%88%E6%A0%BC%E8%B7%AF%E8%AE%A1%E6%95%B0%EF%BC%89/</url>
    <content><![CDATA[<p>给出两个正整数 <span class="math inline">\(n, k\)</span> 。</p>
<p>求出有多少个长度为 <span class="math inline">\(n\)</span> 的括号序列，满足最长合法括号子序列长度恰好为 <span class="math inline">\(2k\)</span> 。 <a id="more"></a></p>
<h2 id="分析">分析</h2>
<p>根据<a href="./「琐记」卡特兰数">卡特兰数的转化</a>同样可以对这个问题进行转化。</p>
<p>可以发现如果前缀和为 <span class="math inline">\(S_i\)</span> ，那么最长的合法括号子序列长度为 <span class="math inline">\(n-S_n + 2\min\{S\}\)</span>，注意 <span class="math inline">\(min\{S\}\)</span>通常为负值。</p>
<figure>
<img src="https://i.loli.net/2021/01/27/7Bt4EbCKUVjGYgH.png" alt="example.png" /><figcaption>example.png</figcaption>
</figure>
<p>其中红色的线段为无效符号，E 为最低点。</p>
<p>设 <span class="math inline">\(t=\min\{S\}\)</span>，易知 <span class="math inline">\(S_n = n+2t+2k\)</span>。</p>
<p>可以考虑枚举 <span class="math inline">\(t\)</span> ，问题就变成了格路计数，需要满足一定到达过 <span class="math inline">\(y=t\)</span> 这个直线，且未曾穿过。</p>
<p>未曾穿过的限制可以考虑用<a href="./「琐记」卡特兰数">卡特兰数的推导</a>相同的思想，即翻折引理。</p>
<p>到达过这条线的要求可以考虑用 <span class="math inline">\(\min\{S\} \ge t\)</span> 的答案减去 <span class="math inline">\(\min\{S\} &gt; t\)</span> 的答案得到。</p>
<p>考虑不经过 <span class="math inline">\(y=t-1\)</span> 时的答案：（根据翻折引理） <span class="math display">\[
\dbinom{n}{(n-S_n)/2}-\dbinom{n}{\left[n - (2(t-1)-S_n)\right]/2}=\dbinom{n}{k-t}-\dbinom{n}{k-1}
\]</span> 同理，不经过 <span class="math inline">\(y=t\)</span> 的答案为： <span class="math display">\[
\dbinom{n}{k-t}-\dbinom{n}{k}
\]</span></p>
<p>做差发现是： <span class="math display">\[
\dbinom{n}{k-1}-\dbinom{n}{k}
\]</span> 有不等式 <span class="math inline">\(S_n \ge \min\{S\}\)</span>，易知：<span class="math inline">\(t \ge 2k-n\)</span>.即 <span class="math inline">\(k\)</span> 有 <span class="math inline">\(n-2k+1\)</span> 种取值。</p>
<p>答案为： <span class="math inline">\((n+1-2k)\left(\dbinom{n}{k}-\dbinom{n}{k-1}\right)\)</span></p>
<p>这应该就能做到线性了，如果有个小巧的质数就能做到更快了。</p>
]]></content>
      <categories>
        <category>杂题记录</category>
      </categories>
      <tags>
        <tag>数学</tag>
        <tag>卡特兰数</tag>
        <tag>组合数学</tag>
      </tags>
  </entry>
  <entry>
    <title>「比赛总结」 正睿 国庆</title>
    <url>//%E3%80%8C%E6%AF%94%E8%B5%9B%E6%80%BB%E7%BB%93%E3%80%8D-%E6%AD%A3%E7%9D%BF-%E5%9B%BD%E5%BA%86/</url>
    <content><![CDATA[<p><a href="http://zhengruioi.com/contest/766/problem/394">link</a> <div class="note info"><p>给出一个长度为 <span class="math inline">\(n\)</span> 的 <code>01</code> 串 <span class="math inline">\(s\)</span> 和整数 <span class="math inline">\(k\)</span> ，求一个 <span class="math inline">\(s\)</span> 最长的子串 <span class="math inline">\(t\)</span> 使得 <span class="math inline">\(t\)</span> 中 <code>0</code> 的个数是 <code>1</code> 的个数的 <span class="math inline">\(k\)</span> 倍，输出最长的 <span class="math inline">\(t\)</span> 的长度。</p>
</div> <a id="more"></a> <div class="note success"><p>设$ S_0[i]$ 表示 <span class="math inline">\(S[1..i]\)</span>中 <code>0</code>的数量。 <span class="math inline">\(S_1[i]\)</span> 表示 <span class="math inline">\(S[1..i]\)</span>中 <code>1</code>的数量。 字串 <span class="math inline">\(S[L, R]\)</span> 满足条件当且仅当 <span class="math inline">\(S_0[R] - S_0[L - 1] = (S_1[R] - S_1[L - 1]) \times k\)</span>。 即：<span class="math inline">\(S_0[R] - S_1[R] \times k = S_0[L - 1] - S_1[L - 1] \times k\)</span>。</p>
</div> <pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">#define i64 long long
const int _ &#x3D; 1e6 + 100;
int n, k;
char S[_];
int S0[_], S1[_];
map&lt;long long, int &gt;M;
int main()&#123;
	ios::sync_with_stdio(false);
	cin &gt;&gt; n &gt;&gt; k &gt;&gt; (S + 1);
	for(int i &#x3D; 1; i &lt;&#x3D; n; i++) S0[i] &#x3D; S0[i - 1] + (S[i] &#x3D;&#x3D; &#39;0&#39;), S1[i] &#x3D; S1[i - 1] + (S[i] &#x3D;&#x3D; &#39;1&#39;);
	int ans &#x3D; 0;
	M[0] &#x3D; 0;
	for(int i &#x3D; 1; i &lt;&#x3D; n; i++)&#123;
		i64 now &#x3D; S0[i] -0ll- k *1ll* S1[i];
		if(M.count(now)) ans &#x3D; max(ans, i - M[now]);  else M[now] &#x3D; i;
	&#125;
	printf(&quot;%d\n&quot;, ans); cerr &lt;&lt; &quot;std&#39;s ans &#x3D; &quot; &lt;&lt; ans &lt;&lt; endl;
	return 0;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></p>
<div class="note info"><p>有两个长度为 <span class="math inline">\(n\)</span> 的排列 <span class="math inline">\(A,B\)</span> ，你每次可以进行三种操作： - 删除 <span class="math inline">\(A\)</span> 的第一个元素 <span class="math inline">\(a\)</span> - 删除 <span class="math inline">\(B\)</span> 的第一个元素 <span class="math inline">\(b\)</span> - 删除 <span class="math inline">\(A\)</span> 的第一个元素 <span class="math inline">\(a\)</span> 和 <span class="math inline">\(B\)</span> 的第一个元素 <span class="math inline">\(b\)</span> ，要求 <span class="math inline">\(a\neq b\)</span> 求把 <span class="math inline">\(A,B\)</span> 都删光需要的最少操作次数。</p>
<p><span class="math inline">\(n \le 10^6\)</span></p>
</div>
<!-- more -->
<div class="note success"><p>当数列 <span class="math inline">\(A, B\)</span> 的首项相同的时候，直接贪心的选择操作 3 。需要决策当 <span class="math inline">\(A, B\)</span> 首项相同的时候选择删除那边的，然后又可以一直删，直到首项再次相同的时候 再决策，直接DP可能被<strong>卡住</strong>的地方即可。</p>
<p>设数字 <span class="math inline">\(x\)</span> 在 <span class="math inline">\(A\)</span> 中的位置是 <span class="math inline">\(i\)</span>，在 <span class="math inline">\(B\)</span> 中的位置是 <span class="math inline">\(j\)</span>，记 数字 <span class="math inline">\(x\)</span> 的位置为二元组 <span class="math inline">\((i, j)\)</span>。由于 <span class="math inline">\(A , B\)</span> 是两个排列，对于数字 <span class="math inline">\(x\)</span> ，其位置一定是唯一的 <span class="math inline">\((i, j)\)</span>。 设 <span class="math inline">\(\operatorname{dp}[i]\)</span> 为 (设 <span class="math inline">\(A_i\)</span> 的位置为 <span class="math inline">\((i, j)\)</span> ) ，删光 <span class="math inline">\(A[i..n]\)</span> 和 <span class="math inline">\(B[j..n]\)</span> 的代价。</p>
<p>对于数值 <span class="math inline">\(x\)</span> 的位置 <span class="math inline">\((i, j)\)</span> 设 $= i - j <span class="math inline">\(。由于排列的性质，\)</span>dp[i]<span class="math inline">\(、\)</span>A_i$ 的位置 <span class="math inline">\((i, j)\)</span>这些是一一对应的。设 <span class="math inline">\(\Delta(x)\)</span> 为 <span class="math inline">\(dp[x]\)</span> 对应的 <span class="math inline">\(\Delta\)</span>。</p>
<p>转移就是</p>
<p><span class="math inline">\(dp[i] = 1 + \min_{\Delta(x) = \Delta(i) - 1, \Delta(y) = \Delta(i) + 1}\limits{\{\ dp[x] + \operatorname{dist}(i, x),\ \ dp[y] + \operatorname{dist}(i, y)}\ \}\)</span>。</p>
<p>从后往前 <span class="math inline">\(dp\)</span> 记录以下 <span class="math inline">\(\Delta\)</span> 即可。 为了方便，其中 <span class="math inline">\(\operatorname{Last}\)</span> 为 <span class="math inline">\(\Delta()\)</span> 的反函数。</p>
</div>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">int n, A[_], B[_], POOL[(_ &lt;&lt; 1) + 100], PosInB[_], *Last &#x3D; &amp;POOL[_ + 10];
int dp[_];
int main()&#123;
    rep(i, 1, n &#x3D; read()) Read(A[i]); rep(i, 1, n) Read(B[i]), PosInB[B[i]] &#x3D; i;
    clear(dp, 0x3f); clear(POOL, -1);
    per(i, 1, n) &#123;
        int det &#x3D; i - PosInB[A[i]];
        if(Last[det + 1] !&#x3D; -1) to_min(dp[i], dp[Last[det + 1]] + 1 + (Last[det + 1] - (i + 1)));
        else to_min(dp[i], 1 + max(n - (i + 1) + 1, n - (PosInB[A[i]]) + 1 ));
        if(Last[det - 1] !&#x3D; -1) to_min(dp[i], dp[Last[det - 1]] + 1 + (Last[det - 1] - (i)));
        else to_min(dp[i], 1 + max(n - (i) + 1, n - (PosInB[A[i]] + 1) + 1));
        Last[det] &#x3D; i;
    &#125;
    int ans &#x3D; 0;
    if(Last[0] &#x3D;&#x3D; -1) ans &#x3D; n; else ans &#x3D; dp[Last[0]] + Last[0] - 1;
    printf(&quot;%d&quot;, ans);
    return 0;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<div class="note info"><p>对于长度为 <span class="math inline">\(n\)</span> 的置换 <span class="math inline">\(A,B\)</span> ，求是否存在正整数 <span class="math inline">\(k\)</span> 使得 <span class="math inline">\(A^k=B\)</span></p>
<p>定义置换的乘法为 <span class="math inline">\(C = (A \cdot B), C_i=A_{B_i}\)</span></p>
<p>定义 <span class="math inline">\(A^1=A,A^n=A^{n-1} \cdot A(n &gt; 1)\)</span></p>
<p>如果存在 <code>k</code> 输出 <code>Yes</code> 否则输出 <code>No</code> 。</p>
<p><span class="math inline">\(n \le 10^6\)</span></p>
</div>
<!-- more -->
<div class="note success"><p>可以转化为对线性同于方程判断是否有解的问题。</p>
<p>这里的线性同于方程组的模数 <span class="math inline">\(\le 10^6\)</span> 且不互质，<span class="math inline">\(LCM\)</span> 很大 无法 <span class="math inline">\(exCRT\)</span> 合并。</p>
<p><span class="math inline">\(O(n \operatorname{log} n)\)</span>： 从 <span class="math inline">\(1 ~ n\)</span> 枚举 <span class="math inline">\(i\)</span> 尝试求出 <span class="math inline">\(x \operatorname{mod} i\)</span> 的数值，易知 这个值可以从 <span class="math inline">\(x \operatorname{mod} k \dot i\)</span> 的值得到，检查方程组中所有的方程，看看是否冲突即可。根据调和级数，这样做的时间复杂度为 <span class="math inline">\(O(n \operatorname{log} n)\)</span>。</p>
</div>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">#define i64 long long
#define walk(now, ex) for(int i &#x3D; head[now], ex; ex &#x3D; edge[i].node, i; i &#x3D; edge[i].nxt)
bool vis[_];
vector&lt;int&gt; G[_];
int D[_], SZ[_], BL[_];
int Dis[_], MD[_];
int cnt &#x3D; 0;
void clear()&#123;
	memset(head, 0, sizeof(head)); tot &#x3D; 0;
	memset(vis, false, sizeof(vis));
	for(int i &#x3D; 1; i &lt;&#x3D; cnt; i++) G[i].clear(); cnt &#x3D; 0;
&#125;
void dfs(int now, int target)&#123;
	G[target].push_back(now);  vis[now] &#x3D; 1;
	walk(now, ex) &#123; if(vis[ex]) continue; dfs(ex, target); &#125;
&#125;
bool CMP(const pair&lt;int, int &gt; &amp; A, const pair&lt;int, int &gt; &amp; B) &#123; return A.fi &lt; B.fi; &#125;
int pos[_];
bool PdExist(int *Md, int *a, int n) &#123;
	static vector&lt; pair&lt;int, int &gt; &gt; M, M0; M.clear(); M0.clear();
	for(int i &#x3D; 1; i &lt;&#x3D; n; i++) M.push_back(make_pair(Md[i], a[i]));
	sort(M.begin(), M.end(), CMP);
	for(int i &#x3D; 0; i &lt; M.size(); i++) &#123;
		int L &#x3D; i, R &#x3D; i;
		while(R + 1 &lt; M.size() &amp;&amp; M[L].fi &#x3D;&#x3D; M[R + 1].fi) R++;
		for(int j &#x3D; L; j &lt;&#x3D; R; j++) if(M[j].se !&#x3D; M[L].se) return false;
		M0.push_back(M[L]);
		i &#x3D; R;
	&#125;
	memset(pos, -1, sizeof(pos));
	int MAX &#x3D; 0; for(int i &#x3D; 0; i &lt; M0.size(); i++) MAX &#x3D; max(MAX, M0[i].fi), pos[M0[i].fi] &#x3D; i;
	for(int i &#x3D; 1; i &lt;&#x3D; MAX; i++)&#123;
		int tmp &#x3D; -1;
		for(int j &#x3D; i; j &lt;&#x3D; MAX; j +&#x3D; i) if(pos[j] !&#x3D; -1) &#123; if(tmp &#x3D;&#x3D; -1) tmp &#x3D; M0[pos[j]].se % i; else if(tmp !&#x3D; M0[pos[j]].se % i) return false; &#125;
	&#125;
	return true;
&#125;

void doit()&#123;
	clear();
	for(int i &#x3D; 1; i &lt;&#x3D; n; i++) add(A[i], i);
	for(int i &#x3D; 1; i &lt;&#x3D; n; i++) if(!vis[i]) dfs(i, ++cnt);
	for(int i &#x3D; 1; i &lt;&#x3D; cnt; i++) &#123;
		for(int j &#x3D; 0; j &lt; G[i].size(); j++)&#123;
			D[G[i][j]] &#x3D; j;
			SZ[G[i][j]] &#x3D; G[i].size();
			BL[G[i][j]] &#x3D; i;
		&#125;
	&#125;
	for(int i &#x3D; 1; i &lt;&#x3D; n; i++) if(BL[A[i]] !&#x3D; BL[B[i]]) &#123; return (void)puts(&quot;No&quot;);&#125;
	for(int i &#x3D; 1; i &lt;&#x3D; n; i++) Dis[i] &#x3D; ( D[B[i]] - D[A[i]] + SZ[A[i]] ) % SZ[A[i]];

	for(int i &#x3D; 1; i &lt;&#x3D; n; i++) MD[i] &#x3D; SZ[A[i]];
	int r &#x3D; PdExist(MD, Dis, n);
	return (void)puts(r ? &quot;Yes&quot; : &quot;No&quot;);
&#125;

int main()&#123;
	while(scanf(&quot;%d&quot;, &amp;n) &#x3D;&#x3D; 1)&#123;
		for(int i &#x3D; 1; i &lt;&#x3D; n; i++) Read(A[i]);
		for(int i &#x3D; 1; i &lt;&#x3D; n; i++) Read(B[i]);
		doit();
	&#125;
	return 0;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
]]></content>
      <categories>
        <category>杂题记录</category>
      </categories>
      <tags>
        <tag>题解</tag>
        <tag>正睿</tag>
      </tags>
  </entry>
  <entry>
    <title>「CSP 2020」退役有感</title>
    <url>//%E3%80%8C%E6%AF%94%E8%B5%9B%E6%80%BB%E7%BB%93%E3%80%8D%E3%80%8CCSP-2020%E3%80%8D%E9%80%80%E5%BD%B9%E6%9C%89%E6%84%9F/</url>
    <content><![CDATA[<p>CSP 2020 联赛</p>
<p>退役有感。 <a id="more"></a> # 比赛经历 ## A 开场看到题目就知道这道题可能会浪费我很长时间，但是这是第一题，如果简单题没有做出来，排名肯定不理想了。 主要是不知道后面题目的难度，而且这道题显然是一道不需要动脑子的题目，所以树立了无论如何都要把这道题拿满分的观念。（也许是对的，但是可能结果不尽人意）</p>
<p>首先这道题一定是一个模拟题，放在第一题的位置，而且题目流程相对复杂，没有考虑时间复杂度上的问题，感觉是模拟整个过程就完全可以通过，就直接上手开始写的。</p>
<p>一开始没有完整的思路，就是想到哪里写道哪里，没有仔细思考怎么做比较好写，浪费了很多时间。一直没有注意部分分，写起来比较迷茫。大约到了 <span class="math inline">\(1\)</span> 小时左右注意到了部分分，发现如果 <span class="math inline">\(\operatorname{O}(n)\)</span> 预处理 + <span class="math inline">\(\operatorname{O}(1)\)</span> 询问。就有 <span class="math inline">\(80pts\)</span> 这一部分大概只需要 <span class="math inline">\(5\)</span> 分钟就可以写完，然后注释掉之前写的垃圾，<span class="math inline">\(5\)</span> 分钟写完了 <span class="math inline">\(\operatorname{O}(n)\)</span> 做法。还是没看后面的题目，坚持着第一题必须拿满分的信念，继续做剩下的 <span class="math inline">\(20pts\)</span>。剩下的 <span class="math inline">\(20pts\)</span> 询问在 的数量级在 <span class="math inline">\(10^9\)</span> 左右。逐年眺的话大概每次需要 <span class="math inline">\(\lfloor \frac{10^9}{365} \rfloor = 2739626\)</span> 次运算 不是很确定能不能通过。然后发现这个年份显然可以二分，然后预处理的部分已经包含了所有特殊情况，对闰年的判断条件容斥了一下感觉可以做到 <span class="math inline">\(O(1)\)</span> check，虽然预处理了，但是细节仍然很多，处理了很久，终于在大概在开始 <span class="math inline">\(2\)</span>h 的时间里通过了大样例。但是没有对拍，因为线性预处理不可能过，而且样例已经包含了所有的情况。主要是时间已经很不够用了，后面还有三道题，时间剩下不到 <span class="math inline">\(2\)</span>h ，基本上已经确定要退役了。直接放弃听天人命了。</p>
<p>后来想了一下，题目要求 <span class="math inline">\(10^5\)</span> 询问，询问数量级为 <span class="math inline">\(10^9\)</span>。我这个做法好像能做到 <span class="math inline">\(10^6\)</span> 询问，单次询问数量级 <span class="math inline">\(10^{18}\)</span>。所以我在考场上写二分是在炫技吗……最后检查了几个特使情况，自己觉得挺稳的，中间该开 <code>long long</code> 的地方都已经开过了，后来发现数据里面的读入数据就已经超过 <code>int</code> 了。还是丢了<span class="math inline">\(10pts\)</span>。</p>
<h2 id="b">B</h2>
<p>冷静了 <span class="math inline">\(10\)</span>min ，确定了虽然已经完蛋但是还要好好打的想法。开始飞速读题，读了一遍感觉这直接做就可以了吧……以为是读错题了，然后又读了一遍，感觉确实是一个大水题啊…… 开始写代码，这时候已经很紧张了，写错很多次，感觉这种状态写出来的东西会出问题，但是顾不了那么多了。大概 <span class="math inline">\(7\)</span>min 写完了，调试了一下样例用了 <span class="math inline">\(5\)</span>min 左右。然后通过了最大的样例。还剩下大概 <span class="math inline">\(1\)</span>h 多一点的时间，剩下两道最难题目，仍然很迷茫，但是感觉已经 <span class="math inline">\(200pts\)</span> 到手了。</p>
<p>光顾着写没注意这题的复杂度，我的实现很简陋，复杂度只能做到 <span class="math inline">\(O(n\operatorname{log}n)\)</span> ，但是数据范围是 <span class="math inline">\(10^6\)</span> 感觉应该能过，就没有继续优化。</p>
<p>后记：评测的时候，出题人卡满了 <span class="math inline">\(O(n\operatorname{log}n)\)</span> ，根本过不去。而且最后需要特判答案是否溢出，根本没注意那里。最后输出的数字可能是 <span class="math inline">\(2^{64}\)</span> 。计算机中无符号64位整形最大是 <span class="math inline">\(2^{64}-1\)</span>。所以这个情况需要计算器算好 <span class="math inline">\(2^{64}\)</span> ，然后当成字符串输出。然后我觉得太恶心了。</p>
<h2 id="c">C</h2>
<p>第一眼看题的时候，感觉这道题和正睿的一道题非常相似，（其实这道题的大概<span class="math inline">\(20pts\)</span>的部分分可以直接用正睿的那个题的方法做），但是只有 <span class="math inline">\(50\)</span>min 了，后来又去看了看 <span class="math inline">\(D\)</span> 题，<span class="math inline">\(D\)</span>题有<span class="math inline">\(20%\)</span>的分数<span class="math inline">\(n &lt; 4\)</span>这一部分分应该很简单。权衡了一下决定好好写 <span class="math inline">\(C\)</span> 题。<span class="math inline">\(C\)</span> 题的部分分特别多（<span class="math inline">\(20pts\)</span> 暴力 + <span class="math inline">\(20pts\)</span>正睿做法 + <span class="math inline">\(10pts\)</span>线段树模板 = <span class="math inline">\(50pts\)</span> ），然后赶紧开始写。后来呢，第一档分数，状态极差，完全没心情，特别紧张，写了 <span class="math inline">\(40\)</span>min 才过了样例。最后只剩下 <span class="math inline">\(10\)</span>min 了，监考老师都开始准备收拾东西了……我哭了……感觉这种状态下 <span class="math inline">\(10\)</span>min 写双标记线段树有点扯。算了退役了……</p>
<p>最后检查了文件夹，一遍一遍测了样例和文件读写。还剩下<span class="math inline">\(5\)</span>min想了想回去怎么好好学文化课……沮丧之极。难受的在于 还能拿到的但是没时间写的分数大概是<span class="math inline">\(50\)</span>分左右，时间，时间，时间。唉……</p>
<p>后来发现其实这个 <span class="math inline">\(C\)</span> 题挺思路很好想，这个题不能直接套用正睿的做法关键在于乘法和加法操作不能合并，如果展开操作，这个操作数量是<span class="math inline">\(O(n^2)\)</span>级别的，既然不能展开，那正解一定是考虑每单个操作的贡献，这些在考场上第一眼就能看出来的，但是由于很多原因都没有仔细想下去。感觉如果时间充足我能想出来。</p>
<p>其实也不能怨出题人题目排布有问题，其实是自己没好好权衡题目难度，紧张情况下没办法保证代码质量。之后问了冯友和，虽然他 <span class="math inline">\(C\)</span> 题最后只剩下了 <span class="math inline">\(40\)</span>min，但是他在比赛快结束的 <span class="math inline">\(40\)</span>min 中写完了 <span class="math inline">\(5\)</span>min写完了暴力，<span class="math inline">\(5\)</span>min 写完了线段树，<span class="math inline">\(5\)</span>min写完了拓扑排序，我一个暴力最后都快不知道我写的是啥了……还是要多加练习啊。</p>
<h1 id="今后注意">今后注意</h1>
<ul>
<li>还是应该仔细的阅读全部试题，就算第一题比较恶心人，也不会像这次比赛那样做第一题用时很长就感觉自己菜到无可救药。</li>
<li>最简单的题目也要注意部分分，能够给你实现上的简便提示。</li>
<li>不要紧张，写的时候好好调整心态，思考每一种可能的最坏情况，认真解决。</li>
<li>根本原因是不熟练，如果能保证代码写完就不出错，就不会出现什么时间不够用的情况。</li>
<li>代码方面：注意<code>long long</code>可以局部<code>#define int long long</code>,<code>#undef int</code>，保证不会溢出。注意最坏情况下程序可能的出错。在时间允许的情况下优化复杂度。</li>
<li>估分 <span class="math inline">\(260\)</span> 实际 <span class="math inline">\(175\)</span> 还是不要对自己的代码太有信心，忘开一个 <code>long long</code> 就送退役了……</li>
<li>之后还是要多做思维难度大的题，毕竟<span class="math inline">\(C\)</span>题没有在<span class="math inline">\(40\)</span>min里想出来QAQ。</li>
</ul>
]]></content>
      <categories>
        <category>学习总结</category>
      </categories>
  </entry>
  <entry>
    <title>「比赛总结」正睿 提高十连 Day1</title>
    <url>//%E3%80%8C%E6%AF%94%E8%B5%9B%E6%80%BB%E7%BB%93%E3%80%8D%E3%80%8CZROI-2020-%E5%8D%81%E8%BF%9E%E6%B5%8B%E3%80%8DDay1/</url>
    <content><![CDATA[<p>2020 第一次正睿提高十连测，题目很妙。</p>
<a id="more"></a>
<h2 id="problems">Problems</h2>
<div class="note success"><h4 id="a">A</h4>
<p>将 <span class="math inline">\(n\)</span> 个石子分成 <span class="math inline">\(x\)</span> 堆，使每一堆的石子个数都形如 $ 3k^2 - 3k + 1$ <span class="math inline">\((k \le 1)\)</span>。最小化 <span class="math inline">\(x\)</span> 输出 <span class="math inline">\(x\)</span>。</p>
<p><span class="math inline">\(n \le 10^{11}\)</span></p>
</div>
<div class="note success"><h4 id="b">B</h4>
<p>给出一个字符串 <span class="math inline">\(S\)</span> ，求出字符串中，有多少连续的子串形如 <span class="math inline">\(A A_r A\)</span> 。</p>
<p>其中 <span class="math inline">\(A_r\)</span> 表示 <span class="math inline">\(A\)</span> 的反串。合法的相同字串出现多次，统计多次。</p>
<p><span class="math inline">\(|S| \le 2 \times 10^6\)</span></p>
</div>
<div class="note success"><h4 id="c">C</h4>
<p>给出一个 <span class="math inline">\(n\)</span> 个点的树（保证这棵树<strong>随机生成</strong>），点有点权， 规定 <span class="math inline">\(1\)</span> 号点为根节点。</p>
<p><strong>随机</strong>生成一个 <span class="math inline">\(n\)</span> 排列，按这个排列的顺序依次访问所有树上的节点。每次访问到一个结点 <span class="math inline">\(x\)</span> 时，需要将包括 <span class="math inline">\(x\)</span> 在内的所有 <span class="math inline">\(x\)</span> 子树中的点的点权 <span class="math inline">\(V\)</span> 加上 <span class="math inline">\(x\)</span> 点的当前权值 <span class="math inline">\(V^{&#39;}_x\)</span>。</p>
<p>求出最终所有点权和的期望值。</p>
<p><span class="math inline">\(n \le 10^5\)</span></p>
</div>
<h2 id="problem-b-palindrome">Problem B Palindrome</h2>
<h3 id="statement">Statement</h3>
<div class="note info"><p>给出一个字符串，求出字符串中，有多少连续的子串形如 <span class="math inline">\(A A_r A\)</span> 。</p>
<p>其中 <span class="math inline">\(A_r\)</span> 表示 <span class="math inline">\(A\)</span> 的反串。合法的相同字串出现多次，统计多次。</p>
<p><span class="math inline">\(|S| \le 2 \times 10^6\)</span></p>
</div>
<h3 id="analysis">Analysis</h3>
<p>先用各种神奇的算法（<code>字符串 Hash</code> 、<code>manacher</code>）求出 <code>len[i]</code> 表示第 <span class="math inline">\(i\)</span> 个字符和第 <span class="math inline">\(i + 1\)</span> 个字符之间为中心，向两边扩展最长的回文串.</p>
<p>枚举 <span class="math inline">\(A A_r A\)</span> 的 <span class="math inline">\(\frac{1}{3}\)</span> 位置 <span class="math inline">\(i\)</span> ，在 <span class="math inline">\([i + 1, i + \text{len}[i]]\)</span> 这个区间中有多少 <span class="math inline">\(x\)</span> 满足 <span class="math inline">\(x - \text{len}[x] \le i\)</span>， 每一个合法的 <span class="math inline">\(x\)</span> 给答案贡献 <span class="math inline">\(1\)</span>.</p>
<p>转化为<mark class="label info">二维数点</mark>问题.</p>
<mark class="label info">静态二维数点</mark>
<p>可以采用 <mark class="label primary">主席树</mark> 或者<mark class="label danger">离线</mark>后采用 <mark class="label primary">树状数组</mark> 扫描.</p>
<hr />
<h2 id="problem-c-random">Problem C Random</h2>
<div class="note info"><p>给出一个 <span class="math inline">\(n\)</span> 个点的树（保证这棵树<strong>随机生成</strong>），点有点权， 规定 <span class="math inline">\(1\)</span> 号点为根节点。</p>
<p><strong>随机</strong>生成一个 <span class="math inline">\(n\)</span> 排列，按这个排列的顺序依次访问所有树上的节点。每次访问到一个结点 <span class="math inline">\(x\)</span> 时，需要将包括 <span class="math inline">\(x\)</span> 在内的所有 <span class="math inline">\(x\)</span> 子树中的点，点权加 <span class="math inline">\(V_x\)</span>。</p>
<p><span class="math inline">\(n \le 10^5\)</span></p>
</div>
<div class="note danger"><h4 id="关于期望思考">关于期望思考</h4>
<p>期望的<mark class="label primary">线性性</mark>：标志着很多情况下的期望可以分开算，算完后再合并。例如：点权和的期望 <span class="math inline">\(=\)</span> 点权的期望和。</p>
<p>直观感受一下：期望是一个随机变量的平均情况下的数值。</p>
<p>我们不知道这个随机变量<span class="math inline">\(x\)</span>确切的数值，自然也不知道由这个随机变量推导出来的另一个随机变量<span class="math inline">\(X\)</span>（例如：如果我们不知道 每个点 操作后的 <strong>确切点权</strong>，那么所有点的点权和的<strong>确切数值</strong>也无从得知。）</p>
<p>但是如果我们知道每个点在<mark class="label info">平均意义</mark>下取到的值<span class="math inline">\(x\)</span>，我们一样可以通过随机变量<span class="math inline">\(x\)</span><mark class="label info">平均意义</mark>下取到的值推出<span class="math inline">\(X\)</span>在<mark class="label info">平均意义</mark>下取到的值。</p>
</div>
<p>关于本题，我们同样可以拆开来看，要求 求出结点的期望和，那我们可以求出每个点的期望权值，然后再相加就能得到所有结点的期望和。</p>
<p>对于一个有根树上的每一个结点，可能能对这个结点的权值产生贡献的<mark class="label danger">是且仅是</mark>它的祖先。</p>
<p>这个点 <span class="math inline">\(a\)</span> 最终权值的期望 <span class="math inline">\(V^{&#39;}_a\)</span> 就是点 <span class="math inline">\(a\)</span> 的初始权值和所有 <span class="math inline">\(a\)</span> 的祖先对点 <span class="math inline">\(a\)</span> 的期望贡献之和。</p>
<p><span class="math inline">\(a\)</span> 的祖先 <span class="math inline">\(p\)</span> 对 <span class="math inline">\(a\)</span> 的期望贡献可以拆成 <span class="math inline">\(V^{&#39;}_p\)</span> 与 对 <span class="math inline">\(a\)</span> 的贡献次数的乘积。</p>
<p>对于每一条树链上的任意一个点 <span class="math inline">\(x\)</span> 来说某一个祖先 <span class="math inline">\(p\)</span> 对其贡献的次数，只与这个祖先<span class="math inline">\(p\)</span>和这个点<span class="math inline">\(x\)</span>的距离有关。</p>
<p>不妨定义 <span class="math inline">\(\text{dp}[i]\)</span> 为结点 <span class="math inline">\(1\)</span> 到往下的第 <span class="math inline">\(i\)</span> 个点的期望贡献次数（<mark class="label danger">note</mark>：第 <span class="math inline">\(1\)</span> 个点对第 <span class="math inline">\(1\)</span> 个点的贡献次数定义为 <span class="math inline">\(\text{dp}[1]\)</span> ）。</p>
<p>对于每一条树链，我们都可以采用同一套 <span class="math inline">\(\text{dp}\)</span> 值进行处理，因为对于每个点来说，其祖先的对其贡献次数只与他们之间的相对位置有关。</p>
<p>考虑如何预处理出 <span class="math inline">\(\text{dp}[i]\)</span>：</p>
<div class="note success"><p>考虑结点 <span class="math inline">\(1\)</span> 如何对其往下第 <span class="math inline">\(i - 1\)</span> 结点 <span class="math inline">\(x\)</span> 产生贡献。（不妨设：这一条树链上结点的编号由<mark class="label danger">浅到深</mark>依次为 <span class="math inline">\(1-k\)</span> ）。</p>
<p>考虑贡献的传递过程，结点 <span class="math inline">\(1\)</span> 的贡献传给 <span class="math inline">\(x\)</span> 有两种情况：</p>
<ul>
<li><p>由 <span class="math inline">\(1\)</span> 直接传递给 <span class="math inline">\(x\)</span></p></li>
<li><p>由 <span class="math inline">\(1\)</span> 传递给 <span class="math inline">\(x\)</span> 的中间的若干结点，经过多次传递后传递给 <span class="math inline">\(x\)</span> 。</p></li>
</ul>
<p>这些方案对应的贡献为 <span class="math inline">\(1\)</span> ，所以只要求出方案数量，就可以求出结点 <span class="math inline">\(1\)</span> 对 <span class="math inline">\(x\)</span> 的贡献次数。</p>
<p>考虑这些方案对应着什么—— <span class="math inline">\(n\)</span> 的排列中 以 <span class="math inline">\(1\)</span> 开始的<strong>上升序列</strong>的个数。</p>
<p>于是，<span class="math inline">\(\text{dp}[i]\)</span> 就等于在 <span class="math inline">\(n\)</span> 的排列中 以 <span class="math inline">\(1\)</span> 开始的<strong>上升序列</strong>的个数。</p>
<p>枚举一个上升序列的长度 <span class="math inline">\(d\)</span> ，统计其数量即可</p>
<p><span class="math display">\[\begin{equation*} \text{dp}[i] = \sum_{d = 1}^{i} \dbinom{i - 1}{d - 1} \times \dbinom{i}{d} \times (i - d)! \end{equation*}\]</span></p>
<p>其中： - <span class="math inline">\(\dbinom{i - 1}{d - 1}\)</span> 指在 <span class="math inline">\(i - 1\)</span> 中选定 <span class="math inline">\(d - 1\)</span> 个数字<mark class="label danger">(已经强制 <span class="math inline">\(1\)</span> 为开头了)</mark>。</p>
<ul>
<li><p><span class="math inline">\(\dbinom{i}{d}\)</span> 指在 <span class="math inline">\(i\)</span> 个位置中选 <span class="math inline">\(d\)</span> 个将这 <span class="math inline">\(d\)</span> 个数字放下。</p></li>
<li><p><span class="math inline">\((i - d)!\)</span> 指 剩下的<span class="math inline">\((i - d)\)</span>个位置的数字任意排列。</p></li>
</ul>
</div>
<div class="note danger"><p>最后需要注意一点，因为树是随机生成的，其实这就保证了树的高度（树链的最长长度）在<span class="math inline">\(O(\sqrt n)\)</span>级别，预处理和统计答案相当于是线性的。</p>
</div>
<h2 id="codes">Codes</h2>
<div class="tabs" id="codes"><ul class="nav-tabs"><li class="tab active"><a href="#codes-1">Code A</a></li><li class="tab"><a href="#codes-2">Code B</a></li><li class="tab"><a href="#codes-3">Code C</a></li></ul><div class="tab-content"><div class="tab-pane active" id="codes-1"><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">#include &lt;cstdio&gt;
#include &lt;cstring&gt;
#include &lt;iostream&gt;
#include &lt;cmath&gt;
using namespace std;
const int _ &#x3D; 1e7 + 100;
#define LL long long
LL read()&#123; LL x; scanf(&quot;%lld&quot;, &amp;x); return x; &#125;
LL A[_], Q;
void init()&#123;
    for(int i &#x3D; 1; ; i++) &#123; A[i] &#x3D; ( (i) *1ll* (i - 1) ) &gt;&gt; 1; if(A[i] &gt; 1e11) break; else Q &#x3D; i; &#125;
&#125;
int doit(LL x)&#123;
    if(x % 6 !&#x3D; 1 &amp;&amp; x % 6 !&#x3D; 2) return x % 6 &#x3D;&#x3D; 0 ? 6 : x % 6;
    if(x % 6 &#x3D;&#x3D; 1)&#123;
        x &#x3D; (x - 1) &#x2F; 6;
        if( ( *lower_bound(A + 1, A + Q + 1, x) ) &#x3D;&#x3D; ( x ) ) return 1;
        else return 7;
    &#125; else &#123;
        x &#x3D; (x - 2) &#x2F; 6;
        int L &#x3D; 1, R &#x3D; Q;
        while(L &lt;&#x3D; R)&#123;
            if(A[L] + A[R] &#x3D;&#x3D; x) return 2;
            while(A[R] + A[L] &lt; x) L++;
            while(A[R] + A[L] &gt; x) R--;
        &#125;
        return 8;
    &#125;
&#125;
int main()&#123;
    int T &#x3D; read();
    init();
    while(T--) printf(&quot;%d\n&quot;, doit(read()));
    return 0;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div><div class="tab-pane" id="codes-2"><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">#include &lt;cstdio&gt;
#include &lt;cstring&gt;
#include &lt;iostream&gt;
#include &lt;cmath&gt;
#include &lt;ctime&gt;
#include &lt;algorithm&gt;
using namespace std;
const int _ &#x3D; 2e7 + 100;
#define LL long long
int read()&#123; int x; scanf(&quot;%d&quot;, &amp;x); return x; &#125;
char S[_];
int  n;
namespace Hash&#123;
    const int MOD  &#x3D; 998244353;
    const int base &#x3D; &#39;z&#39; + 10;
    int ahs[_];
    int bhs[_];
    int POW[_];
    int pow(int a, int b, int p)&#123; int ans &#x3D; 1; while(b) &#123; if(b &amp; 1) ans &#x3D; (ans *1LL* a) % p; a &#x3D; (a *1ll* a) % p; b &gt;&gt;&#x3D; 1; &#125; return ans; &#125;
    int suba(int L, int R) &#123; return (  ahs[R] - (ahs[L - 1] *1ll* POW[R - L + 1] % MOD)  +0ll+ MOD) % MOD; &#125;
    int subb(int L, int R) &#123; return (  bhs[L] - (bhs[R + 1] *1ll* POW[R - L + 1] % MOD)  +0ll+ MOD) % MOD; &#125;
    void initHash(int x)&#123;
        POW[0] &#x3D; 1;
        for(int i &#x3D; 1; i &lt;&#x3D; x; i++) POW[i] &#x3D; POW[i - 1] *1ll* base % MOD;
        for(int i &#x3D; 1; i &lt;&#x3D; x; i++)&#123;
            ahs[i] &#x3D; ( (ahs[i - 1] *1ll* base) +0ll+ S[i] ) % MOD;
        &#125;
        for(int i &#x3D; x; i &gt;&#x3D; 1; i--)&#123;
            bhs[i] &#x3D; ( (bhs[i + 1] *1ll* base) +0ll+ S[i] ) % MOD;
        &#125;
    &#125;
&#125;
using Hash::initHash;
using Hash::suba;
using Hash::subb;
int mlen[_];
int qury[_];

int main()&#123;
    clock_t t0 &#x3D; clock();
    freopen(&quot;in.txt&quot;, &quot;r&quot;, stdin);
    scanf(&quot;%s&quot;, S + 1); n &#x3D; strlen(S + 1);
    initHash(n);
    for(int i &#x3D; 1; i &lt; n; i++)&#123;
        if(S[i] !&#x3D; S[i + 1]) &#123; mlen[i] &#x3D; 0; continue; &#125;
        int L &#x3D; 0;
        int R &#x3D; i;
        int ans &#x3D; 0;
        while(L &lt; R)&#123;
            int mid &#x3D; L + ((R - L + 1) &gt;&gt; 1);
            if(suba(i - mid + 1, i) &#x3D;&#x3D; subb(i + 1, i + mid)) ans &#x3D; mid, L &#x3D; mid;
            else R &#x3D; mid - 1;
        &#125;
        mlen[i] &#x3D; ans;
    &#125;

    for(int i &#x3D; 1; i &lt; n; i++) qury[i] &#x3D; i - mlen[i];

    int ans &#x3D; 0;
    for(int i &#x3D; 1; i &lt; n; i++)&#123;
        for(int j &#x3D; i + 1; j &lt;&#x3D; i + mlen[i];j++) ans +&#x3D; (j - mlen[j] &lt;&#x3D; i);
    &#125;
    printf(&quot;%d&quot;, ans);
    return 0;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div><div class="tab-pane" id="codes-3"><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">#include &lt;cstdio&gt;
#include &lt;cstring&gt;
#include &lt;cmath&gt;
#include &lt;stack&gt;
#include &lt;iostream&gt;
#define MOD 1000000007
using namespace std;
int read()&#123; int x; scanf(&quot;%d&quot;, &amp;x); return x; &#125;
const int _ &#x3D; 1e5 + 100;
const int MAXD &#x3D; 1e3 + 100;
int head[_];
struct edges&#123;
    int node;
    int nxt;
&#125;edge[_ &lt;&lt; 1];
int tot &#x3D; 0;
void add(int u, int v)&#123;
    tot++;
    edge[tot].node &#x3D; v;
    edge[tot].nxt  &#x3D; head[u];
    head[u]        &#x3D; tot;
&#125;
int n;
int rt &#x3D; 1;
int C[MAXD + 100][MAXD + 100];
int frc[_];
int dp[_];
int pow(int a, int b, int P)  &#123; int ans &#x3D; 1; while(b) &#123; if(b &amp; 1) ans &#x3D; (ans *1ll* a) % P; a &#x3D; (a *1ll* a) % P; b &gt;&gt;&#x3D; 1; &#125; return ans; &#125;
int inv(int x)&#123; return pow(x, MOD - 2, MOD); &#125;
const int DB &#x3D; 20;
void init()&#123;
    C[0][0] &#x3D; 1;
    for(int i &#x3D; 1; i &lt;&#x3D; MAXD; i++)&#123;
        C[i][0] &#x3D; 1;
        for(int j &#x3D; 1; j &lt;&#x3D; i; j++)&#123;
            C[i][j] &#x3D; ( C[i - 1][j] +0ll+ C[i - 1][j - 1] ) % MOD;
        &#125;
    &#125;
    frc[0] &#x3D; 1;
    for(int i &#x3D; 1; i &lt;&#x3D; _ - 10; i++) frc[i] &#x3D; ( frc[i - 1] *1ll* (i) ) % MOD;
    for(int i &#x3D; 1; i &lt;&#x3D; MAXD; i++)&#123;
        dp[i] &#x3D; 0;
        for(int d &#x3D; 1; d &lt;&#x3D; i; d++)&#123;
            dp[i] &#x3D; (dp[i] +0ll+ (
                (  ( (C[i - 1][d - 1] *1ll* C[i][d]) % MOD ) *1ll* frc[i - d]  ) % MOD
                    ) % MOD) % MOD;
        &#125;
    &#125;
    for(int i &#x3D; 1; i &lt;&#x3D; MAXD; i++) dp[i] &#x3D; (dp[i] *1ll* inv(frc[i])) % MOD;
&#125;
int ans &#x3D; 0;
struct Stack&#123; int v[_]; int top; Stack()&#123; top &#x3D; 0; &#125; inline int *GetHead()&#123; return &amp;v[0]; &#125; inline int* GetTail()&#123; return &amp;v[top]; &#125; void push(int x)&#123;v[top++] &#x3D; x;&#125; void pop()&#123;top --;&#125; &#125;;
Stack S;
int val[_];
int NodeVal[_];
void dfs0(int o, int fa, int dep)&#123;
    S.push(o);
    int now &#x3D; dep;
    for(int *i &#x3D; S.GetHead(); i !&#x3D; S.GetTail(); i++)&#123;
        val[o] &#x3D; (  val[o] +0ll+ (dp[now] *1ll* NodeVal[*i]) % MOD  ) % MOD;
        now --;
    &#125;
    for(int i &#x3D; head[o]; i ; i &#x3D; edge[i].nxt)&#123;
        int ex &#x3D; edge[i].node;
        if(ex &#x3D;&#x3D; fa) continue;
        dfs0(ex, o, dep + 1);
    &#125;
    S.pop();
&#125;
int main()&#123;
    n &#x3D; read();
    init();
    for(int i &#x3D; 1; i &lt; n; i++)&#123; int u &#x3D; read(), v &#x3D; read(); add(u, v); add(v, u); &#125;
    for(int i &#x3D; 1; i &lt;&#x3D; n; i++) NodeVal[i] &#x3D; read();
    dfs0(1, -1, 1);
    int ans &#x3D; 0;
    for(int i &#x3D; 1; i &lt;&#x3D; n; i++) ans &#x3D; (ans +0ll+ NodeVal[i]) % MOD;
    for(int i &#x3D; 1; i &lt;&#x3D; n; i++) ans &#x3D; (ans +0ll+ val[i]) % MOD;
    printf(&quot;%d\n&quot;, (ans *1ll* frc[n]) % MOD);
    return 0;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></div></div>
]]></content>
      <categories>
        <category>比赛总结</category>
      </categories>
  </entry>
  <entry>
    <title>「比赛总结」实验舱</title>
    <url>//%E3%80%8C%E6%AF%94%E8%B5%9B%E6%80%BB%E7%BB%93%E3%80%8D%E5%AE%9E%E9%AA%8C%E8%88%B1/</url>
    <content><![CDATA[<p>第一天的题都是好题啊 QAQ!!</p>
<a id="more"></a>
<h2 id="异或">异或</h2>
<p>给出一个大小为 <span class="math inline">\(n\)</span> 的集合 <span class="math inline">\(S\)</span> 和一个整数 <span class="math inline">\(x\)</span> ，求 <span class="math inline">\(S\)</span> 中有多少子集满足其中任意两个元素之间的异或和不小于 <span class="math inline">\(x\)</span> 。对质数取模。 <span class="math inline">\(n \le 10^6\)</span></p>
<p>设 <span class="math inline">\(x\)</span> 的二进制最高位为 <span class="math inline">\(k\)</span> 。</p>
<p>考虑两个数字异或的情况，如果两个数字大于 <span class="math inline">\(k\)</span> 的二进制位不一样，其异或结果一定不小于 <span class="math inline">\(x\)</span> 。</p>
<p>那么如果我们把大于 <span class="math inline">\(k\)</span> 的二进制位相同的数取出来，分成一个组，然后单独求出每组内能取出的子集个数，最后答案只需要对每个组能取出的子集个数自由组合即可。</p>
<p>考虑求出每组内能取出的子集个数。因为要求每组取出的子集中任意两个数的异或和所以这些数字在第 <span class="math inline">\(k\)</span> 位的取值一定要两两不同，所以每一组内取出的合法子集大小只有 <span class="math inline">\(0, 1, 2\)</span> 三种，前两种是平凡的，最后一种用 trie 维护即可。</p>
<h2 id="计数">计数</h2>
<p>给定整数 <span class="math inline">\(x\)</span> ，定义长度为 <span class="math inline">\(N\)</span> 的序列 <span class="math inline">\(\{a_i\}\)</span> 的价值 <span class="math inline">\(f(a)\)</span> 如下：</p>
<p><span class="math display">\[
\max\{L(a)-x,0\}
\]</span></p>
<p>其中 <span class="math inline">\(L(a)\)</span> 表示 <span class="math inline">\(a\)</span> 最长的相同子段的长度。</p>
<p>给定整数 <span class="math inline">\(N,K, x\)</span> ，求出长度为 <span class="math inline">\(N\)</span>，各个元素在 <span class="math inline">\([1,K]\)</span> 中的所有整数序列的价值之和。大质数取模。 <span class="math inline">\(N \le 10^6, K \le 10^8, x \ge 0\)</span></p>
<p>首先一个显然的策略是枚举每个 <span class="math inline">\(L(a)\)</span> 的可能取值 <span class="math inline">\(x\)</span>，算方案数即可。</p>
<p>每次算方案数时可以设 <span class="math inline">\(dp[n][0/1]\)</span> 考虑了长度为 <span class="math inline">\(n\)</span> 的序列，达到了 / 未达到 <span class="math inline">\(x\)</span> 的方案数。</p>
<p>这样就已经没办法优化了，可以考虑把等于的限制改宽改为大于的限制，注意到： <span class="math display">\[
\max\{L(a) - x, 0\}=\sum_{i=x+1}^{n}\left[L[a] \ge i\right]
\]</span> 类似地贡献转化手法还有<a href="https://www.luogu.com.cn/problem/P4365">这道题</a>。可能是一种常见套路</p>
<p>问题转化为对于一个 <span class="math inline">\(i\)</span> 求有多少序列的连续子段长度大于 <span class="math inline">\(i\)</span>。</p>
<p>可以考虑补集转化，求有多少序列的连续子段长度小于 <span class="math inline">\(i\)</span> 的序列，只需要在每个位置枚举从这里出发连续字段有多长就可以了。（相当于一个存在性限制，转化为任意性限制，任意性限制显然结构更加简单）</p>
<p>可以设 <span class="math inline">\(dp[n]\)</span> 表示长度为 <span class="math inline">\(n\)</span> 的序列，最长相同子段的长度小于 <span class="math inline">\(x\)</span> 的方案数，转移显然： <span class="math display">\[
dp[n] =
\begin{cases}
k^n &amp; n &lt; x\\
(k-1)\sum_{i=1}^{x-1}\limits{dp[n-i]} &amp; otherwise.
\end{cases}
\]</span> 可以用前缀和优化。这样做复杂度仍旧是 <span class="math inline">\(\mathcal{O}(n^2)\)</span> 的。</p>
<p>题解中给出了这样一份代码，其 <span class="math inline">\(dp[n]\)</span> 的意义是长度为 <span class="math inline">\(n\)</span> 的合法序列，且最后两个元素不同的方案数：</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">int getans(int n, int k, int x) &#123;
	if (x &#x3D;&#x3D; 1) return power(k, n);
	static int dp[MAXN]; dp[1] &#x3D; k;
	for (int i &#x3D; 2; i &lt;&#x3D; n; i++)
		if (i &lt; x) dp[i] &#x3D; 1ll * k * dp[i - 1] % P;
		else dp[i] &#x3D; (1ll * k * dp[i - 1] - 1ll * (k - 1) * dp[i - x] % P + P) % P;
	return (0ll + power(k, n) - dp[n] + P + dp[n - x + 1]) % P;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>按照题解的转移方式，其方程可以写作：（转移可以理解为把最后一个数字扩充，然后随便放上一个不一样的） <span class="math display">\[
dp[n]=
\begin{cases}
k &amp;n=1\\
dp[n-1]\times k &amp;i &lt; x\\
dp[n-1]\times k + (1-k) \times dp[i-x] &amp;otherwise.
\end{cases}
\]</span> 考虑到这里的方程转移比较单一，可以试图画出转移图，然后考虑贡献的传递，第一个点值为 <span class="math inline">\(k\)</span> ，每一条转移边都是乘某一个值，且这个值的取值仅有 <span class="math inline">\(2\)</span> 种。</p>
<p>如果一条从 <span class="math inline">\(1\)</span> 到 <span class="math inline">\(n\)</span> 的转移路径所经过的两种转移路径数量相同，那么他们的贡献也相同。枚举第二条转移路径的数量即可计算贡献。这样做的复杂度是 <span class="math inline">\(\mathcal{O}(\frac{n}{x})\)</span> 。根据调和级数的理论，这样的做法是 <span class="math inline">\(\mathcal{O}(n\log n)\)</span> 的。</p>
<p>有一道平衡树优化 dp 转移的题目，比较有意思。</p>
<!-- more -->
<p><a href="/oi-blog/pdf/20210310/A.pdf">A</a></p>
<p><a href="/oi-blog/pdf/20210310/A.pdf">B</a></p>
<h2 id="c.-最大价值"><a href="/oi-blog/pdf/20210310/C.pdf">C. 最大价值</a></h2>
<p>A 君有 <span class="math inline">\(n\)</span> 个物品，每个物品有两个属性 <span class="math inline">\(a_i,b_i\)</span>，现在 A 君想从所有物品中挑选 <span class="math inline">\(k\)</span> 个，并按一定顺序摆放好。</p>
<p>对于一个方案中，被摆在第 <span class="math inline">\(j\)</span> 个位置（位置从 <span class="math inline">\(1\)</span> 开始标号）的物品为 <span class="math inline">\(i\)</span>，它对这个方案产生的价值贡献为 <span class="math inline">\(a_i\cdot(j-1)+b_i\)</span>，一个方案的价值和为它所含的所有物品的贡献之和。</p>
<p>现在 A 君想知道对于所有可能的 <span class="math inline">\(k\)</span>（<span class="math inline">\(1\le k\le n​\)</span>），在最优的选取以及摆放情况下能得到的方案价值和最大是多少。</p>
<p>接下来 <span class="math inline">\(n\)</span> 行，每行两个整数 <span class="math inline">\(a_i, b_i\)</span>。</p>
<p><span class="math inline">\(100\%\)</span> 的数据：<span class="math inline">\(n \le 300\,000\)</span>, <span class="math inline">\(0 \le a_i \le 10^6\)</span>, <span class="math inline">\(0 \le b_i \le 10^{12}\)</span></p>
<p>输出 <span class="math inline">\(n\)</span> 行，每行两个整数 <span class="math inline">\(a_i, b_i\)</span> ，表示 <span class="math inline">\(k=1, 2, 3, 4, \cdots , n\)</span> 时的最大总价值。</p>
<p>对于一个大小为 <span class="math inline">\(k\)</span> 的方案，如果确定了选择哪 <span class="math inline">\(k\)</span> 个，就可以直接按照 <span class="math inline">\(a\)</span> 排序，然后依次算出贡献（排序不等式）</p>
<p>那么显然可以考虑先对原物品按照的 <span class="math inline">\(a\)</span> 排序，然后依次做背包即可。 <span class="math display">\[
dp[i][j] = \max\{dp[i-1][j], dp[i-1][j-1] + a_i\times j+b_i\}
\]</span> 观察到一条结论，选定 <span class="math inline">\(k\)</span> 个物品的答案，一定是在原来 <span class="math inline">\(k-1\)</span> 个物品的答案基础上添加一个物品，而不会拿走。</p>
<p>如果考虑了 <span class="math inline">\(i\)</span> 种物品，那么对于选取 <span class="math inline">\(j\)</span> 个物品的方案，一定是从选 <span class="math inline">\(j-1\)</span> 个物品的方案添加一个物品得到的。也就是说，每新考虑一个物品，上面的转移一定是在某个 <span class="math inline">\(j\)</span> 之前都是继承上一轮的答案，之后都是新增这个物品的答案，维护差分数组即可。可以平衡数维护每一个 <span class="math inline">\(j\)</span> 处的答案的差分。</p>
<p>官方题解附有结论证明。</p>
]]></content>
      <categories>
        <category>比赛总结</category>
      </categories>
      <tags>
        <tag>dp</tag>
        <tag>异或</tag>
        <tag>分组思想</tag>
        <tag>贡献转化</tag>
        <tag>dp优化</tag>
      </tags>
  </entry>
  <entry>
    <title>「比赛总结」正睿省选失恋测</title>
    <url>//%E3%80%8C%E6%AF%94%E8%B5%9B%E6%80%BB%E7%BB%93%E3%80%8D%E6%AD%A3%E7%9D%BF%E7%9C%81%E9%80%89%E5%A4%B1%E6%81%8B%E6%B5%8B/</url>
    <content><![CDATA[<p>正睿十连测 Round 8 补题记录。 菜到去世……</p>
<a id="more"></a>
<h2 id="陈太阳的石子游戏">陈太阳的石子游戏</h2>
<p>有 <span class="math inline">\(n\)</span> 堆石子，每堆石子被染成了黑色或者白色，第 <span class="math inline">\(i\)</span> 堆石子有 <span class="math inline">\(a_i\)</span> 个石子。陈太阳和杨主力轮流操作，杨主力先操作。操作有两种，他们每次可以选择一种进行操作：</p>
<ul>
<li>从石子数量最少的黑堆中取出任意正整数数量的石头</li>
<li>从任何白堆中取出任意正整数数量的石头</li>
</ul>
<p>不能操作的玩家将会输掉游戏。现在所有石头堆都是固定的，但尚未着色。 陈太阳贿赂了裁判，使他有机会自己给所有石头涂色。 现在，他想知道有多少种涂色方法使得自己能赢下游戏？ 由于答案可能太大，因此只需要输出模 <span class="math inline">\(1 000 000 007\)</span> 答案即可。</p>
<p><span class="math inline">\(n\le 10^6\)</span></p>
<p>好吧 - -这才明白什么叫做 <code>SG</code> 函数。</p>
<h3 id="sprague-grundysg定理">Sprague-Grundy(SG)定理</h3>
<p>对于一个完整的游戏局面 <span class="math inline">\(G\)</span> ，有若干个子游戏 <span class="math inline">\(G_0, G_1, G_2, \cdots\)</span> 那么： <span class="math display">\[
\operatorname{SG}(G) = \bigoplus\limits{G_i}
\]</span> 对于一个局面 <span class="math inline">\(x\)</span> ，若其有若干个后继局面，则： <span class="math display">\[
\operatorname{SG}(x) = \operatorname{mex}\{ \operatorname{SG}(y) \mid y \text{是} x \text{后继} \}
\]</span> 特殊地，若一个局面 <span class="math inline">\(P\)</span> 没有后继局面，则其 <span class="math inline">\(\operatorname{SG}\)</span> 值为 <span class="math inline">\(0\)</span>。</p>
<p>首先考虑必胜局面条件是什么：</p>
<p>对一个局面划分子游戏，显然，白色石头和黑色石头可以作为两个子游戏，白色石头构成一个经典的 <code>Nim</code> 游戏。只需要考虑黑色石头的 <span class="math inline">\(\operatorname{SG}\)</span> 值即可。</p>
<p>通过手算不难发现黑色石头的 <span class="math inline">\(\operatorname{SG}\)</span> 值为： <span class="math display">\[
\text{最小堆中的石头数}-(\text{最小堆的数量}+[\text{所有黑色石头堆都具有相同的大小}]) \% 2
\]</span> 先按照石子数量排序。</p>
<p>可以考虑枚举最小堆出现次数和石子数量 <span class="math inline">\(x\)</span>，石子数量小于 <span class="math inline">\(x\)</span> 的石子堆一定是白色堆，枚举一个出现次数，可以算出石子数量等于 <span class="math inline">\(x\)</span> 和小于 <span class="math inline">\(x\)</span> 的堆的 <span class="math inline">\(\operatorname{SG}\)</span> 值 <span class="math inline">\(z\)</span>，然后考虑后面的石子堆有多少种选法，使得其 <span class="math inline">\(\operatorname{SG}\)</span> 值等于 <span class="math inline">\(z​\)</span> 即可。这个问题是 <a href="https://shuyumo2003.github.io/%E3%80%8C%E7%90%90%E8%AE%B0%E3%80%8D%E8%B4%B0%E6%9C%88-%E5%8F%81%E6%9C%88-%E7%90%90%E8%AE%B0/#%E7%BA%BF%E6%80%A7%E5%9F%BA%E7%90%90%E8%AE%B0">线性基</a> 的经典问题。</p>
<h2 id="陈阳太的集合">陈阳太的集合</h2>
<p>陈阳太有个集合 <span class="math inline">\(U=\{ 1,2,3,⋯,n \}\)</span> 她打算和杨主力轮流操作。</p>
<ul>
<li>陈阳太负责<strong>一次拆分操作</strong>。具体地，陈阳太会将集合 <span class="math inline">\(U\)</span> 分成<strong>至少两个非空集合</strong>，它们的并集为 <span class="math inline">\(U\)</span> 且两两交集均为 <span class="math inline">\(\varnothing\)</span>。</li>
<li>杨主力负责<strong>多次合并操作</strong>。具体地，杨主力首先收到陈阳太操作后的所有集合，随后每当杨主力手上存有<strong>多于一个集合</strong>，则必须取出两个集合<strong>合二为一</strong>，即取出的集合消失并获得它们的并集。</li>
</ul>
<p>显然最终杨主力将获得集合 <span class="math inline">\(U\)</span>，同时操作结束。</p>
<p>定义两局操作不同，当且仅当存在集合 <span class="math inline">\(S\)</span>，在一局操作中出现过且在另一局操作中从未出现。<strong>注意，与操作次序无关。</strong></p>
<p>求杨主力和陈阳太一共有多少局不同的操作，对 <code>NTT</code> 质数取模。</p>
<p><span class="math inline">\(n \le 10^6\)</span></p>
<p>只考虑如何合并一些集合，可以倒过来考虑，考虑一开始有一个全集 <span class="math inline">\(U\)</span> ，如何拆分成若干个子集，显然每一种拆分方式对应一个操作等价类。</p>
<p>考虑递推式：</p>
<p>设 <span class="math inline">\(f(n)\)</span> 为将元素个数为 <span class="math inline">\(n\)</span> 的集合拆分成若干个集合的情况。</p>
<p>易知递推式为： <span class="math display">\[
f(n) = 1 + \frac{1}{2}\sum_{i=1}^{n-1}\dbinom{n}{i}f(i)f(n - i)
\]</span> 其中 <span class="math inline">\(+1\)</span> 是考虑到这个集合就在这里停止划分，后面的 <span class="math inline">\(\frac{1}{2}​\)</span> 是因为划分没有什么顺序性。</p>
<p>可以考虑生成函数优化，这个式子后面的项稍微补补就是一个卷积，先定义 <span class="math inline">\(f(0)=1\)</span>，可以把式子写成： <span class="math display">\[
f(n) = 1 + \frac{1}{2}\left[\left(\sum_{i=0}^{n}\dbinom{n}{i}f(i)(n-i)\right) - 2 \times f(n)\right]
\]</span></p>
<p><span class="math display">\[
2f(n) = 1 + \frac{1}{2}\sum_{i=0}^{n}\dbinom{n}{i}f(i)(n-i)
\]</span></p>
<p>补齐常数项： <span class="math display">\[
2f(n) = 1 + \frac{[n=0]}{2} + \frac{1}{2}\sum_{i=0}^{n}\dbinom{n}{i}f(i)(n-i)
\]</span> 有组合数，考虑指数生成函数： <span class="math display">\[
2\frac{f(n)}{n!} = \frac{1 + \frac{[n=0]}{2}}{n!} + \frac{1}{2}\sum_{i=0}^{n}\frac{f(i)}{i!}\frac{f(n-i)}{(n-i)!}
\]</span> 设 <span class="math inline">\(F(x) = \sum_{i \ge 0} f(i)\frac{x^i}{i!}\)</span> <span class="math display">\[
2F(x)=e^x+\frac{1}{2}+\frac{1}{2}F^2(x)
\]</span> 解出 <span class="math inline">\(F(x)\)</span> 根据常数项，得到最终取值为： <span class="math display">\[
F(x) = 2 + \sqrt{3+2e^x}
\]</span> 需要一个多项式开方。大佬们对长度为 <span class="math inline">\(10^6\)</span> 的多项式开方都冲到 <span class="math inline">\(500ms\)</span> 了，我的甚至需要跑 <span class="math inline">\(8s\)</span> 左右，就很震撼 /kk。</p>
<p>题目关键是对计数对象的转化，需要根据题目描述的等价类划分方式，确定转化为何种计数对象。</p>
<h2 id="陈太阳的树">陈太阳的树</h2>
<p>陈太阳有一棵 <span class="math inline">\(n\)</span> 个点的树，每条边 <span class="math inline">\(e_i\)</span> 上有一个非空字母集合 <span class="math inline">\(S_i \subset \{&#39;a&#39;,&#39;b&#39;,\cdots,&#39;z&#39;\}\)</span>，陈太阳还有一个模板串集合 <span class="math inline">\(T = \{t_1, t_2, \cdots, t_m\}\)</span></p>
<p>杨主力给了陈太阳 <span class="math inline">\(q\)</span> 次询问，每次询问给定一条从 <span class="math inline">\(u\)</span> 到 <span class="math inline">\(v\)</span> 的有向树链，问有多少种在树边上选字母的方案，使得将所有树链上的字母按照从 <span class="math inline">\(u\)</span> 到 <span class="math inline">\(v\)</span> 的顺序写出来之后形成的字符串包含模板串集合中至少一个模板串。</p>
<p>杨主力不想让答案数字太大，于是陈太阳只需要告诉杨主力对 998244353 取模的结果就好了。</p>
<p>输入第一行两个正整数 <span class="math inline">\(n,m,q\)</span>，分别表示树的大小，模板串集合的大小以及询问的个数。</p>
<p>接下来 <span class="math inline">\(n-1\)</span> 行，每行两个正整数 <span class="math inline">\(u,v(1 \le u &lt; v \le n)\)</span> 以及一个字符串 <span class="math inline">\(s\)</span>，表示 <span class="math inline">\(u\)</span> 点到 <span class="math inline">\(v\)</span> 点之间有一条边，边上的非空字母集合由 <span class="math inline">\(s\)</span> 中的所有字母构成。保证 <span class="math inline">\(s\)</span> 只包含小写字母且不包含重复的字符</p>
<p>接下来 <span class="math inline">\(m\)</span> 行，每行一个字符串，表示一个模板串。保证所有模板串的长度之和不超过 40</p>
<p>接下来 <span class="math inline">\(q\)</span> 行，每行两个正整数 <span class="math inline">\(u,v(1 \le u,v \le n, u\neq v)\)</span>，表示一次询问。</p>
<p><span class="math inline">\(1\le n \le 2500, 1\le q \le 5000, 1\le m \le 40, \sum|t_i|\le 40\)</span></p>
<p>多模板匹配问题，显然需要 AC 自动机，显然可以在 AC 自动机上对路径 dp。</p>
<p>一个 AC 自动机的技巧：如果只是想判断 AC 自动机中是否存在一个模板串可以在文本串中完全匹配，可以考虑强制将 AC 自动机中每一个模板串结束字符对应结点的出边全都连向自己。最后走完文本串后一定会停留在一个模板串结尾的对应结点。</p>
<p>但是这里的文本串不确定，就可以考虑在 AC 自动机上 dp。</p>
<p>设 <span class="math inline">\(dp[n][u]\)</span> 表示考虑了路径的前 <span class="math inline">\(n\)</span> 个结点，到达结点 <span class="math inline">\(u\)</span> 的路径个数。</p>
<p>如果每次暴力 dp 就能够得到 <span class="math inline">\(\mathcal{O}(qnt^3)\)</span> 的做法。</p>
<p>考虑到每个边的转移其实是相似的，按照动态 dp 的套路可以把每一条树边的贡献理解为一种线性变换？考虑使用矩阵乘法表示转移，每一条树边就对应一个矩阵，可以倍增预处理就能够做到单次询问 <span class="math inline">\(\mathcal{O}(t^2\log n)\)</span> 的复杂度。</p>
<p>可以考虑树剖然后线段树维护矩阵乘积。</p>
<p>还可以点分之后预处理每个点到其祖先路径上的矩阵乘积，然后点分树上合并矩阵乘法。</p>
<p>还可以点分之后离线处理每个询问。</p>
<p>能过几个就不得而知了</p>
]]></content>
      <categories>
        <category>比赛总结</category>
      </categories>
      <tags>
        <tag>数学</tag>
        <tag>计数</tag>
        <tag>题解</tag>
        <tag>线性基</tag>
        <tag>博弈论</tag>
        <tag>矩阵</tag>
        <tag>树链剖分</tag>
        <tag>生成函数</tag>
        <tag>字符串</tag>
        <tag>AC自动机</tag>
      </tags>
  </entry>
  <entry>
    <title>「比赛总结」洛谷 10 月赛</title>
    <url>//%E3%80%8C%E6%AF%94%E8%B5%9B%E6%80%BB%E7%BB%93%E3%80%8D%E6%B4%9B%E8%B0%B7-10-%E6%9C%88%E8%B5%9B/</url>
    <content><![CDATA[<p>洛谷 2020 年 10 月 月赛 有两道期望题分数拿的还不错 . <a id="more"></a></p>
<h1 id="pro.-a">Pro. A</h1>
<div class="note info"><p>给出一张无向图，从任意一点出发，规定每条边只能经过一次（正向 反向都算一次）。求最长的合法路径长度。</p>
</div>
<div class="note success"><p>考虑每次经过一个点 x ，就会使点 x 的可用度数减 2 。如果走到一个合法度数为 0 的点，那么路径终止。要求是求最长路径长度，那么显然应该以此减少每个点的可用度数。每个点的初始度数为 n - 1。特殊考虑有偶数个点的完全图，初始度数为奇数，那么最后一次仍然可以走一步到达一个点。 <span class="math display">\[\begin{equation*}\frac{n-1}{2} \times n + [n\ \texttt{mod}\ 2\ =\ 0]\end{equation*}\]</span></p>
</div>
<!-- more -->
<h2 id="code">code</h2>
<pre class="line-numbers language-python" data-language="python"><code class="language-python"># python3
T &#x3D; int(input())
for i in range(T):
    now &#x3D; int(input())
    print((now - 1) &#x2F;&#x2F; 2 * now + ((now &amp; 1) ^ 1))<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h1 id="pro.-b">Pro. B</h1>
<div class="note info"><p>总共有 <span class="math inline">\(n\)</span> 条带 「圣盾」的「胖头鱼」和 <span class="math inline">\(m\)</span> 条不带圣盾的胖头鱼，每次等概率对一条存活的胖头鱼造成「剧毒」伤害。 现在 Amazing John 想知道，期望造成多少次伤害可以杀死全部胖头鱼？<br />
答案对 <span class="math inline">\(998244353\)</span> 取模。</p>
<ul>
<li>「圣盾」：当拥有圣盾的胖头鱼受到伤害时，免疫这条鱼所受到的本次伤害。免疫伤害后，圣盾被破坏。</li>
<li>「胖头鱼」：在一条胖头鱼的圣盾被破坏后，给予其他所有没有死亡且没有圣盾的胖头鱼圣盾。</li>
<li>「剧毒」：立即杀死没有圣盾的胖头鱼。</li>
</ul>
<p>本题共有 <span class="math inline">\(20\)</span> 个数据点，数据点从 <span class="math inline">\(1\)</span> 到 <span class="math inline">\(20\)</span> 编号。对于一个子任务，只有通过其中所有数据点才能获得该子任务的分数。</p>
<table>
<thead>
<tr class="header">
<th>子任务</th>
<th>数据点</th>
<th>数据范围</th>
<th>分数</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><span class="math inline">\(1\)</span></td>
<td><span class="math inline">\(1\sim3\)</span></td>
<td><span class="math inline">\(n,m≤5×10^3\)</span></td>
<td><span class="math inline">\(15\)</span></td>
</tr>
<tr class="even">
<td><span class="math inline">\(2\)</span></td>
<td><span class="math inline">\(4\sim5\)</span></td>
<td><span class="math inline">\(n≤10^6，m=0\)</span></td>
<td><span class="math inline">\(10\)</span></td>
</tr>
<tr class="odd">
<td><span class="math inline">\(3\)</span></td>
<td><span class="math inline">\(6\sim10\)</span></td>
<td><span class="math inline">\(n,m≤10^6\)</span></td>
<td><span class="math inline">\(25\)</span></td>
</tr>
<tr class="even">
<td><span class="math inline">\(4\)</span></td>
<td><span class="math inline">\(11\sim14\)</span></td>
<td><span class="math inline">\(n≤10^{14}，m=0\)</span></td>
<td><span class="math inline">\(20\)</span></td>
</tr>
<tr class="odd">
<td><span class="math inline">\(5\)</span></td>
<td><span class="math inline">\(15\sim20\)</span></td>
<td><span class="math inline">\(n≤10^{14}，m≤10^6\)</span></td>
<td><span class="math inline">\(30\)</span></td>
</tr>
</tbody>
</table>
</div>
<div class="note warning"><p>为描述方便，使用 0 代表无圣盾的胖头鱼， 1 代表有圣盾的胖头鱼。即，局面可以使用一串 0-1 串表示。</p>
</div>
<div class="note success"><p>考虑一个局面：有 n 个 0 ， m 个 1（<code>000000000000011111111</code>）。 - 如果一次操作作用在 0 上，那么会使其死亡 局面变成有（n - 1）个 0， m 个 1。其概率为 <span class="math inline">\(\frac{n}{n + m}\)</span>。 - 如果一次操作作用在 1 上，那么会使其死亡 局面变成有 1 个 0， (n + m) 个 1。其概率为 <span class="math inline">\(\frac{m}{n + m}\)</span>。 设: 一个局面的期望结束操作步数函数为 <span class="math inline">\(f(n, m)\)</span> 。特殊的，设 有 n 个 1 的局面的期望奇数操作步数函数<span class="math inline">\(\operatorname{g}(n) = \operatorname{f}(0, n)\)</span></p>
<p>易知： <span class="math display">\[\operatorname{f}(n, m) = 1 + \frac{n}{n + m}\times\operatorname{f}(n - 1, m) + \frac{m}{n + m}\times[\ \operatorname{g}(n + m) - 1\ ]\]</span></p>
<p><span class="math display">\[\operatorname{g}(n) = 2 + \frac{1}{n}\times\operatorname{g}(n - 1) + \frac{n - 1}{n}\times[\ \operatorname{g}(n) - 1\ ]\]</span></p>
<p>化简得</p>
<p><span class="math display">\[\operatorname{g}(n) = \frac{n \times (n + 1)}{2} + n\]</span></p>
<p>最后答案就是 <span class="math inline">\(\operatorname{f}(n, m)\)</span>, 递归求解即可。</p>
</div>
<h2 id="code-1">code</h2>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">#define int long long
int inv(int x) &#123; x %&#x3D; MOD; int a &#x3D; x, b &#x3D; MOD - 2, ans &#x3D; 1; while(b) &#123; if(b &amp; 1) ans &#x3D; (ans *1ll* a) % MOD; a &#x3D; (a *1ll* a) % MOD; b &gt;&gt;&#x3D; 1; &#125; return ans; &#125;
int f(int n) &#123; n %&#x3D; MOD; return ((n) *1ll* (n + 1) % MOD * inv(2) % MOD + n) % MOD; &#125;
int g(int n) &#123; return (f(n) - 1 + MOD )% MOD; &#125;
int doit(int n, int m)&#123;
	if(m &lt;&#x3D; 0) return f(n);
	return (((n % MOD) * inv(n + m) % MOD) * g(n + m) % MOD + (m *1ll* inv(n + m) % MOD) * doit(n, m - 1) % MOD  + 1)% MOD;
&#125;
signed main()&#123;
	int n &#x3D; read(), m &#x3D; read();
	printf(&quot;%lld\n&quot;, doit(n, m));
	return 0;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h1 id="pro.-c">Pro. C</h1>
<div class="note info"><p>给出一个长度为 <span class="math inline">\(n\)</span> 的序列（保证<span class="math inline">\(A_i \in [1, 2]\)</span>）， <span class="math inline">\(m\)</span> 次操作。 - 询问操作格式为 <code>A s</code>，表示询问是否有一种散步方案使得美丽值之和为 <span class="math inline">\(s\)</span>。 - 修改操作格式为 <code>C i val</code>，表示将第 <span class="math inline">\(i\)</span> 朵花的美丽值改成 <span class="math inline">\(val(val=1\)</span> 或 <span class="math inline">\(2)\)</span>。</p>
<p>对于每一个询问，若有合法的方案，输出这个方案的左右端点位置（多种方案时输出左端点最小的方案），否则输出 <code>none</code>。</p>
<p><span class="math inline">\(\operatorname{Subtask\ 1}\ (20pts)\)</span>：对于数据点 <span class="math inline">\(1\sim 5\)</span>，满足 <span class="math inline">\(1\leq n,m\leq 1000\)</span>。</p>
<p><span class="math inline">\(\operatorname{Subtask\ 2}\ (30pts)\)</span>：对于数据点 <span class="math inline">\(6\sim 10\)</span>，满足 <span class="math inline">\(1\leq n,m\leq 2.5\times 10^5\)</span>。</p>
<p><span class="math inline">\(\operatorname{Subtask\ 3}\ (50pts)\)</span>：对于数据点 <span class="math inline">\(11\sim 15\)</span>，满足 <span class="math inline">\(1\leq n,m\leq 2\times 10^6\)</span>。</p>
<p>对于 <span class="math inline">\(100\%\)</span> 的数据，有 <span class="math inline">\(1\leq n,m\leq 2\times 10^6,0\leq s\leq 2^{31}-1\)</span>。每次修改操作时 <span class="math inline">\(i\in[1,n],val\in\{1,2\}\)</span>。</p>
<p>对于所有数据点，时间限制 <span class="math inline">\(2000\operatorname{ms}\)</span>，空间限制 <span class="math inline">\(256\operatorname{MB}\)</span>。</p>
</div>
<div class="note success"><p>留坑！</p>
</div>
<h1 id="pro.-d">Pro. D</h1>
<div class="note info"><p>有一个无限大的棋盘来下马棋。</p>
<p>有一个马最开始在 <span class="math inline">\((0,0)\)</span>，它的每一步可以走一个 <span class="math inline">\(a\times b\)</span> 的矩形（ 即能够从<span class="math inline">\((x,y)\)</span>到达 <span class="math inline">\((x\pm a,y\pm b)\)</span> 或 <span class="math inline">\((x\pm b,y\pm a)\)</span> ）。</p>
<p>若马通过上述移动方式可以到达棋盘中任意一个点，那么 <span class="math inline">\(p(a,b)=1\)</span>，否则 <span class="math inline">\(p(a,b)=0\)</span>。</p>
<p>现在 Amazing John 给你 <span class="math inline">\(T\)</span> 组询问，每组询问他会给出一个正整数 <span class="math inline">\(n\)</span>，他想知道</p>
<p><span class="math display">\[\left ( \sum_{a=1}^n\sum_{b=1}^np(a,b) \right )\bmod\ 2^{64}\]</span></p>
<p>的值。</p>
<p><strong>本题开启Subtask</strong></p>
<table>
<thead>
<tr class="header">
<th>子任务</th>
<th>数据点</th>
<th>数据范围</th>
<th>分数</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><span class="math inline">\(1\)</span></td>
<td><span class="math inline">\(1\)</span></td>
<td><span class="math inline">\(n\leq 10,T\leq5\)</span></td>
<td><span class="math inline">\(5\)</span></td>
</tr>
<tr class="even">
<td><span class="math inline">\(2\)</span></td>
<td><span class="math inline">\(2\sim 5\)</span></td>
<td><span class="math inline">\(n\leq 3000,T\leq5\)</span></td>
<td><span class="math inline">\(15\)</span></td>
</tr>
<tr class="odd">
<td><span class="math inline">\(3\)</span></td>
<td><span class="math inline">\(6\sim 10\)</span></td>
<td><span class="math inline">\(n\leq 10^5,T\leq 5\)</span></td>
<td><span class="math inline">\(15\)</span></td>
</tr>
<tr class="even">
<td><span class="math inline">\(4\)</span></td>
<td><span class="math inline">\(11\sim 15\)</span></td>
<td><span class="math inline">\(n\leq 10^7,T\leq5\)</span></td>
<td><span class="math inline">\(15\)</span></td>
</tr>
<tr class="odd">
<td><span class="math inline">\(5\)</span></td>
<td><span class="math inline">\(16\sim 18\)</span></td>
<td><span class="math inline">\(n\leq10^9,T\leq 5\)</span></td>
<td><span class="math inline">\(15\)</span></td>
</tr>
<tr class="even">
<td><span class="math inline">\(6\)</span></td>
<td><span class="math inline">\(19\sim 25\)</span></td>
<td><span class="math inline">\(n\times T\leq 10^{11},T\leq 5\)</span></td>
<td><span class="math inline">\(35\)</span></td>
</tr>
</tbody>
</table>
<p>注 1：对于 <span class="math inline">\(n\times T\geq 5*10^{10}\)</span> 的数据点，时限为 <strong>4s</strong> ，其余均为 <strong>2.5s</strong> 。且对于所有数据点，空间限制为 <strong>500MB</strong> 。</p>
<p>注 2：输出答案 <span class="math inline">\(\bmod\ 2^{64}\)</span> 即对 <strong>64位无符号整数</strong> 自然溢出。</p>
</div>
<div class="note success"><p><del>通过打表可知：</del>其中的函数 <span class="math inline">\(\operatorname{p}\)</span>， <span class="math inline">\(\operatorname{p}(a, b) = [a \perp b]\ [(a - b) \ \operatorname{mod} \ 2\ = \ 1]\)</span></p>
<p>考虑每个数字的贡献，因为 <span class="math inline">\(a\)</span> <span class="math inline">\(b\)</span> 的差为奇数 所以<span class="math inline">\(a\)</span> <span class="math inline">\(b\)</span> 的奇偶性不同。 - 对于偶数 <span class="math inline">\(x\)</span> 贡献为 <span class="math inline">\(\varphi(x)\)</span> - 对于奇数 <span class="math inline">\(x\)</span> 贡献为 <span class="math inline">\(\frac{\varphi(x)}{2}\)</span>，即 与 <span class="math inline">\(x\)</span> 互质的偶数个数。</p>
<p>答案就是： <span class="math display">\[2\times[\ \sum_{i=1}^{n}\limits{[i\ \operatorname{mod} \ 2\ = 1]\frac{\varphi(i)}{2}} + \sum_{i=1}^{n}\limits{[i\ \operatorname{mod} \ 2\ = 0]\varphi(i)}\ ]\]</span></p>
<p><strong>50pts</strong> 不知道怎么杜教筛降复杂度。</p>
</div>
<h1 id="code-2">code</h1>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">&#x2F;&#x2F; 线性筛 phi
#define ULL unsigned long long
void doit()&#123;
	int n &#x3D; read();
	ULL ans &#x3D; 0;
	for(int i &#x3D; 1; i &lt;&#x3D; n; i++)&#123;
		ans +&#x3D; (i &amp; 1) ? (phi[i] &gt;&gt; 1) : phi[i];
	&#125;
	printf(&quot;%llu\n&quot;, ans &lt;&lt; 1);
&#125;
int main()&#123;
    int T &#x3D; read(); euler(1e7 + 2); while(T--) doit(); return 0;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
]]></content>
      <categories>
        <category>比赛总结</category>
      </categories>
      <tags>
        <tag>数学</tag>
        <tag>期望</tag>
        <tag>构造</tag>
        <tag>杜教筛</tag>
      </tags>
  </entry>
  <entry>
    <title>「琐记」NOIP 2020 考前</title>
    <url>//%E3%80%8C%E7%90%90%E8%AE%B0%E3%80%8DNOIP-2020-%E8%80%83%E5%89%8D/</url>
    <content><![CDATA[<p>NOIP 考前听到的一些算法，如果 NOIP 失利，这些算法可能这辈子也学不到了……算是留下一点点纪念吧… <a id="more"></a></p>
<h2 id="分治乘法">分治乘法</h2>
<p><span class="math inline">\((A \times 10^{base} + B) \times (C \times 10^{base} + D)\)</span></p>
<p>= $ A C 10^{base + base} + (AD + BC) 10^{base} + BD$</p>
<p>= $ A C 10^{base + base} + ((A + B)(C + D) - (AC + BD)) 10^{base} + BD$</p>
<p>复杂度为 <span class="math inline">\(\mathcal{T}(n) = 3 \times \mathcal{T}(\frac{n}{2}) + \mathcal{O}(n) = \mathcal{O}(n^{\log_2{3}}) \approx \mathcal{O}(n^{1.58})\)</span></p>
<!-- more -->
<h2 id="分数规划例题">分数规划例题</h2>
<div class="note info"><p>给出一张无向图，每个边两种权值 <span class="math inline">\((a, b)\)</span> ，定义一棵树的权值为</p>
<p><span class="math display">\[\frac{\sum_{i \in T}\limits{a_i}}{\sum_{i \in T}\limits{b_i}}\]</span></p>
<p>求最大权值。</p>
</div>
<div class="note success"><p>二分答案是什么，设二分的值为 <span class="math inline">\(L\)</span>。</p>
<p><span class="math inline">\(\frac{\sum_{i \in T}\limits{a_i}}{\sum_{i \in T}\limits{b_i}} \ge L\)</span></p>
<p><span class="math inline">\(\sum_{i \in T}\limits{a_i} \ge L \times \sum_{i \in T}\limits{b_i}\)</span></p>
<p><span class="math inline">\(\sum_{i \in T}\limits{(L \times b_i - a_i)} \le 0\)</span></p>
<p>将权值赋值为 <span class="math inline">\(L \times b_i - a_i\)</span> 求最小生成树是否小于 <span class="math inline">\(0\)</span>，即可。</p>
</div>
<h2 id="国家集训队阿狸和桃子的游戏">[国家集训队]阿狸和桃子的游戏</h2>
<p>https://www.luogu.com.cn/problem/P4643</p>
<h2 id="一道防ak的好题-and-卡常数">《一道防AK的好题》 and 《卡常数》</h2>
<p>强制在线，数据加密对解题有帮助</p>
<h2 id="cdq-分治例题">CDQ 分治例题</h2>
<p>COGS 577 蝗灾</p>
<h2 id="组合数取模">组合数取模</h2>
<ul>
<li>递推一行 / 一列 考虑展开组合数通项公式，线性递推一行 / 一列</li>
<li>预处理阶乘，阶乘逆。</li>
<li>Lucas 定理</li>
<li>计算 <span class="math inline">\(n!\)</span> 中素数 <span class="math inline">\(p\)</span> 的次数 : <code>calc(n) = n / p + calc(n / p)</code></li>
<li>非素数 <code>CRT</code> 合并。</li>
</ul>
<h2 id="第-k-小子集和">第 k 小子集和</h2>
<p>给出一个大小为 <span class="math inline">\(n\)</span> 的集合，定义子集权值为子集元素之和，求第 <span class="math inline">\(k\)</span> 小子集和。 <span class="math inline">\(n \le 30\)</span>，<span class="math inline">\(k &lt; 2^{n}\)</span> <code>meet in the middle</code>。暴力求出两边 <span class="math inline">\(2^{15}\)</span> 个值，双指针合并。</p>
<h2 id="bzoj-isn">BZOJ ISN</h2>
<p>给出长度为 <span class="math inline">\(n\)</span> 的序列 <span class="math inline">\(A\)</span> ，如果 <span class="math inline">\(A\)</span> 不是递增序列，需要删除一些数字，直到为递增序列，问方案数 <span class="math inline">\(98244353\)</span>。 动态规划 + 树状数组 + 容斥原理</p>
<h2 id="pilling-up">Pilling Up</h2>
<p>NULL.</p>
]]></content>
      <categories>
        <category>琐记</category>
      </categories>
      <tags>
        <tag>题解</tag>
      </tags>
  </entry>
  <entry>
    <title>「琐记」卡特兰数</title>
    <url>//%E3%80%8C%E7%90%90%E8%AE%B0%E3%80%8D%E5%8D%A1%E7%89%B9%E5%85%B0%E6%95%B0/</url>
    <content><![CDATA[<p>卡特兰数的证明能够扩展到处理一类括号序列的问题上。不仅仅只是为了应付 <del>sb</del> 初赛。</p>
<a id="more"></a>
<h2 id="卡特兰数">卡特兰数</h2>
<h3 id="基本定义">基本定义</h3>
<p>使用 <span class="math inline">\(C(n)\)</span> 表示卡特兰数的第 <span class="math inline">\(n\)</span> 项。</p>
<p>通项： <span class="math display">\[
C(n) = \dbinom{2n}{n} - \dbinom{2n}{n-1} =\frac{1}{n+1}\dbinom{2n}{n}=\frac{1}{n+1}\sum_{i=0}^{n}\dbinom{n}{i}^2
\]</span> 递推式： <span class="math display">\[
C(n)=\sum_{i=0}^{n-1}C(i)C(n-1 - i)
\]</span></p>
<h3 id="通项的推导">通项的推导</h3>
<p>考虑通项公式的推导：</p>
<p>第 <span class="math inline">\(n\)</span> 项卡特兰数的定义之一就是 <span class="math inline">\(n\)</span> 对括号的合法配对方案。</p>
<p>将括号序列中的 <code>(</code> 看成 <code>+1</code> 将 <code>(</code> 看成 <code>-1</code> ，合法的括号序列方案不仅仅是代数和等于 <span class="math inline">\(0\)</span> 这么简单。</p>
<p>如果某一个位置的前缀和变成负数，那么这个括号是不可能合法了。</p>
<p>所以，按照上面括号向数字的映射定义，这个序列的任意一个位置的前缀和都应该不小于 <span class="math inline">\(0\)</span>。</p>
<p>可以将问题转化为从平面上 <span class="math inline">\((0, 0)\)</span> 走到 <span class="math inline">\((2n, 0)\)</span>，每一个位置都需要决策是沿着右上对角线走还是沿着右下对角线走。 走的过程中不能越过 <span class="math inline">\(y=0\)</span> 这条线。</p>
<p>考虑没有最后一条限制，方案数就是 <span class="math inline">\(\dbinom{2n}{n}\)</span>。</p>
<p>考虑哪些方案不合法，必然是到达过 <span class="math inline">\(y=-1\)</span> 这条线的方案都不合法，考虑算出这部分不合法的方案。</p>
<p>可以强制一定要穿过 <span class="math inline">\(y=-1\)</span> 这条线，只需要把终点设置为原终点 <span class="math inline">\((2n, 0)\)</span> 关于 <span class="math inline">\(y=-1\)</span> 的对称点 <span class="math inline">\((2n, -2)\)</span>，然后格路计数，考虑这样统计的所有方案一定穿过了若干次 <span class="math inline">\(y=-1\)</span> ，考虑最后一次穿过的点，到终点这一段路径全部翻着之后就是走到原终点的方案。不难发现，之前所计入的不合法方案和走到 <span class="math inline">\((2n, -2)\)</span> 的方案一一对应。</p>
<p>这样就能得到不合法的方案数为 <span class="math inline">\(\dbinom{2n}{n-1}\)</span></p>
<p>《组合数学》 中给出的证明只是把 <strong>最后一次穿越</strong> 改成了 <strong>第一次穿越</strong>，没有引入格点计数的转换，本质相同。</p>
<h3 id="应用">应用</h3>
<p>卡特兰数的几个应用如下：</p>
<ul>
<li><p><span class="math inline">\(n\)</span>对括号的合法配对方案数.</p></li>
<li><p><span class="math inline">\(n\)</span> 个节点的有根二叉树的形态数.这个对应了递推式.</p></li>
<li><p><span class="math inline">\(n\)</span> 个数入栈后出栈的排列总数</p></li>
<li><p>对凸 <span class="math inline">\(n+2\)</span> 边形进行不同的三角形分割的方案数(分割线断点仅为顶点，且分割线仅在顶点上相交)</p></li>
<li><p><span class="math inline">\(n\)</span> 层的阶梯切割为 <span class="math inline">\(n\)</span> 个矩形的切法数 <a href="https://www.luogu.com.cn/problem/P2532">P2532 [AHOI2012]树屋阶梯</a></p></li>
<li><p><span class="math inline">\(n+1\)</span> 个叶子（<span class="math inline">\(n\)</span> 个非叶子）的满二叉树形态数，这个对应了递推式.</p></li>
</ul>
<p>这里的满二叉树指满足 <strong>结点要么是叶子结点，度为0，要么是度为2的结点，不存在度为1的结点</strong> 的二叉树。</p>
<blockquote>
<p>美国以及国际上所定义的满二叉树，即 full binary tree ,和国内的定义不同，美国 NIST 给出的定义为：A binary tree in which each node has exactly zero or two children. In other words, every node is either a leaf or has two children. For efficiency, any Huffman coding is a full binary tree.</p>
</blockquote>
<p>前几项为：1,1,2,5,14,42,132</p>
<ul>
<li><a href="https://loj.ac/p/10238">BZOJ 3907 网格</a></li>
</ul>
]]></content>
      <categories>
        <category>学习总结</category>
      </categories>
      <tags>
        <tag>数学</tag>
        <tag>卡特兰数</tag>
      </tags>
  </entry>
  <entry>
    <title>「琐记」壹月 贰月 叁月</title>
    <url>//%E3%80%8C%E7%90%90%E8%AE%B0%E3%80%8D%E5%A3%B9%E6%9C%88-%E8%B4%B0%E6%9C%88/</url>
    <content><![CDATA[<p>壹月 贰月 叁月 里逛 <code>U</code> 群/水犇犇学到的一些有趣的知识。</p>
<a id="more"></a>
<h2 id="周贰">周贰</h2>
<h3 id="一个式子">一个式子</h3>
<p><span class="math display">\[
g(n) = \prod_{d|n}f(d)\ \Longleftrightarrow \ f(n)=\prod_{d|n}g(\frac{n}{d})^{\mu(d)}
\]</span></p>
<p>取完 <span class="math inline">\(\ln\)</span> 就是标准的狄利克雷卷积形式，莫比乌斯反演后 exp 即可，感觉挺有意思/CY.</p>
<h2 id="周叁">周叁</h2>
<h3 id="excrt-优化">exCRT 优化</h3>
<p>exCRT 的一种姿势，推了推式子，换了一种更好背的式子。 <span class="math display">\[
\begin{cases}
x \equiv a_1\pmod{p_1}\\\\
x \equiv a_2\pmod{p_2}
\end{cases}
\]</span> 考虑合并以上方程：</p>
<p><code>exgcd(p1, p2, t1, t2)</code> <span class="math inline">\((a_2-a_1)|(p_1, p_2)\)</span> 有解 <span class="math display">\[
x \equiv a_1 + \frac{t_1(a_2 - a_1)}{(p_1, p_2)}\times p_1 \pmod{[p1, p2]}
\]</span></p>
<p><a href="./「杂题记录」「NOI%202018」屠龙勇士">应用</a></p>
<h3 id="快速乘法">快速乘法</h3>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">inline ULL mul(ULL a, ULL b, ULL MOD)&#123; &#x2F;&#x2F; unsigned long long
    LL R &#x3D; (LL)a*b - (LL)((ULL)((long double)a * b &#x2F; MOD) * MOD);
    if(R &lt; 0) R +&#x3D; MOD;
    if(R &gt; MOD) R -&#x3D; MOD;
    return R;
&#125;
&#x2F;&#x2F; 只关心两个答案的差值，这个差值一定小于 unsigned long long 的最大值， 所以在哪个剩余系下都不重要，不管差值是什么都能还原出原始数值。 <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h3 id="卡特兰数">卡特兰数</h3>
<p><a href="./「琐记」卡特兰数">单独成文</a></p>
<h3 id="三元环与四元环计数">三元环与四元环计数</h3>
<p><a href="https://notes.sshwy.name/Tri-Four-Cycle/">黄队长博客</a></p>
<h3 id="一类维护两个有影响序列的线段树">一类维护两个有影响序列的线段树</h3>
<p>问题形如，考虑维护两个序列 <span class="math inline">\(A, B\)</span> 支持对 <span class="math inline">\(A\)</span> 做某些修改（区间加、区间乘等），还要求支持将 <span class="math inline">\(A\)</span> 的某个区间加到 <span class="math inline">\(B\)</span> 的相应位置。</p>
<p>考虑线段树上维护一个 <span class="math inline">\(n, n\ge 2\)</span> 维向量，可能需要构造一些常数加入元素矩阵来支持操作，每一次操作可以看作矩阵乘法，由于矩阵乘法具有结合律，所以这样能够保证支持标记的合并 /CY.</p>
<p>贰月 叁月 一些小到无法单独成文的知识。</p>
<!-- more -->
<h2 id="排列三维偏序">排列三维偏序</h2>
<p>可以考虑使用容斥原理转化为二维偏序。</p>
<p>先对序列两两求二维偏序，然后求和，对于任意一个数对 <span class="math inline">\((i, j)\)</span> ，合法的三位偏序会被重复计算三次，不合法的三维偏序会被计算一次。最终答案减去 <span class="math inline">\(\dbinom{n}{2}\)</span> 然后除 <span class="math inline">\(2\)</span> 即为所求。</p>
<h2 id="线性基琐记">线性基琐记</h2>
<p>一篇探讨线性基本质的<a href="https://blog.sengxian.com/algorithms/linear-basis">文章</a> 一篇阐述线性基性质的<a href="https://blog.csdn.net/a_forever_dream/article/details/83654397">文章</a></p>
<p>由于不太了解线性基本质，只能不加证明的阐述一些事实。</p>
<p>线性基有两种构建方式，准确的说，是有两种存在形式。</p>
<p>第一种构造方式： <pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">void add(LL t)&#123;
    for(int i &#x3D; _B; i &gt;&#x3D; 0; i--)&#123;
        if(!(t &amp; (1LL &lt;&lt; i))) continue;
        if(v[i]) t ^&#x3D; v[i];
        else&#123;
            for(int k &#x3D; 0; k &lt; i; k++) if(t &amp; (1LL &lt;&lt; k)) t ^&#x3D; v[k];
            for(int k &#x3D; i + 1; k &lt;&#x3D; _B; k++) if(v[k] &amp; (1LL &lt;&lt; i)) v[k] ^&#x3D; t;
            v[i] &#x3D; t;
            break;
        &#125;
    &#125;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre> 第二种构造方式： <pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">void add(LL t)&#123;
    for(int i &#x3D; _B; i &gt;&#x3D; 0; i--)&#123;
        if(!(t &amp; (1LL &lt;&lt; i))) continue;
        if(v[i]) t ^&#x3D; v[i];
        else&#123;
            v[i] &#x3D; t;
            break;
        &#125;
    &#125;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre> 区别在于第二种构造方式删除了两行 <code>for</code> 循环，本质上是在插入过程中不在维护 <strong>“线性基中存在的位对应的那一列只有一个 1”</strong> 的性质。</p>
<p>第一种构建方式使得每一位之间脱离联系，基本是支持了大部分线性基操作，如：</p>
<ul>
<li>最大值（从高位到低位依次贪心查询异或上这个基能否使得答案变优）</li>
<li>最小值（就是线性基里面的最小值）</li>
<li>第 <span class="math inline">\(k\)</span> 大值，将线性基中存在的位依次排开，按照 <span class="math inline">\(k\)</span> 的每个二进制位是否为 <span class="math inline">\(1\)</span> 选出一些位，异或起来。</li>
<li>查询是否能够异或出某个数字 <span class="math inline">\(x\)</span>，如果 <span class="math inline">\(x\)</span> 的某一位是 <span class="math inline">\(1\)</span> 那么就把 <span class="math inline">\(x\)</span> 异或上线性基上的这一位，最后判断 <span class="math inline">\(x\)</span> 是否为 <span class="math inline">\(0\)</span> 即可。</li>
</ul>
<p>第二种构建方式：</p>
<ul>
<li><p>最大值的操作相同，可以发现，从查询最大值得角度，这两种线性基的存在形式是本质相同的。</p></li>
<li><p>最小值操作相同。</p></li>
<li><p>第 <span class="math inline">\(k\)</span> 大值：由于每一位之间并没有脱离联系，所以无法单独考虑每一位，需要先转化为第一种线性基，然后进行相同的操作。</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">void rebuild() &#123;
	for(int i &#x3D; 63;i &gt;&#x3D; 0;i--)
		for(int j &#x3D; i-1;j &gt;&#x3D; 0;j--)
			if(p[i] &amp; (1LL &lt;&lt; j))
                p[i] ^&#x3D; p[j];
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li>
<li><p>但是第二种线性基支持所谓的 <strong>离线带删</strong> 。支持查询序列的某个区间的信息。详见<a href="https://www.luogu.com.cn/problem/solution/CF1100F">题解</a></p></li>
</ul>
<p>补充一些显然的小性质：</p>
<ul>
<li>线性基的结构可能与元素插入顺序有关，但是成功插入的元素数量对于相同的插入集合是唯一的。</li>
</ul>
<h2 id="一类满足结合律的矩阵乘法">一类满足结合律的矩阵乘法</h2>
<p>定义矩阵上运算 <span class="math inline">\(*\)</span> ，<span class="math inline">\(C=A*B\)</span> 满足： <span class="math display">\[
C_{i, j} = \max/\min{（A_{i, k}+B_{k,j}）}
\]</span> 可以证明 <span class="math inline">\(*\)</span> 满足结合律。</p>
<p>关于这类矩阵乘法，<strong>单位矩阵</strong> 的定义可以考虑每个运算的单位元是什么。考虑一般意义下的矩阵乘法： <span class="math display">\[
C_{i, j} = \sum_{k} A_{i, k} \times B_{k, j}
\]</span> 和一般意义下的单位矩阵（一个位置为 <span class="math inline">\(1\)</span> 当且仅当其在对角线上，其他位置为 <span class="math inline">\(0\)</span>）</p>
<p><span class="math inline">\(0\)</span> 是加法运算单位元， <span class="math inline">\(1\)</span> 是乘法运算单位元。</p>
<p>那么显然这里定义的矩阵乘法中，单位矩阵应该类似的定义成：</p>
<ul>
<li>对角线上为加法单位元 <span class="math inline">\(0\)</span></li>
<li>其他位置为 <span class="math inline">\(\min / \max\)</span> 单位元 <span class="math inline">\(\infty / -\infty\)</span></li>
</ul>
<h2 id="一个小转化">一个小转化</h2>
<p><span class="math display">\[
\text{最小权覆盖} = \text{全集} - \text{最大独立集}
\]</span></p>
<p>显然成立。</p>
<h2 id="三角矩阵的-mathcalon2-消元">三角矩阵的 <span class="math inline">\(\mathcal{O}(n^2)\)</span> 消元</h2>
<p>每次到达一行 <span class="math inline">\(i\)</span> 时，有用的值只有 <span class="math inline">\(M_{i, i}\)</span> 和 常数项，其他值都已经成零了，只需要用这两个有用值消后面的行即可，每消一行是 <span class="math inline">\(O(1)\)</span> 的。</p>
<p>一些类似三角阵的矩阵也可以完成快速消元，例如比三角阵稍微大一点点的矩阵。<a href="https://www.luogu.com.cn/problem/P4457">example</a></p>
<h2 id="轮廓线-dp">轮廓线 dp</h2>
<p>描述状态为一个类似于轮廓线的东西，类似于状压 dp ，<span class="math inline">\(0\)</span> 表示向上走，<span class="math inline">\(1\)</span> 表示向右走这样的东西。 <a href="https://www.luogu.com.cn/problem/P4363">和简单博弈结合</a></p>
<h2 id="拉格朗日插值">拉格朗日插值</h2>
<p>拉格朗日插值是真的能把多项式函数的系数插出来的。多项式多点插值能用多项式方法做到 <span class="math inline">\(\mathcal{O}(n\log n)\)</span> ，这里只记录 <span class="math inline">\(\mathcal{O}(n^2)\)</span> 的方法。</p>
<p>考虑拉格朗日插值的式子： <span class="math display">\[
f(x) = \sum_{i=1}^{n}\prod_{j \not = i}\frac{(x-x_i)}{(x_j - x_i)}y_j
\]</span> 式子中每一项的分母和 <span class="math inline">\(y_j\)</span> 都是常数项，可以平凡的求出。</p>
<p>分子上除掉 <span class="math inline">\(y\)</span> 的剩余部分都和 <span class="math inline">\(\prod_i(x-x_i)\)</span> 差一项，可以先考虑预处理出 <span class="math inline">\(\prod_{i}(x-x_i)\)</span> ，然后在每次处理点值的时候除掉某一项即可。</p>
<p>预处理：考虑乘上一个 <span class="math inline">\((x - x_i)\)</span> 多项式会发生 <del>甚么事了</del> 什么变化，相当于前移一位再加上乘 <span class="math inline">\(-x_i​\)</span> 后的多项式。暴力做即可，这里不会成为复杂度瓶颈。</p>
<p>除掉某一项：可以考虑从低到高依次还原每一项的系数。</p>
<p>如果 dp 为卷积，可以考虑构建一个生成函数后，求点值加速生成函数的卷积运算，最后再用 lagrange 把系数插出来。</p>
<p>不太好写：</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">struct LagrangeHelper&#123;
    int B0[_], B1[_];
    #define X first
    #define Y second
    void operator () (pair&lt;int, int&gt; * pts, int n, int *ret)&#123;
        for(int i &#x3D; 0; i &lt; n; i++) ret[i] &#x3D; 0;
        for(int i &#x3D; 0; i &lt; n; i++) B0[i]  &#x3D; 0; B0[0] &#x3D; 1;
        for(int i &#x3D; 1; i &lt;&#x3D; n; i++)&#123; &#x2F;&#x2F; \prod&#123; (x - x_i) &#125;
            for(int j &#x3D; n; j &gt;&#x3D; 0; j--)&#123;
                B0[j] &#x3D; (B0[j] *1ll* (MOD -pts[i].X) % MOD + (j &#x3D;&#x3D; 0 ? 0 : B0[j - 1])) % MOD;
            &#125;
        &#125;
        for(int i &#x3D; 1; i &lt;&#x3D; n; i++)&#123;
            int d &#x3D; pts[i].Y;
            for(int j &#x3D; 1; j &lt;&#x3D; n; j++)&#123;
                if(i &#x3D;&#x3D; j) continue;
                d &#x3D; d *1ll* inv(pts[i].X - pts[j].X) % MOD;
            &#125;
            for(int j &#x3D; 0; j &lt; n; j++) B1[j] &#x3D; B0[j];
            for(int j &#x3D; 0; j &lt; n; j++) &#123;
                if(j &#x3D;&#x3D; 0) B1[j] &#x3D; B1[j] *1ll* inv(-pts[i].X) % MOD;
                else       B1[j] &#x3D; (B1[j] - B1[j - 1] + MOD) *1ll* inv(-pts[i].X) % MOD;
            &#125;
            for(int j &#x3D; 0; j &lt; n; j++) ret[j] &#x3D; (ret[j] + B1[j] *1ll* d % MOD) % MOD;
        &#125;
    &#125;
    #undef X
    #undef Y
&#125;d;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
]]></content>
      <categories>
        <category>琐记</category>
      </categories>
      <tags>
        <tag>线性基</tag>
        <tag>琐记</tag>
        <tag>三维偏序</tag>
        <tag>高斯消元</tag>
        <tag>拉格朗日插值</tag>
        <tag>exCRT</tag>
        <tag>三元环计数</tag>
      </tags>
  </entry>
  <entry>
    <title>「琐记」字符串复习</title>
    <url>//%E3%80%8C%E7%90%90%E8%AE%B0%E3%80%8D%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%A4%8D%E4%B9%A0/</url>
    <content><![CDATA[<p>后缀数组的一次复习和整理，大部分精简自oi-wiki。</p>
<a id="more"></a>
<h1 id="琐记字符串复习">「琐记」字符串复习</h1>
<h2 id="sa-后缀数组">SA 后缀数组</h2>
<p>整理自 OI-Wiki.</p>
<h3 id="应用">应用</h3>
<h4 id="两字串最长公共前缀长度">两字串最长公共前缀长度</h4>
<p><span class="math display">\[
\min\{\ \operatorname{height}[\ \operatorname{rk}[i] + 1, \operatorname{rk}[j]\ ]\ \}
\]</span></p>
<h5 id="比较字串大小关系">比较字串大小关系</h5>
<p>不妨设：<span class="math inline">\(A=S[a..b], B=S[c..d]\)</span></p>
<p><span class="math display">\[
A &lt; B\iff
\begin{cases}
|A| &amp;&lt; &amp;|B|, &amp;|\mathbb{LCP}(A, B)| \ge \min(|A|, |B|)\\
\operatorname{rk}[a] &amp;&lt; &amp;\operatorname{rk}[b],&amp;otherwise.
\end{cases}
\]</span></p>
<h5 id="不同子串的数目">不同子串的数目</h5>
<p><span class="math display">\[
\frac{n (n + 1)}{2} - \sum_{i=2}^{n}\operatorname{height}[i]
\]</span></p>
<h5 id="出现至少-k-次的子串-最大长度">出现至少 <span class="math inline">\(k\)</span> 次的子串 最大长度</h5>
<p>如果某个子串出现了 <span class="math inline">\(k\)</span> 次，那么一定有连续（后缀排序后）<span class="math inline">\(k\)</span> 个后缀的 <span class="math inline">\(\mathbb{LCP}\)</span> 是其超串。 <span class="math display">\[
\max_{i}\{ \min_{j=i + 1}^{i + k}\{\operatorname{height}[j]\} \}
\]</span></p>
<h5 id="最长-不重叠出现两个次以上的子串">最长 不重叠出现两个次以上的子串</h5>
<p>考虑二分一个值 <span class="math inline">\(|S|\)</span> 表示子串长度。 考虑根据 <span class="math inline">\(|S|\)</span> 把 <span class="math inline">\(Height\)</span> 数组断成若干段。每一段内的 <span class="math inline">\(\operatorname{height}\)</span> 的值都 <span class="math inline">\(\ge |S|\)</span> ，检查每一段内的所有值的下标，判断是否重复。</p>
<h5 id="noi2015品酒大会"><a href="https://loj.ac/p/2133">「NOI2015」品酒大会</a></h5>
<p>如果从大到小枚举 <span class="math inline">\(r\)</span> ，后缀排好序后，合法的串一定挨在一起，并且随着 <span class="math inline">\(r\)</span> 的减小，合法的区间会扩大、合并。</p>
<p>方案和最大值都好维护，同时维护最大值、次大值/最小值、次小值（存在负数），就可以在每次合并的过程中更新答案。</p>
<p>最大、次大、最小和次小不好维护…</p>
<ul>
<li>可能某个值不存在，不能使用 -1 表示不存在，可以考虑特殊化一下，特别定义某个值表示不存在，不是很可能冲突。</li>
<li>合并的时候讨论比较麻烦，只需要考虑把这些数字都放入一个 vector ，排序去重后一一取出即可，可以避免讨论。</li>
</ul>
<h5 id="ahoi2013-差异"><a href="https://loj.ac/p/2377">「AHOI2013」 差异</a></h5>
<p>给出长度为 <span class="math inline">\(n\)</span> 的字符串 <span class="math inline">\(S\)</span> ，<span class="math inline">\(T_i\)</span> 表示从字符 <span class="math inline">\(i\)</span> 开始的后缀，求： <span class="math display">\[
\sum_{1 \le i \le j \le n}\limits{ |T_i| + |T_j| - 2 |\mathbb{LCP}(T_i, T_j)| }
\]</span></p>
<p>因为<span class="math inline">\(|\mathbb{LCP}(T_i, T_j)|\)</span> 直接对应后缀排序里的值，考虑对这个值单调栈求一下取值为其的区间，算贡献即可。</p>
<h3 id="模板">模板</h3>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">const int _ &#x3D; 1e6 + 100;
int sa[_], rk[_], ht[_];
void Suffix_Array(char *S, int n)&#123;
	static int oldrk[_], cnt[_], id[_], px[_];
	int m &#x3D; max(n, 300), i, p, T, k;
	for(i &#x3D; 1; i &lt;&#x3D; n; i++) cnt[rk[i] &#x3D; S[i]] ++;
	for(i &#x3D; 1; i &lt;&#x3D; m; i++) cnt[i] +&#x3D; cnt[i - 1];
	for(i &#x3D; n; i &gt;&#x3D; 1; i--) sa[cnt[rk[i]] -- ] &#x3D; i;
	for(T &#x3D; 1; T &lt;&#x3D; n; T &lt;&lt;&#x3D; 1)&#123;
		memset(cnt, 0, sizeof(int) * (m + 5));
		memcpy(id, sa, sizeof(int) * (n + 5));
		for(i &#x3D; 1; i &lt;&#x3D; n; i++) cnt[px[i] &#x3D; rk[id[i] + T]] ++;
		for(i &#x3D; 1; i &lt;&#x3D; m; i++) cnt[i] +&#x3D; cnt[i - 1];
		for(i &#x3D; n; i &gt;&#x3D; 1; i--) sa[cnt[px[i]] --] &#x3D; id[i];

		memset(cnt, 0, sizeof(int) * (m + 5));
		memcpy(id, sa, sizeof(int) * (n + 5));
		for(i &#x3D; 1; i &lt;&#x3D; n; i++) cnt[px[i] &#x3D; rk[id[i]]]++;
		for(i &#x3D; 1; i &lt;&#x3D; m; i++) cnt[i] +&#x3D; cnt[i - 1];
		for(i &#x3D; n; i &gt;&#x3D; 1; i--) sa[cnt[px[i]] -- ] &#x3D; id[i];

		memcpy(oldrk, rk, sizeof(int) * (n + 5));
		for(p &#x3D; 0, i &#x3D; 1; i &lt;&#x3D; n; i++)&#123;
			if(oldrk[sa[i]] &#x3D;&#x3D; oldrk[sa[i - 1]]
			&amp;&amp; oldrk[sa[i] + T] &#x3D;&#x3D; oldrk[sa[i - 1] + T])
				 rk[sa[i]] &#x3D; p;
			else rk[sa[i]] &#x3D; ++p;
		&#125;
		if(p &#x3D;&#x3D; n) break;
	&#125;
	for(k &#x3D; 0, i &#x3D; 1; i &lt;&#x3D; n; i++)&#123;
		if(k) k--;
		while(S[i + k] &#x3D;&#x3D; S[sa[rk[i] - 1] + k] &amp;&amp; k &lt;&#x3D; n) k++;
		ht[rk[i]] &#x3D; k;
	&#125;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
]]></content>
      <categories>
        <category>学习总结</category>
      </categories>
      <tags>
        <tag>字符串</tag>
        <tag>后缀数组</tag>
      </tags>
  </entry>
  <entry>
    <title>退役笔记 生涯回忆 NOI 2021</title>
    <url>//%E9%80%80%E5%BD%B9%E7%AC%94%E8%AE%B0-%E7%94%9F%E6%B6%AF%E5%9B%9E%E5%BF%86/</url>
    <content><![CDATA[<div class="note info"><p>Hi! new Shu_Yu_Mo</p>
</div>
<a id="more"></a>
<h2 id="序">序</h2>
<p>NOI 2021 二试结束了，查完成绩，感觉低的无法接受，一个一个点的测了一遍，貌似拿不到分都有理有据…申诉也没什么用了。回去之后一直躺倒了黑天，决定出去买明天疏散路上喝的水，受台风影响，余姚连续下了好几天的雨。今天雨停了，蛙鸣遍野，蝉声震耳。记得我下定决心准备省选的时候，也是这样一个盛夏。一年过去了。</p>
<p>想了很久有没有必要写这样一篇磨牙的文章，好像从来没有在博客里面放一些有温度的文字。渐渐喜欢那种严谨的，富有理性愉悦的文字，于是准备省选期间写的文章好像都在追求所谓的“形式化”、“严谨”、“优雅”，而没有什么温度。前两天翻看自己高一写的文章，莫名感觉到一股温暖。相比那时，我感觉我变得越来越冷血了，那就从现在开始，渐渐找回我的情感吧。</p>
<p>其实我准备省选的时候，很少谈论情怀、梦想、希望之类的话题，我好像在刻意的把自己打造成一个学习机器，而且准备省选的整个过程都是我独自走下来的，也没有什么人可以谈。</p>
<p>已经不太会写什么好文章了，那就写一篇流水账，仅仅是记录一下这一段时间，我想我应该是不会忘记的，那写给后人批判应该也是挺有意义的？</p>
<h2 id="田园时代">田园时代</h2>
<p>我一直把初中学竞赛的经历称之为田园时代，没有升学的压力，不需要功利的学习一个又一个的算法，不需要为了赶时间去背代码，学竞赛的每一天都很快乐…</p>
<div class="group-picture"><div class="group-picture-row"><div class="group-picture-column"><img src="/oi-blog/images-last/NOIP2016.jpg" alt="NOIP2016" /></div><div class="group-picture-column"><img src="/oi-blog/images-last/NOIP2017.jpg" alt="NOIP2017" /></div></div><div class="group-picture-row"><div class="group-picture-column"><img src="/oi-blog/images-last/NOIP2017-2.jpg" alt="NOIP2017" /></div><div class="group-picture-column"><img src="/oi-blog/images-last/NOIP2018.jpg" alt="NOIP2018" /></div></div><div class="group-picture-row"><div class="group-picture-column"><img src="/oi-blog/images-last/re.jpg" alt="王逸飞家阁楼备赛" /></div><div class="group-picture-column"><img src="/oi-blog/images-last/zzpass.jpg" alt="市一中自招通过" /></div></div></div>
<h2 id="省选">省选</h2>
<p>感觉准备省选是我信息竞赛生涯的一个分水岭，</p>
]]></content>
  </entry>
  <entry>
    <title>「学习总结」基本卷积算法</title>
    <url>//%E3%80%8C%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93%E3%80%8D%E5%9F%BA%E6%9C%AC%E5%8D%B7%E7%A7%AF%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<div class="note warning"><p>「做多项式题就像嗑药，出多项式题就像贩毒。」 —— 某福建知名OI选手</p>
<p>学了学红日bn一年前玩剩下的东西。</p>
</div>
<p>倒是扩展了 FWT 的一种思路吧。</p>
<a id="more"></a>
<h1 id="基本卷积算法">基本卷积算法</h1>
<h2 id="加法卷积">加法卷积</h2>
<p>用于解决形如以下问题： 给出两个序列 <span class="math inline">\(A, B\)</span>。求两个序列的卷积序列 <span class="math inline">\(C\)</span>，其中序列 <span class="math inline">\(C\)</span> 的定义如下 <span class="math display">\[
\begin{equation} \label{QWQ}
C_k = \sum_{i+j=k}A_i \times B_j
\end{equation}
\]</span> 序列可以看作是函数的系数表示法，所以我们可以定义函数 $F(x) = _{i 0} A_i x^i $ 和函数 <span class="math inline">\(G(x)= \sum_{i \ge 0} B_i x^i\)</span> 分别对应序列 <span class="math inline">\(A, B\)</span> 的两个函数。</p>
<p>类似的，还可以定义序列 <span class="math inline">\(C\)</span> 对应函数 <span class="math inline">\(T(x) = \sum_{i \ge 0} C_i x^i\)</span>。</p>
<p>注意到这种定义就是将序列的第 <span class="math inline">\(i\)</span> 个数当作多项式函数的第 <span class="math inline">\(i\)</span> 次系数。</p>
<p>注意到 <span class="math display">\[
\begin{equation} \label{QAQ}
T(x)=F(x) \times G(x)
\end{equation}
\]</span> 这个是后面卷积方法的核心工作原理。本质上是 建立了 <strong>序列运算</strong> 与其对应 <strong>函数（多项式）运算</strong> 的一种联系。</p>
<p>注意到 <span class="math inline">\((\ref{QAQ})\)</span> 也可以理解为对于任意常数 <span class="math inline">\(a\)</span>，总有 <span class="math inline">\(T(a)=F(a) \times G(a)\)</span>。</p>
<p>也就是说，如果我们知道了 <span class="math inline">\(G(x)\)</span> 和 <span class="math inline">\(F(x)\)</span> 在 <span class="math inline">\(a\)</span> 处的函数值，那么他们相乘就能够得到 <span class="math inline">\(T(x)\)</span> 在 <span class="math inline">\(a\)</span> 处的函数值。</p>
<p>考虑如果存在一种变换，能够快速计算 <span class="math inline">\(G(x)\)</span> 和 <span class="math inline">\(F(x)\)</span> 在某些特定自变量 <span class="math inline">\(\\{a_1, a_2, a_3,\cdots a_k\\}\)</span> 处的函数值，那么就能快速算出 <span class="math inline">\(T(x)\)</span> 在这些自变量处的函数值。</p>
<p>如果存在某种逆变换，能够快速将函数在某些自变量处的函数值转换成每一次项的系数，那么就能够求出 <span class="math inline">\(T(x)\)</span> 的系数（即序列 <span class="math inline">\(C\)</span>）了。</p>
<p>总的来说，希望存在一种序列上变换 <span class="math inline">\(\operatorname{FFT}(T)\)</span>，使得 <span class="math display">\[
\begin{equation}
\operatorname{FFT}(C) = \operatorname{FFT}(A \times B) = \operatorname{FFT}(A) \cdot \operatorname{FFT}(B)
\end{equation}
\]</span> 其中 <span class="math inline">\(\times\)</span> 表示序列加法卷积 <span class="math inline">\((\ref{QWQ})\)</span>，<span class="math inline">\(\cdot\)</span> 表示对应位置相乘。</p>
<p>并且这种变换存在逆变换，能够将 <span class="math inline">\(\operatorname{FFT}(C)\)</span> 还原为 <span class="math inline">\(C\)</span> 。</p>
<p>通过上述描述可以发现，对于一个函数 <span class="math inline">\(G(x)\)</span> 来说，其表示成序列的方式有两种：一种是构造序列，使得序列第 <span class="math inline">\(i\)</span> 位为多项式函数 <span class="math inline">\(G(x)\)</span> 的第 <span class="math inline">\(i\)</span> 次项系数。另一种是指定一系列取值<span class="math inline">\(\\{a_1, a_2, a_3,\cdots a_k\\}\)</span> ，分别带入函数中，得到的函数值依次排开，成为一个序列。我们称前者为函数 <span class="math inline">\(G(x)\)</span> 的系数表示法，称后者为其点值表示法。而我们所希望的变换就是能够实现函数的<strong>系数表示法</strong> 与 <strong>点值表示法</strong> 相互转化。</p>
<p>因为 两函数相乘时，其对应的系数表示法的序列就是在做卷积操作，对应了我们希望的运算，但是这个并不能快速计算。而两函数相乘，对于点值表示法，就仅仅是对应位置相乘，这个可以快速计算。所以可以考虑如果能够快速实现 <em>函数的<strong>系数表示法</strong> 与 <strong>点值表示法</strong> 相互转化</em>。就能够解决上述问题。可以先转化为点值表示法，然后对点相乘后，再转换为系数表示法，就相当于对序列做卷积。</p>
<h3 id="快速傅里叶变换fft">快速傅里叶变换（FFT）</h3>
<p><strong>快速傅里叶变换</strong> 就是一种满足上述条件的变换。她可以使得函数在系数表示法与点值表示法之间转换。 时间复杂度为 <span class="math inline">\(\mathcal{O}(n \log n)\)</span>。</p>
<p>考虑上述过程中，并没有限制点值表示法中的点值应该取哪些值，所以可以考虑取一些有丰富性质的数字，利用这些性质加速运算。</p>
<p>对于 FFT 我们取 <strong>n次单位根</strong> 来加速运算。<span class="math inline">\(n\)</span> 为待变换序列长度。</p>
<h4 id="单位根">单位根</h4>
<p><em>n</em> 次单位根记作 <span class="math inline">\(\omega_n\)</span>。其定义为 <span class="math inline">\(\omega_n = \cos{\frac{2\pi}{n}} + \mathrm{i}\sin{\frac{2\pi}{n}}\)</span>，这是一个虚数。虚数可以通过向量来表示，而 <span class="math inline">\(\omega_n\)</span> 就可以考虑为一个模长为 <span class="math inline">\(1\)</span> ，与 <span class="math inline">\(x\)</span> 轴夹角为 <span class="math inline">\(\frac{2\pi}{n}\)</span> 的向量。易知， <span class="math inline">\(\omega_n^k=\cos{\frac{2\pi k}{n}} + \mathrm{i}\sin{\frac{2\pi k}{n}}\)</span>。</p>
<p>他有如下性质</p>
<ul>
<li><span class="math inline">\(\omega_n^k=\omega_{2n}^{2k}\)</span></li>
<li><span class="math inline">\(\omega_n^{k + \frac{n}{2}}=-\omega_{n}^{k}\)</span></li>
<li><span class="math inline">\(\omega_n^0=\omega_n^n=1\)</span></li>
</ul>
<p>这些性质都可以通过其定义得知。</p>
<p>考虑将 <span class="math inline">\(\omega_n^0, \omega_n^1, \omega_n^2, \cdots, \omega_n^{n-1}\)</span> 带入函数，得到点值即可。</p>
<h4 id="蝴蝶操作">蝴蝶操作</h4>
<p>分别抽取函数 <span class="math inline">\(F(x)\)</span> 的奇、偶次项系数构成两个新函数 <span class="math inline">\(G(x), H(x)\)</span>。 易知: <span class="math display">\[
F(x) = G(x^2) + xH(x^2)
\]</span> 即 <span class="math display">\[
\begin{equation}
F(\omega_n^k) = G(\omega_{n/2}^k) + \omega_n^k H(\omega_{n/2}^k)
\end{equation}
\]</span> <span class="math display">\[
\begin{equation}
F(\omega_n^{k + n/2}) = G(\omega_{n/2}^k) - \omega_n^k H(\omega_{n/2}^k)
\end{equation}
\]</span></p>
<p>划分了子问题，分治即可。这里必须保证 <span class="math inline">\(n = 2^k\)</span>，<span class="math inline">\(k \in \mathbb{N}\)</span></p>
<h4 id="逆变换">逆变换</h4>
<p>单位根还有如下性质 <span class="math display">\[
\begin{equation}
\sum_{i=0}^{n-1}\left(\omega_n^k\right)^i=
\begin{cases}
0&amp; {k \not= 0}\\\\
n&amp; {k = 0}
\end{cases}
\end{equation}
\]</span> 第二种情况显然，第一种情况根据等比数列求和公式可以得证。</p>
<p>根据上述性质，我们只需要取单位根为之前的倒数，然后跑一遍 <span class="math inline">\(\operatorname{FFT}\)</span> 对结果除以 <span class="math inline">\(n\)</span> 即可。 不会推QAQ。</p>
<h3 id="快速数论变换ntt">快速数论变换（NTT）</h3>
<p>FFT 需要实数运算，对精度要求较高。且无法解决常见的取模要求。</p>
<p>注意到 <span class="math inline">\(FFT\)</span> 中所依赖的是一个复平面上的单位圆，其实剩余系本身就可以看作一个环。可以考虑在剩余系下寻找具有与单位根性质类似的数字。</p>
<p>设质数 <span class="math inline">\(P\)</span> 的原根为 <span class="math inline">\(g\)</span>。那么 <span class="math inline">\(\forall k \in [0, \varphi(P) - 1],k \in \mathbb{N},g^{k}\)</span>，可以表示 <span class="math inline">\(P\)</span> 的剩余系中除 <span class="math inline">\(0\)</span> 以外的任何数字，显然可表示的数字有 <span class="math inline">\(P-1\)</span> 个。</p>
<div class="note warning"><p>以下关于剩余系类比复平面单位圆的描述由笔者口胡，不保证语言严谨。</p>
</div>
<p>在 <span class="math inline">\(\operatorname{FFT}\)</span> 中取单位根的方式本质上实在均分复平面上单位圆。而 <span class="math inline">\(\operatorname{NTT}\)</span> 中，如果将 <span class="math inline">\(g^k\)</span> 依次排成一个环，即剩余系，我们一样可以通过均分这个环，来取剩余系下的“单位根”，来获得和之前复平面单位根 类似性质的一些数。显然，这里需要保证在我们均分单位圆的过程中，每个值都能取到，也就是 <span class="math inline">\(n | \varphi(P)\)</span>，即 <span class="math inline">\(n | (P-1)\)</span>。</p>
<p>所以这里的剩余系取值有一定要求，变换中所要求的 <span class="math inline">\(n\)</span> 都是 <span class="math inline">\(2\)</span> 的次幂，需要保证 <span class="math inline">\(P-1\)</span> 中 <span class="math inline">\(2\)</span> 的幂次应该足够大。（文末附<a href="./#质数表">质数取值表</a>）</p>
<p>设 <span class="math inline">\(P-1 = q\times n\)</span>。</p>
<p>考虑将 <span class="math inline">\(g_n=g^q\)</span> 当作 <span class="math inline">\(\omega_n\)</span> 即可，根据上面的描述，<span class="math inline">\(\omega_n\)</span> 所具有的性质，<span class="math inline">\(g_{n}\)</span> 显然成立。这里的 <span class="math inline">\(q\)</span> 可以想成等分环时的单位角度。</p>
<p>关于 <strong>蝴蝶操作</strong> 和 <strong>逆变换</strong> 的手法和 <span class="math inline">\(\operatorname{FFT}\)</span> 是一样的。</p>
<h2 id="位运算卷积">位运算卷积</h2>
<p>类似地，定义位运算序列卷积。 给出两个序列 <span class="math inline">\(A, B\)</span>。求两个序列的卷积序列 <span class="math inline">\(C\)</span>，其中序列 <span class="math inline">\(C\)</span> 的定义如下 <span class="math display">\[
\begin{equation} \label{QWQWQ}
C_k = \sum_{i\oplus j=k}A_i \times B_j
\end{equation}
\]</span> 可以仿照上述思路，构造一种作用在序列上的变换 <span class="math inline">\(\operatorname{FWT}\)</span>，使得其满足 <span class="math display">\[
\begin{equation} \label{FWT}
\operatorname{FWT}(C) = \operatorname{FWT}(A \oplus B) = \operatorname{FWT}(A) \cdot \operatorname{FWT}(B)
\end{equation}
\]</span> <span class="math inline">\(A \oplus B\)</span> 中的 <span class="math inline">\(\oplus\)</span> 指某种位运算。指下标的运算方式。即 <span class="math inline">\((\ref{QWQWQ})\)</span> 中的 <span class="math inline">\(i\oplus j=k\)</span>。</p>
<h3 id="快速沃尔什变换fwt">快速沃尔什变换（FWT）</h3>
<p>考虑分治处理，令 <span class="math inline">\(A_0\)</span> 为 <span class="math inline">\(A\)</span> 的前一半， <span class="math inline">\(A_1\)</span> 为 <span class="math inline">\(A\)</span> 的后一半。可以考虑如果已经求出了 <span class="math inline">\(\operatorname{FWT}(A_0)\)</span> 和 <span class="math inline">\(\operatorname{FWT}(A_1)\)</span>，如何求出 <span class="math inline">\(\operatorname{FWT}(A)\)</span>。</p>
<p>顺便定义函数 <span class="math inline">\(\operatorname{merge}(A, B)\)</span> 表示将序列 <span class="math inline">\(A, B\)</span> 直接前后拼接，返回拼接后的大序列。例如 <span class="math inline">\(A = \operatorname{merge}(A_0, A_1)\)</span>。</p>
<h4 id="或运算">或运算</h4>
<p>考虑如何构造 <span class="math inline">\(\operatorname{FWT}\)</span> 的方式，使得： <span class="math display">\[
\begin{equation} \label{FWTORBASE}
\operatorname{FWT}(A | B) = \operatorname{FWT}(A) \cdot \operatorname{FWT}(B)
\end{equation}
\]</span> 对于或运算卷积，直接给出结论。我们定义当前情况下的 <span class="math inline">\(\operatorname{FWT}\)</span> 的运算规则如下。 <span class="math display">\[
\begin{equation} \label{FWTOR}
\operatorname{FWT}(A) = \operatorname{merge}(\operatorname{FWT}(A_0), \operatorname{FWT}(A_0) + \operatorname{FWT}(A_1))
\end{equation}
\]</span> 其中 <span class="math inline">\(+\)</span> 为序列对应位置相加。</p>
<p>现在证明：已知 <span class="math inline">\((\ref{FWTOR})\)</span>， <span class="math inline">\((\ref{FWTORBASE})\)</span> 成立。</p>
<p>将 <span class="math inline">\(\operatorname{FWT}\)</span> 简记为 <span class="math inline">\(\operatorname{F}\)</span>，将 <span class="math inline">\(\operatorname{merge}(A, B)\)</span> 简记为 <span class="math inline">\([A, B]\)</span></p>
<p>首先试图从等式左边开始推导： <span class="math display">\[
\begin{split}
\operatorname{F}(A) \cdot \operatorname{F}(B) &amp;= \left[\ \operatorname{F}(A_0)\ \ ,\ \  \operatorname{F}(A_0) + \operatorname{F}(A_1)\right] \cdot \left[\operatorname{F}(B_0), \operatorname{F}(B_0) + \operatorname{F}(B_1)\ \right] \\\\
&amp;=\left[\ \operatorname{F}(A_0) \cdot\operatorname{F}(B_0)\ \ ,\ \   (\operatorname{F}(A_0) + \operatorname{F}(A_1)) \cdot (\operatorname{F}(B_0) + \operatorname{F}(B_1))\  \right]\\\\
&amp;=\left[\ \operatorname{F}(A_0) \cdot\operatorname{F}(B_0)\ \ ,\ \  \operatorname{F}(A_0)\cdot\operatorname{F}(B_0) + \operatorname{F}(A_0)\cdot\operatorname{F}(B_1) \\\\ + \operatorname{F}(A_1)\cdot\operatorname{F}(B_0) + \operatorname{F}(A_1)\cdot  \operatorname{F}(B_1)\ \right]\\\\
\end{split}
\]</span></p>
<p>再从等式右边开始推导，先假设当序列长度为 <span class="math inline">\(\frac{|A|}{2}\)</span> 时，根据 <span class="math inline">\((\ref{FWTOR})\)</span> 能够使得 <span class="math inline">\((\ref{FWTORBASE})\)</span> 成立。 <span class="math display">\[
\begin{split}
\operatorname{F}(A\ |\ B) &amp;= \operatorname{F}([A_0|B_0, A_0|B_1 + A_1|B_0 + A_1 | B_1]) \\\\
&amp;=[\operatorname{F}(A_0|B_0), \operatorname{F}(A_0|B_1) + \operatorname{F}(A_1|B_0) + \operatorname{F}(A_1 | B_1) + \operatorname{F}(A_0|B_0)]\\\\
&amp;=\left[\ \operatorname{F}(A_0) \cdot\operatorname{F}(B_0)\ \ ,\ \  \operatorname{F}(A_0)\cdot\operatorname{F}(B_0) + \operatorname{F}(A_0)\cdot\operatorname{F}(B_1) \\\\ + \operatorname{F}(A_1)\cdot\operatorname{F}(B_0) + \operatorname{F}(A_1)\cdot  \operatorname{F}(B_1)\ \right]\\\\
\end{split}
\]</span></p>
<p>我们假设结论在 序列长度为 <span class="math inline">\(\frac{|A|}{2}\)</span> 时 成立，能够推出 序列长度为 <span class="math inline">\(|A|\)</span> 时 成立，就能够推出上述结论在任何情况下均适用（数学归纳法）。</p>
<p>考虑如何构造逆变换 <span class="math inline">\(\operatorname{iFWT}\)</span> 的运算规则。 相当于每一步都反向操作。</p>
<p>因为： <span class="math display">\[
\begin{equation}
\operatorname{FWT}(A) = \operatorname{merge}(\operatorname{FWT}(A_0), \operatorname{FWT}(A_0) + \operatorname{FWT}(A_1))
\end{equation}
\]</span> 相当于，现在已经得到了 <span class="math inline">\(A_0&#39; = A_0\)</span> ，<span class="math inline">\(A_1&#39; = A_0 +A_1​\)</span> 那么易知： <span class="math display">\[
A_0 = A_0&#39;
\]</span> <span class="math display">\[
A_1 =  A_1&#39; - A_0&#39;
\]</span></p>
<p>因此，逆变换就是： <span class="math display">\[
\begin{equation}
\operatorname{iFWT}(A)=\operatorname{merge}(\operatorname{iFWT}(A_0), \operatorname{iFWT}(A_1) - \operatorname{iFWT}(A_0))
\end{equation}
\]</span></p>
<p>需要注意的是： <span class="math display">\[
\operatorname{FWT}(A)_i = \sum_{j \subseteq i}A_j
\]</span></p>
<h4 id="与运算">与运算</h4>
<p><span class="math display">\[
\begin{equation}
\operatorname{FWT}(A) = \operatorname{merge}(\operatorname{FWT}(A_0) + \operatorname{FWT}(A_1), \operatorname{FWT}(A_1))
\end{equation}
\]</span> <span class="math display">\[
\begin{equation}
\operatorname{iFWT}(A)=\operatorname{merge}(\operatorname{iFWT}(A_0) - \operatorname{iFWT}(A_1),\operatorname{iFWT}(A_1) )
\end{equation}
\]</span></p>
<p>需要注意的是： <span class="math display">\[
\operatorname{FWT}(A)_i = \sum_{i \subseteq j}A_j
\]</span></p>
<h4 id="一般方法">一般方法</h4>
<p>构造的逆运算为解方程。</p>
<p>考虑如何根据一种位运算，求出一种合法的 $ /  $ 构造方式。这里的<strong>合法</strong>指这种构造方式满足 <span class="math inline">\((\ref{FWT})\)</span></p>
<p>考虑某种位运算 <span class="math inline">\(\oplus\)</span> 的 <span class="math inline">\(\operatorname{FWT}​\)</span> 应该是什么样子。根据上面的两个例子，可以设出如下式子： <span class="math display">\[
\operatorname{F}(A) = \operatorname{merge}(a \cdot\operatorname{F}(A_0) + b \cdot\operatorname{F}(A_1)\ ,c \cdot\operatorname{F}(A_0) + d \cdot\operatorname{F}(A_1) )
\]</span> 这里的 <span class="math inline">\(a, b, c, d\)</span> 为常数，“<span class="math inline">\(\cdot\)</span>” 为普通乘法。</p>
<p>为了方便，设 <span class="math inline">\(U=\operatorname{F}(A_0)\)</span>，<span class="math inline">\(V=\operatorname{F}(A_1)\)</span>， <span class="math inline">\(W=\operatorname{F}(B_0)\)</span>，<span class="math inline">\(X=\operatorname{F}(B_1)\)</span></p>
<p>则： <span class="math display">\[
\begin{equation} \label{FWTCOM}
\begin{split}
\operatorname{F}(A)\cdot\operatorname{F}(B)&amp;=[aU+bV, cU+dV]\cdot[aW+bX, cW+dX]\\\\
&amp;=[a^2UW + 2ab(UX + VW)+b^2VX, c^2UW + 2cd(UX + VW)+d^2VX \ \ ]
\end{split}
\end{equation}
\]</span></p>
<p>这里以<strong>异或</strong>为例，因为序列是中间分成两个序列，不妨设序列长度均为 <span class="math inline">\(2\)</span> 的若干次方，那么分开之后，其下标的最高位一定是前一半为 0 后一半为 1，根据异或的运算规则，哪些元素组合起来能够什么样的最高位即可。</p>
<p>假设上式在 序列长度为 <span class="math inline">\(\frac{|A|}{2}​\)</span> 时是成立的。则： <span class="math display">\[
\begin{split}
\operatorname{F}(A \oplus B)&amp;=\operatorname{F}([A_0\oplus B_0 + A_1\oplus B_1, A_0\oplus B_1+A_1\oplus B_0])\\\\
&amp;=[a\operatorname{F}(A_0\oplus B_0 + A_1\oplus B_1) + b\operatorname{F}(A_0\oplus B_1+A_1\oplus B_0), c\operatorname{F}(A_0\oplus B_0 + A_1\oplus B_1) + d\operatorname{F}(A_0\oplus B_1+A_1\oplus B_0)]\\\\
&amp;=[a\operatorname{F}(A_0\oplus B_0) + a\operatorname{F}(A_1\oplus B_1) + b\operatorname{F}(A_0\oplus B_1)+b\operatorname{F}(A_1\oplus B_0),c\operatorname{F}(A_0\oplus B_0)+ c\operatorname{F}(A_1\oplus B_1) + d\operatorname{F}(A_0\oplus B_1)+d\operatorname{F}(A_1\oplus B_0)]\\\\
&amp;=[a\operatorname{F}(A_0)\operatorname{F}(B_0) + a\operatorname{F}(A_1)\operatorname{F}(B_1) + b\operatorname{F}(A_0)\operatorname{F}(B_1)+b\operatorname{F}(A_1)\operatorname{F}(B_0),c\operatorname{F}(A_0)\operatorname{F}(B_0)+ c\operatorname{F}(A_1)\operatorname{F}(B_1) + d\operatorname{F}(A_0)\operatorname{F}(B_1)+d\operatorname{F}(A_1)\operatorname{F}(B_0)]\\\\
&amp;=[aUW + aVX + bUX+bVW\ ,\ cUW+ cVX + dUX+dVW]
\end{split}
\]</span></p>
<p>和 <span class="math inline">\((\ref{FWTCOM})\)</span> 对齐系数可以得到如下方程组： <span class="math display">\[
\begin{cases}
a=a^2\\\\
a=b^2\\\\
b=2ab\\\\
c=c^2\\\\
c=d^2\\\\
d=2cd
\end{cases}
\]</span> 解上面的方程组即可，显然有许多解。但是考虑到不仅需要 <span class="math inline">\(\operatorname{FWT}\)</span> ，还需要 <span class="math inline">\(\operatorname{iFWT}\)</span>。有些解无法保证 <span class="math inline">\(\operatorname{iFWT}\)</span> 能够存在解。</p>
<p>由： <span class="math display">\[
\operatorname{F}(A) = \operatorname{merge}(a \cdot\operatorname{F}(A_0) + b \cdot\operatorname{F}(A_1)\ ,c \cdot\operatorname{F}(A_0) + d \cdot\operatorname{F}(A_1) )
\]</span></p>
<p>设 <span class="math inline">\(X = a \cdot\operatorname{F}(A_0) + b \cdot\operatorname{F}(A_1)\)</span>，<span class="math inline">\(Y = c \cdot\operatorname{F}(A_0) + d \cdot\operatorname{F}(A_1)\)</span>。问题变成了已知 <span class="math inline">\(X, Y\)</span>，求出 <span class="math inline">\(\operatorname{F}(A_0), \operatorname{F}(A_1)\)</span>，可以解得： <span class="math display">\[
\operatorname{F}(A_1) =\frac{aY - cX}{da-bc}
\]</span> <span class="math display">\[
\operatorname{F}(A_0) =\frac{dX - bY}{da-bc}
\]</span> 因此上述方程组中，解还需要需要保证 <span class="math inline">\(ad \not = bc\)</span>。</p>
<p>可以解出一如下两组解： <span class="math display">\[
\begin{cases}
a=1\\\\
b=-1\\\\
c=1\\\\
d=1
\end{cases}
\]</span> <span class="math display">\[
\begin{cases}
a=1\\\\
b=1\\\\
c=1\\\\
d=-1
\end{cases}
\]</span></p>
<p>上述两组解带入后都可以实现异或卷积。</p>
<h5 id="质数表">质数表</h5>
<details class="note info"><summary><p>质数表</p>
</summary>
<p>来自 <a href="https://min-25.hatenablog.com/entry/2015/04/07/160154">min_25的博客Orz</a></p>
<table>
<thead>
<tr class="header">
<th>最长周期 <span class="math inline">\(n\)</span></th>
<th>质数</th>
<th>原根</th>
<th><span class="math inline">\(z(z^n = 1)\)</span></th>
<th><span class="math inline">\(p-1\)</span>的因数分解</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><span class="math inline">\(2^{26}\)</span></td>
<td>469762049</td>
<td>3</td>
<td>2187</td>
<td><span class="math inline">\(2^{26} \times 7\)</span></td>
</tr>
<tr class="even">
<td><span class="math inline">\(2^{25}\)</span></td>
<td>167772161</td>
<td>3</td>
<td>243</td>
<td><span class="math inline">\(2^{25} \times 5\)</span></td>
</tr>
<tr class="odd">
<td><span class="math inline">\(2^{24}\)</span></td>
<td>754974721</td>
<td>11</td>
<td>739831874</td>
<td><span class="math inline">\(2^{24} \times 3^2 \times 5\)</span></td>
</tr>
<tr class="even">
<td><span class="math inline">\(2^{23}\)</span></td>
<td>377487361</td>
<td>7</td>
<td>48510621</td>
<td><span class="math inline">\(2^{23} \times 3^2 \times 5\)</span></td>
</tr>
<tr class="odd">
<td><span class="math inline">\(2^{23}\)</span></td>
<td>595591169</td>
<td>3</td>
<td>361399025</td>
<td><span class="math inline">\(2^{23} \times 71\)</span></td>
</tr>
<tr class="even">
<td><span class="math inline">\(2^{23}\)</span></td>
<td>645922817</td>
<td>3</td>
<td>224270701</td>
<td><span class="math inline">\(2^{23} \times 7 \times 11\)</span></td>
</tr>
<tr class="odd">
<td><span class="math inline">\(2^{23}\)</span></td>
<td>880803841</td>
<td>26</td>
<td>273508579</td>
<td><span class="math inline">\(2^{23} \times 3 \times 5 \times 7\)</span></td>
</tr>
<tr class="even">
<td><span class="math inline">\(2^{23}\)</span></td>
<td>897581057</td>
<td>3</td>
<td>872686320</td>
<td><span class="math inline">\(2^{23} \times 107\)</span></td>
</tr>
<tr class="odd">
<td><span class="math inline">\(2^{23}\)</span></td>
<td>998244353</td>
<td>3</td>
<td>15311432</td>
<td><span class="math inline">\(2^{23} \times 7 \times 17\)</span></td>
</tr>
<tr class="even">
<td><span class="math inline">\(2^{22}\)</span></td>
<td>104857601</td>
<td>3</td>
<td>39193363</td>
<td><span class="math inline">\(2^{22} \times 5^2\)</span></td>
</tr>
<tr class="odd">
<td><span class="math inline">\(2^{22}\)</span></td>
<td>113246209</td>
<td>7</td>
<td>58671006</td>
<td><span class="math inline">\(2^{22} \times 3^3\)</span></td>
</tr>
<tr class="even">
<td><span class="math inline">\(2^{22}\)</span></td>
<td>138412033</td>
<td>5</td>
<td>99040867</td>
<td><span class="math inline">\(2^{22} \times 3 \times 11\)</span></td>
</tr>
<tr class="odd">
<td><span class="math inline">\(2^{22}\)</span></td>
<td>155189249</td>
<td>6</td>
<td>14921912</td>
<td><span class="math inline">\(2^{22} \times 37\)</span></td>
</tr>
<tr class="even">
<td><span class="math inline">\(2^{22}\)</span></td>
<td>163577857</td>
<td>23</td>
<td>121532577</td>
<td><span class="math inline">\(2^{22} \times 3 \times 13\)</span></td>
</tr>
<tr class="odd">
<td><span class="math inline">\(2^{22}\)</span></td>
<td>230686721</td>
<td>6</td>
<td>71750113</td>
<td><span class="math inline">\(2^{22} \times 5 \times 11\)</span></td>
</tr>
<tr class="even">
<td><span class="math inline">\(2^{22}\)</span></td>
<td>415236097</td>
<td>5</td>
<td>73362476</td>
<td><span class="math inline">\(2^{22} \times 3^2 \times 11\)</span></td>
</tr>
<tr class="odd">
<td><span class="math inline">\(2^{22}\)</span></td>
<td>666894337</td>
<td>5</td>
<td>147340140</td>
<td><span class="math inline">\(2^{22} \times 3 \times 53\)</span></td>
</tr>
<tr class="even">
<td><span class="math inline">\(2^{22}\)</span></td>
<td>683671553</td>
<td>3</td>
<td>236932120</td>
<td><span class="math inline">\(2^{22} \times 163\)</span></td>
</tr>
<tr class="odd">
<td><span class="math inline">\(2^{22}\)</span></td>
<td>918552577</td>
<td>5</td>
<td>86995699</td>
<td><span class="math inline">\(2^{22} \times 3 \times 73\)</span></td>
</tr>
<tr class="even">
<td><span class="math inline">\(2^{22}\)</span></td>
<td>935329793</td>
<td>3</td>
<td>86363943</td>
<td><span class="math inline">\(2^{22} \times 223\)</span></td>
</tr>
<tr class="odd">
<td><span class="math inline">\(2^{22}\)</span></td>
<td>943718401</td>
<td>7</td>
<td>754500478</td>
<td><span class="math inline">\(2^{22} \times 3^2 \times 5^2\)</span></td>
</tr>
<tr class="even">
<td><span class="math inline">\(2^{22}\)</span></td>
<td>985661441</td>
<td>3</td>
<td>79986183</td>
<td><span class="math inline">\(2^{22} \times 5 \times 47\)</span></td>
</tr>
<tr class="odd">
<td><span class="math inline">\(2^{21}\)</span></td>
<td>111149057</td>
<td>3</td>
<td>60767546</td>
<td><span class="math inline">\(2^{21} \times 53\)</span></td>
</tr>
<tr class="even">
<td><span class="math inline">\(2^{21}\)</span></td>
<td>132120577</td>
<td>5</td>
<td>102376994</td>
<td><span class="math inline">\(2^{21} \times 3^2 \times 7\)</span></td>
</tr>
<tr class="odd">
<td><span class="math inline">\(2^{21}\)</span></td>
<td>136314881</td>
<td>3</td>
<td>2981173</td>
<td><span class="math inline">\(2^{21} \times 5 \times 13\)</span></td>
</tr>
<tr class="even">
<td><span class="math inline">\(2^{21}\)</span></td>
<td>169869313</td>
<td>5</td>
<td>143354861</td>
<td><span class="math inline">\(2^{21} \times 3^4\)</span></td>
</tr>
<tr class="odd">
<td><span class="math inline">\(2^{21}\)</span></td>
<td>186646529</td>
<td>3</td>
<td>88383805</td>
<td><span class="math inline">\(2^{21} \times 89\)</span></td>
</tr>
<tr class="even">
<td><span class="math inline">\(2^{21}\)</span></td>
<td>199229441</td>
<td>3</td>
<td>174670364</td>
<td><span class="math inline">\(2^{21} \times 5 \times 19\)</span></td>
</tr>
<tr class="odd">
<td><span class="math inline">\(2^{21}\)</span></td>
<td>211812353</td>
<td>3</td>
<td>113852926</td>
<td><span class="math inline">\(2^{21} \times 101\)</span></td>
</tr>
<tr class="even">
<td><span class="math inline">\(2^{21}\)</span></td>
<td>249561089</td>
<td>3</td>
<td>61724276</td>
<td><span class="math inline">\(2^{21} \times 7 \times 17\)</span></td>
</tr>
<tr class="odd">
<td><span class="math inline">\(2^{21}\)</span></td>
<td>257949697</td>
<td>5</td>
<td>186470816</td>
<td><span class="math inline">\(2^{21} \times 3 \times 41\)</span></td>
</tr>
<tr class="even">
<td><span class="math inline">\(2^{21}\)</span></td>
<td>270532609</td>
<td>22</td>
<td>74891632</td>
<td><span class="math inline">\(2^{21} \times 3 \times 43\)</span></td>
</tr>
<tr class="odd">
<td><span class="math inline">\(2^{21}\)</span></td>
<td>274726913</td>
<td>3</td>
<td>255478716</td>
<td><span class="math inline">\(2^{21} \times 131\)</span></td>
</tr>
<tr class="even">
<td><span class="math inline">\(2^{21}\)</span></td>
<td>383778817</td>
<td>5</td>
<td>324881819</td>
<td><span class="math inline">\(2^{21} \times 3 \times 61\)</span></td>
</tr>
<tr class="odd">
<td><span class="math inline">\(2^{21}\)</span></td>
<td>387973121</td>
<td>6</td>
<td>124477810</td>
<td><span class="math inline">\(2^{21} \times 5 \times 37\)</span></td>
</tr>
<tr class="even">
<td><span class="math inline">\(2^{21}\)</span></td>
<td>459276289</td>
<td>11</td>
<td>238723101</td>
<td><span class="math inline">\(2^{21} \times 3 \times 73\)</span></td>
</tr>
<tr class="odd">
<td><span class="math inline">\(2^{21}\)</span></td>
<td>463470593</td>
<td>3</td>
<td>428228038</td>
<td><span class="math inline">\(2^{21} \times 13 \times 17\)</span></td>
</tr>
<tr class="even">
<td><span class="math inline">\(2^{21}\)</span></td>
<td>576716801</td>
<td>6</td>
<td>153098993</td>
<td><span class="math inline">\(2^{21} \times 5^2 \times 11\)</span></td>
</tr>
<tr class="odd">
<td><span class="math inline">\(2^{21}\)</span></td>
<td>597688321</td>
<td>11</td>
<td>395834143</td>
<td><span class="math inline">\(2^{21} \times 3 \times 5 \times 19\)</span></td>
</tr>
<tr class="even">
<td><span class="math inline">\(2^{21}\)</span></td>
<td>635437057</td>
<td>11</td>
<td>171402456</td>
<td><span class="math inline">\(2^{21} \times 3 \times 101\)</span></td>
</tr>
<tr class="odd">
<td><span class="math inline">\(2^{21}\)</span></td>
<td>639631361</td>
<td>6</td>
<td>432237000</td>
<td><span class="math inline">\(2^{21} \times 5 \times 61\)</span></td>
</tr>
<tr class="even">
<td><span class="math inline">\(2^{21}\)</span></td>
<td>648019969</td>
<td>17</td>
<td>592437138</td>
<td><span class="math inline">\(2^{21} \times 3 \times 103\)</span></td>
</tr>
<tr class="odd">
<td><span class="math inline">\(2^{21}\)</span></td>
<td>710934529</td>
<td>17</td>
<td>69533131</td>
<td><span class="math inline">\(2^{21} \times 3 \times 113\)</span></td>
</tr>
<tr class="even">
<td><span class="math inline">\(2^{21}\)</span></td>
<td>715128833</td>
<td>3</td>
<td>355872337</td>
<td><span class="math inline">\(2^{21} \times 11 \times 31\)</span></td>
</tr>
<tr class="odd">
<td><span class="math inline">\(2^{21}\)</span></td>
<td>740294657</td>
<td>3</td>
<td>237508734</td>
<td><span class="math inline">\(2^{21} \times 353\)</span></td>
</tr>
<tr class="even">
<td><span class="math inline">\(2^{21}\)</span></td>
<td>786432001</td>
<td>7</td>
<td>228383098</td>
<td><span class="math inline">\(2^{21} \times 3 \times 5^3\)</span></td>
</tr>
<tr class="odd">
<td><span class="math inline">\(2^{21}\)</span></td>
<td>799014913</td>
<td>13</td>
<td>374051146</td>
<td><span class="math inline">\(2^{21} \times 3 \times 127\)</span></td>
</tr>
<tr class="even">
<td><span class="math inline">\(2^{21}\)</span></td>
<td>824180737</td>
<td>5</td>
<td>133412682</td>
<td><span class="math inline">\(2^{21} \times 3 \times 131\)</span></td>
</tr>
<tr class="odd">
<td><span class="math inline">\(2^{21}\)</span></td>
<td>899678209</td>
<td>7</td>
<td>118485495</td>
<td><span class="math inline">\(2^{21} \times 3 \times 11 \times 13\)</span></td>
</tr>
<tr class="even">
<td><span class="math inline">\(2^{21}\)</span></td>
<td>924844033</td>
<td>5</td>
<td>44009197</td>
<td><span class="math inline">\(2^{21} \times 3^2 \times 7^2\)</span></td>
</tr>
<tr class="odd">
<td><span class="math inline">\(2^{21}\)</span></td>
<td>950009857</td>
<td>7</td>
<td>741494216</td>
<td><span class="math inline">\(2^{21} \times 3 \times 151\)</span></td>
</tr>
<tr class="even">
<td><span class="math inline">\(2^{21}\)</span></td>
<td>962592769</td>
<td>7</td>
<td>695637473</td>
<td><span class="math inline">\(2^{21} \times 3^3 \times 17\)</span></td>
</tr>
<tr class="odd">
<td><span class="math inline">\(2^{21}\)</span></td>
<td>975175681</td>
<td>17</td>
<td>518451017</td>
<td><span class="math inline">\(2^{21} \times 3 \times 5 \times 31\)</span></td>
</tr>
<tr class="even">
<td><span class="math inline">\(2^{21}\)</span></td>
<td>1004535809</td>
<td>3</td>
<td>702606812</td>
<td><span class="math inline">\(2^{21} \times 479\)</span></td>
</tr>
<tr class="odd">
<td><span class="math inline">\(2^{21}\)</span></td>
<td>1012924417</td>
<td>5</td>
<td>673144645</td>
<td><span class="math inline">\(2^{21} \times 3 \times 7 \times 23\)</span></td>
</tr>
</tbody>
</table>

</details>
]]></content>
      <categories>
        <category>学习总结</category>
      </categories>
      <tags>
        <tag>多项式</tag>
        <tag>FWT</tag>
        <tag>NTT</tag>
        <tag>FFT</tag>
      </tags>
  </entry>
  <entry>
    <title>「学习总结」数论</title>
    <url>//%E3%80%8C%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93%E3%80%8D%E6%95%B0%E8%AE%BA/</url>
    <content><![CDATA[<p>关于 <code>Lucas</code> 定理及其扩展，<code>BSGS</code>及其扩展，快速质因数分解 <code>Pollard-Rho</code>，素性测试以及原根和阶的一些可爱知识。 <a id="more"></a></p>
<h1 id="数论">数论</h1>
<h2 id="lucas-定理">Lucas 定理</h2>
<p>解决模数为小质数的组合数取模问题。</p>
<p>设模数为 <span class="math inline">\(P\)</span>，设 <span class="math display">\[
\begin{equation}n = \sum_{i \ge 0}\limits{a_i P^i}, m = \sum_{i \ge 0}\limits{b_i P^i}\notag\end{equation}
\]</span> <span class="math display">\[
\begin{equation}
\dbinom{n}{m} \equiv \prod_{i \ge 0}\limits{\dbinom{a_i}{b_i}} ( mod\ P)\label{Lucas}
\end{equation}
\]</span> 同时 <span class="math inline">\(\eqref{Lucas}\)</span> 还有一种形式化的写法： <span class="math display">\[
\begin{equation}\label{Luacs_ex}\dbinom{n}{m} \equiv \dbinom{\lfloor n/P\rfloor}{\lfloor m/P\rfloor}\dbinom{n \mod P}{m \mod P}(mod\ P)\end{equation}
\]</span></p>
<p>若小组合数可以 <span class="math inline">\(\mathcal{O}(1)\)</span> 查询，<code>Luacs</code> 的时间复杂度为 <span class="math inline">\(\mathcal{O}(\log_p(n))\)</span> 。</p>
<p>取模后不能保证 <span class="math inline">\(n \ge m\)</span> ，查询组合数要写的细致一点。</p>
<p>特殊地，如果模数是 <span class="math inline">\(2\)</span> ，根据 <span class="math inline">\((\ref{Lucas})\)</span> 考虑如果把数字进行二进制拆分求组合数，不难发现其在模 <span class="math inline">\(2\)</span> 意义下的值为 <span class="math inline">\(\left[(n\ \And\ m) = m\right]\)</span> 其中 <span class="math inline">\(n, m\)</span> 的意义同 <span class="math inline">\((\ref{Lucas})\)</span>。</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">int _C_(int m, int n)&#123;
	if(m &lt; n)  return 0;
	return frac[m] *1ll* ifrac[n] % MOD *1ll* ifrac[m - n] % MOD;
&#125;
int C(int m, int n)&#123;
	if(MOD &#x3D;&#x3D; 2) return ((n &amp; m) &#x3D;&#x3D; n);
	if(m &lt; n)  return 0; if(n &#x3D;&#x3D; 0) return 1;
	return C(m &#x2F; MOD, n &#x2F; MOD) *1ll* _C_(m % MOD, n % MOD) % MOD;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="扩展-lucas-定理">扩展 Lucas 定理</h2>
<p>解决模数为可能不为质数，且每个质数幂较小的组合数取模问题。 <del>扩展卢卡斯定理和卢卡斯定理没有关系</del> 并没有用到 <code>Luacs</code> 的基本思想 <span class="math inline">\((\ref{Lucas})\)</span> ，扩展 <code>Lucas</code> 定理 本质上是解决了阶乘逆元不存在的情况下，形如</p>
<p><span class="math display">\[\begin{equation}\frac{*}{n!}\mod P\label{exl}\end{equation}\]</span></p>
<p>式子的求值。 考虑组合数通项公式：</p>
<p><span class="math display">\[\begin{equation}\dbinom{n}{m} = \frac{n!}{m! (n-m)!}\label{exC}\end{equation}\]</span></p>
<p>限制我们不能直接求 <span class="math inline">\((\ref{exC})\)</span> 的原因——模数不为质数，无法保证逆元存在。考虑如果让分母和模数互质就可以求出这个式子的值了。</p>
<p>首先可以对模数 <span class="math inline">\(p\)</span> 进行质因数分解，分解成形如 <span class="math inline">\(p = \prod_{i\ge 0}\limits{P_i^{e_i}}\)</span> ，先分别求模数为 <span class="math inline">\(P_i^{e_i}\)</span> 式子的值，然后 <code>CRT</code> 合并答案。</p>
<p>考虑如何求出模数为 <span class="math inline">\(P_i^{e_i}\)</span> 的值。 设函数 <span class="math inline">\(g_p(n)\)</span> 为 <span class="math inline">\(n!\)</span> 中质因子 <span class="math inline">\(p\)</span> 的幂次。 设 <span class="math inline">\(a = g_p(n), b=g_p(m), c=g_p(n-m)\)</span> 易知：</p>
<p><span class="math display">\[\begin{equation} \ref{exC} \equiv \frac{\frac{n!}{p^{a}}}{\frac{m!}{p^{b}} \frac{(n-m)!}{p^{c}}}\ p^{a-b-c}\  (mod \ P_i^{e_i})\label{exLucas}\end{equation}\]</span></p>
<p>设 <span class="math inline">\(k=P_i^{e_i}\)</span> ，如果所求为 <span class="math inline">\(\frac{n!}{p_i^{a}}\)</span> 对于 <span class="math inline">\(n!\)</span> 的每一项 (<span class="math inline">\(1\times 2\times 3\times 4\times 5\times \dots \times n\)</span>)，其每一项在模 <span class="math inline">\(k\)</span> 意义下的取值一定是每 <span class="math inline">\(k\)</span> 个一次循环的。</p>
<p>同时每一个 <span class="math inline">\(P_i\)</span> 的倍数都可以提出一个因子 <span class="math inline">\(P_i\)</span> 也可以轻松知道，这个提出来的因子有 <span class="math inline">\(\lfloor\frac{n}{P_i}\rfloor\)</span> 个， 即 <span class="math inline">\(P^{\lfloor\frac{n}{P_i}\rfloor}\)</span> 这个式子不计入答案。</p>
<p>这些倍数提出一个 <span class="math inline">\(P_i\)</span> 的因子之后一定会形成另一个阶乘的形式，这是一个子问题，可以递归计算。剩下的数字可以暴力计算一个周期，然后根据周期的出现次数，直接计算式子的值。 这样就可以算出 <span class="math inline">\(n!\)</span> 去掉所有质因子 <span class="math inline">\(P_i\)</span> 在模 <span class="math inline">\(P_i^{e_i}\)</span> 意义下的值了。 保证了这个值和 <span class="math inline">\(P_i\)</span> 互质，这样就可以求逆元了。 根据 <span class="math inline">\((\ref{exLucas})\)</span> 计算即可。</p>
<p>关于函数 <span class="math inline">\(g_p(n)\)</span> 的计算：</p>
<p><span class="math display">\[
g_p(n) = \prod_{i\ge 1}\limits{\lfloor\frac{n}{p^i}\rfloor}= \frac{n - f_p(n)}{p - 1}
\]</span></p>
<p>其中 <span class="math inline">\(f_p(n)\)</span> 为数字 <span class="math inline">\(n\)</span> 在 <span class="math inline">\(p\)</span> 进制下的数位和。</p>
<p>注意逆元不是质数，别<del>傻不拉几的</del>冲一个费马小定理。</p>
<p>复杂度是 <span class="math inline">\(\mathcal{O}\left(\sum_{i\ge 0}\limits{(\log P + P_i^{e_i})\log n}\right)\)</span> 大概就是 <span class="math inline">\(\mathcal{O}\left(\sum_{i \ge 0}\limits{P_i^{e_i}\log n}\right)\)</span> 吧。 <details class="note info"><summary><p>code</p>
</summary>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">int f(int n, int p)&#123;
	int ans &#x3D; 0;
	while(n) &#123; ans +&#x3D; n % p; n &#x2F;&#x3D; p; &#125;
	return ans;
&#125;
int g(int n, int P)&#123; return (n - f(n, P)) &#x2F; (P - 1); &#125;

int pow(int a, int b, int P)&#123; int ans &#x3D; 1; while(b) &#123; if(b &amp; 1) ans &#x3D; ans *1ll* a % P; a &#x3D; a *1ll* a % P; b &gt;&gt;&#x3D; 1; &#125; return ans; &#125;
&#x2F;&#x2F;int inv(int x, int MOD) &#123; return pow(x, MOD - 2, MOD); &#125; &#x2F;&#x2F; deleted: Fermat&#39;s Little Theorem is NOT correct when MOD is not a prime number.
int exgcd(int a, int b, int &amp;x, int &amp;y)&#123;
	if(!b) &#123; x &#x3D; 1; y &#x3D; 0; return a; &#125;
	int g &#x3D; exgcd(b, a % b, y, x);
	y -&#x3D; (a &#x2F; b) * x;
	return g;
&#125;
int inv(int a, int P)&#123; &#x2F;&#x2F; add: Exgcd
	int x, y; exgcd(a, P, x, y);
	return (x % P +0ll+ P ) % P;
&#125;

int calc(int n, int p, int k)&#123; &#x2F;&#x2F; calc n!(without p) mod p^k
	if(n &#x3D;&#x3D; 0) return 1;
	int P &#x3D; 1; rep(i, 1, k) P *&#x3D; p;
	int res &#x3D; n % P, prd0 &#x3D; 1, prd1 &#x3D; 1;
	rep(i, 1, P)&#123;
		if(i % p &#x3D;&#x3D; 0) continue;
		if(i &lt;&#x3D; res) prd0 &#x3D; prd0 *1ll* i % P;
		prd1 &#x3D; prd1 *1ll* i % P;
	&#125;
	int ans &#x3D; calc(n &#x2F; p, p, k);
	ans &#x3D; ans *1ll* prd0 % P;
	ans &#x3D; ans *1ll* pow(prd1, n &#x2F; P, P) % P; &#x2F;&#x2F; changed &#96;pow(prd1, n &#x2F; p, P)&#96; to &#96;pow(prd1, n &#x2F; P, P) % P&#96;.
	return ans;
&#125;
LL n, m; int MOD;
vector&lt;pair&lt;int, int &gt; &gt; d;
namespace Divide&#123;
	const int _ &#x3D; 1e6 + 100;
	int np[_], prime[_], tot &#x3D; 0, Mid[_];
	void init(int n)&#123;
		rep(i, 2, n)&#123;
			if(!np[i]) prime[++tot] &#x3D; i, Mid[i] &#x3D; i;
			for(int j &#x3D; 1; j &lt;&#x3D; tot &amp;&amp; prime[j] * i &lt;&#x3D; n; j++)&#123;
				int x &#x3D; prime[j] * i; Mid[x] &#x3D; prime[j];
				np[x] &#x3D; 1;
				if(i % prime[j] &#x3D;&#x3D; 0) break;
			&#125;
		&#125;
	&#125;
	void divide(vector&lt;pair&lt;int, int &gt; &gt; &amp; res, int MOD)&#123;
		for(int i &#x3D; 1; i &lt;&#x3D; tot; i++)&#123;
			if(MOD % prime[i] !&#x3D; 0) continue;
			pair&lt;int, int &gt; ans; ans.fi &#x3D; prime[i];
			ans.se &#x3D; 0;
			while(MOD % prime[i] &#x3D;&#x3D; 0) MOD &#x2F;&#x3D; prime[i], ans.se++;
			res.push_back(ans);
		&#125;
	&#125;&#x2F;&#x2F; 这里可以直接 $\mathcal&#123;O&#125;(\sqrt&#123;n&#125;)$ 试除即可，没必要分解质因数。写的时候太年轻了。
&#125;
int CRT(vector&lt;pair&lt;int, int &gt; &gt; &amp; A)&#123;
	int W &#x3D; MOD;
	int ans &#x3D; 0;
	rep(i, 0, A.size() - 1)&#123;
		pair&lt;int, int &gt; now &#x3D; A[i];
		ans &#x3D; (ans +0ll+ ( now.fi *1ll* (W &#x2F; now.se) % MOD *1ll* inv(W &#x2F; now.se, now.se) ) % MOD) % MOD;
	&#125;
	return ans;
&#125;

vector&lt;pair&lt;int, int &gt; &gt; Ans;
signed main()&#123; &#x2F;&#x2F;freopen(&quot;.in&quot;, &quot;r&quot;, stdin);
	Read(n)(m)(MOD); Divide::init(MOD + 2);
	Divide::divide(d, MOD);
	rep(i, 0, d.size() - 1)&#123;
		pair&lt;int, int&gt; NowMod &#x3D; d[i]; int P &#x3D; pow(NowMod.fi, NowMod.se);
		int rA &#x3D; calc(n, NowMod.fi, NowMod.se);
		int rB &#x3D; calc(n - m, NowMod.fi, NowMod.se);
		int rC &#x3D; calc(m, NowMod.fi, NowMod.se);
		int ans &#x3D; 0;
		ans &#x3D; rA *1ll* inv(rB, P) % P *1ll* inv(rC, P) % P;
		ans &#x3D; ans *1ll* pow(NowMod.fi, g(n, NowMod.fi) - g(n - m, NowMod.fi) - g(m, NowMod.fi), P) % P;
		Ans.push_back(mp(ans, P));
	&#125;
	printf(&quot;%lld\n&quot;, CRT(Ans));
	return 0;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

</details></p>
<h2 id="bsgs">BSGS</h2>
<p>求解模数为质数的指数方程。<span class="math inline">\(a^x \equiv b\ (mod\ p) \ p \in P\)</span>。 由欧拉定理可知，本质不同的解 范围为 <span class="math inline">\([0, p-1]\)</span> 。 朴素做法就是枚举一下 <span class="math inline">\([0, p-1]\)</span> 判断是不是解，但是这样显然太慢了。 考虑选一个参数 <span class="math inline">\(T\)</span>，则 <span class="math inline">\(\forall x \in [0, p-1]\)</span> 都可以表示成 <span class="math inline">\(r \times T + c\ \ (b &lt; T)\)</span> 的形式，易知，<span class="math inline">\(r = \lfloor\frac{x}{T} \rfloor, c=x\ mod \ T\)</span></p>
<p>带入原式：</p>
<p><span class="math display">\[
\begin{equation*}
a^{rT + c} \equiv b\ (mod\ p)
\end{equation*}
\]</span> <span class="math display">\[
\begin{equation} \label{BSGS0}
a^{c} \equiv b\times a^{-rT}\ (mod\ p)
\end{equation}
\]</span> 可以考虑枚举 <span class="math inline">\(c\)</span> 算出每一个 <span class="math inline">\(a^{c}\)</span> 压入 <code>set</code> 或 <code>hash</code> 表，然后枚举每一个 <span class="math inline">\(r\)</span> 算出每一个 <span class="math inline">\(a^{-rT} \times b\)</span> 在之前算出的答案中查找，如果能找到相同的取值（即：满足<span class="math inline">\((\ref{BSGS0})\)</span>），就说明当前这个 <span class="math inline">\(r\)</span> 就是一个答案。 <details class="note info"><summary><p>code</p>
</summary>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">int inv(int a, int P)&#123;
	int x, y; exgcd(a, P, x, y);
	return (x % P +0ll+ P) % P;
&#125;
int BSGS(int a, int b, int P) &#123; &#x2F;&#x2F; a^x &#x3D; b (mod P) (a, p) &#x3D; 1;
	static set&lt;int&gt; S; S.clear();
	int T &#x3D; sqrt(P);
	for(int i &#x3D; 0, x &#x3D; 1; i &lt; T; i++, x &#x3D; x *1ll* a % P) if(x !&#x3D; b) S.insert(x); else return i;
	for(int i &#x3D; 1; i &lt;&#x3D; T; i++)&#123;
		int now &#x3D; b *1ll* inv(pow(a, T * i, P), P) % P;
		if(!S.count(now)) continue;
		for(int j &#x3D; i * T, V &#x3D; pow(a, j, P); ; j++, V &#x3D; V *1ll* a % P) if(V &#x3D;&#x3D; b) return j;
	&#125;
	return -1;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

</details></p>
<h2 id="扩展-bsgs">扩展 BSGS</h2>
<p>用于求解模数不一定为质数的指数方程。<span class="math inline">\(a^x \equiv b\ (mod\ p) \ p \in P\)</span>。 限制不能直接 <span class="math inline">\(BSGS\)</span> 的因素就是不能保证逆元存在，那就考虑如何让 <span class="math inline">\((a, p) = 1\)</span> 。</p>
<p>具体地，设 <span class="math inline">\(d_1=\gcd(a,p)\)</span> 。如果 <span class="math inline">\(d_1\nmid b\)</span> ，则原方程无解。否则我们把方程同时除以 <span class="math inline">\(d_1\)</span> ，得到<br />
<span class="math display">\[
\begin{equation}
\frac{a}{d_1}\cdot a^{x-1}\equiv \frac{b}{d_1}\pmod{\frac{p}{d_1}}
\end{equation}
\]</span></p>
<p>如果 <span class="math inline">\(a\)</span> 和 <span class="math inline">\(\frac{p}{d_1}\)</span> 仍不互质就再除，设 <span class="math inline">\(d_2=\gcd\left(a,\frac{p}{d_1}\right)\)</span> 。如果 <span class="math inline">\(d_2\nmid \frac{b}{d_1}\)</span> ，则方程无解；否则同时除以 <span class="math inline">\(d_2\)</span> 得到. <span class="math display">\[
\begin{equation}
\frac{a^2}{d_1d_2}\cdot a^{x-2}≡\frac{b}{d_1d_2} \pmod{\frac{p}{d_1d_2}}
\end{equation}
\]</span> 直到模数和 <span class="math inline">\(a\)</span> 互质。 记 <span class="math inline">\(D = \prod\limits{d_i}\)</span>，则</p>
<p><span class="math display">\[
\begin{equation}
\frac{a^k}{D}\cdot a^{x-k}\equiv\frac{b}{D} \pmod{\frac{p}{D}}
\end{equation}
\]</span> 就可以使用 <code>BSGS</code> 求解了。</p>
<p>需要注意的是：</p>
<ul>
<li>解可能小于 <span class="math inline">\(k\)</span> ，可以暴力枚举一下小于 <span class="math inline">\(k\)</span> 的幂次，判断一下</li>
<li>如果有 <span class="math inline">\(d_i\)</span> 不是 <span class="math inline">\(b\)</span> 的约数，直接判断无解即可。</li>
</ul>
<pre class="line-numbers language-none"><code class="language-none">int exBSGS(int a, int b, int P)&#123;
	int D &#x3D; 1, k &#x3D; 0, tp &#x3D; P;
	while(true) &#123; int g &#x3D; gcd(a, tp); if(g &#x3D;&#x3D; 1) break; tp &#x2F;&#x3D; g; D *&#x3D; g; k++;  &#125;
	for(int i &#x3D; 0, V &#x3D; 1; i &lt;&#x3D; k; i++, V &#x3D; V *1ll* a % P) if(V &#x3D;&#x3D; b) return i; &#x2F;&#x2F; changed: It must be executed before &#96;if(b % D !&#x3D; 0) return -1&#96;).
	int S &#x3D; pow(a, k, tp);
	if(b % D !&#x3D; 0) return -1; &#x2F;&#x2F; added: It is necessary!
	int B &#x3D; b *1ll* inv(S, tp) % tp;
	int r &#x3D; BSGS(a, B, tp);
	return r &#x3D;&#x3D; -1 ? -1 : r + k;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>已通过 luogu 和 SPOJ 的测试数据，但是 zhx (Orz) 的数据只有 <span class="math inline">\(50pts\)</span> 待填。</p>
<p><span class="math inline">\(\begin{equation}\label{} \end{equation}\)</span></p>
<h2 id="miller_rabin">Miller_Rabin</h2>
<p>快速判断大数素性。</p>
<p>一个结论： 如果 <span class="math inline">\(n\)</span> 为质数 <span class="math inline">\(\forall a &lt; n\)</span> 设 <span class="math inline">\(n - 1 = d \times 2^r, (d, 2) = 1\)</span>，则 <span class="math display">\[\begin{equation}\label{MR0}a^d \equiv 1 \pmod n \end{equation}\]</span> <span class="math display">\[\begin{equation}\label{MR1}\exists\ 0 \le i &lt; r, s.t. a^{d\times i^i} \equiv -1 \pmod n \end{equation}\]</span></p>
<p><span class="math inline">\(\ref{MR0}\)</span> 和 <span class="math inline">\(\ref{MR1}\)</span> 至少一个满足。 是否为充要条件带查。</p>
<p>我们需要判断一个数是否为质数，只需要判断是否符合上面的定理即可，但是 <span class="math inline">\(\forall a &lt; n\)</span> 对复杂度不友好。</p>
<p>通常的做法是选择若干质数当作底数 <span class="math inline">\(a\)</span>，进行判断。</p>
<p>关于底数的选择： &gt;如果选用2, 3, 7, 61和24251作为底数，那么10^16内唯一的强伪素数为46 856 248 255 981 ——matrix67博客 (Orz)</p>
<p>选择 <code>int PrimeList[10] = &#123;2, 3, 7, 61, 24251, 11, 29&#125;;</code> 即可，或者再随意加几个小质数。</p>
<p>需要注意快速乘法的实现。 复杂度为 <span class="math inline">\(\mathcal{O}(k \log x)\)</span> <details class="note info"><summary><p>code</p>
</summary>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">#define LL long long
#define ULL unsigned long long
inline ULL mul(ULL a, ULL b, ULL MOD)&#123; &#x2F;&#x2F; unsigned long long
	LL R &#x3D; (LL)a*b - (LL)((ULL)((long double)a * b &#x2F; MOD) * MOD);
	&#x2F;&#x2F; 只关心两个答案的差值，这个差值一定小于 unsigned long long 的最大值，
	&#x2F;&#x2F; 所以在哪个剩余系下都不重要，不管差值是什么都能还原出原始数值。
	if(R &lt; 0) R +&#x3D; MOD;
	if(R &gt; MOD) R -&#x3D; MOD;
	return R;
&#125;
inline LL pow(LL a, LL b, LL P) &#123; LL ans &#x3D; 1; while(b)&#123; if(b &amp; 1) ans &#x3D; mul(ans, a, P); a &#x3D; mul(a, a, P); b &gt;&gt;&#x3D; 1; &#125; return ans; &#125;
int PrimeList[10] &#x3D; &#123;2, 3, 7, 61, 24251, 11, 17, 19, 29, 27&#125;;
bool Miller_Rabin(int a, LL n)&#123;
	LL d &#x3D; n - 1, r &#x3D; 0, x;
	while(!(d &amp; 1)) d &gt;&gt;&#x3D; 1, r++;
	if((x &#x3D; pow(a, d, n)) &#x3D;&#x3D; 1) return true;
	for(int t &#x3D; 1; t &lt;&#x3D; r; t++, x &#x3D; mul(x, x, n)) if(x &#x3D;&#x3D; n - 1) return true;
	return false;
&#125;
bool Prime(LL x)&#123;
	if(x &lt;&#x3D; 2) return x &#x3D;&#x3D; 2;
	for(int i &#x3D; 0; i &lt; 7; i++)&#123;
		if(x &#x3D;&#x3D; PrimeList[i]) return true;
		if(!Miller_Rabin(PrimeList[i], x)) return false;
	&#125;
	return true;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

</details></p>
<h2 id="pollard-rho">Pollard-Rho</h2>
<p>快速分解质因数的解决方案。 复杂度 <span class="math inline">\(\mathcal{O}(Accepted)\)</span>。大约为 <span class="math inline">\(\mathcal{O}(n^{1/4})\)</span> ，算法导论给出的是 <span class="math inline">\(\mathcal{O}(\sqrt{n})\)</span>，但是随机数据下，<span class="math inline">\(1s\)</span> 分解 <span class="math inline">\(10000\)</span> 个 <span class="math inline">\(10^{18}\)</span> 量级的数字问题不大……</p>
<blockquote>
<p>任何一个伟大的算法都来自于一个微不足道的猜想。</p>
</blockquote>
<p>考虑给出一个数字 <span class="math inline">\(n\)</span> ，如果可以快速找其中一个因子 <span class="math inline">\(g\)</span> ，然后继续递归分解 <span class="math inline">\(n / g\)</span> 和 <span class="math inline">\(g\)</span> 即可完成质因数分解。</p>
<p>考虑如何快速寻找一个数 <span class="math inline">\(n\)</span> 的因子 <span class="math inline">\(g\)</span>； （以下复杂度分析都是基于最坏情况，即素数平方的形式）</p>
<ol type="1">
<li>枚举 <span class="math inline">\(n\)</span> 的因子 <span class="math inline">\(g\)</span> 试除，复杂度为 <span class="math inline">\(\mathcal{O}(\sqrt{n})\)</span></li>
<li>考虑随机枚举 <span class="math inline">\(n\)</span> 的因子，试除，期望复杂度为 <span class="math inline">\(\mathcal{O}(n)\)</span></li>
<li>没必要随机枚举 <span class="math inline">\(n\)</span> 的因子，只需要随机一个数字 <span class="math inline">\(a\)</span> 那么 <span class="math inline">\(g = gcd(a, n)\)</span> 就是 <span class="math inline">\(n\)</span> 的一个因子，需要找到一个不平凡的因子才可以，这样 <span class="math inline">\(a\)</span> 的合法取值变成了 <span class="math inline">\(n\)</span> 的因子或 <span class="math inline">\(n\)</span> 因子的倍数，合法的 <span class="math inline">\(a\)</span> 的取值有 <span class="math inline">\(\mathcal{O}(\sqrt{n})\)</span> 个。</li>
</ol>
<p>着重考虑下一种优化：</p>
<p>考虑一次性随机出 <span class="math inline">\(k\)</span> 个数字 分别记作 <span class="math inline">\(a_{1...k}\)</span>，考虑其中两两的差值，应该有 <span class="math inline">\(k^2\)</span> 种差值。试图让其差值与 <span class="math inline">\(n\)</span> 求最大公约数 <span class="math inline">\(c\)</span>，若 <span class="math inline">\(c\)</span> 不为 <span class="math inline">\(1\)</span> 则 <span class="math inline">\(c\)</span> 就是一个不平凡因子。 差值与 <span class="math inline">\(n\)</span> 的最大公约数为 <span class="math inline">\(c\)</span>，等价于 差值在 <span class="math inline">\(c\)</span> 的剩余系下同余 <span class="math inline">\(0\)</span>。考虑这 <span class="math inline">\(k^2\)</span> 个差值都不等于 <span class="math inline">\(0\)</span> 的概率为多少。因为这 <span class="math inline">\(k\)</span> 个数字是随机的，那么他们差值的取值在 <span class="math inline">\(c\)</span> 的剩余系下也是在 <span class="math inline">\([0, c]\)</span> 等概率分布的。那么都不等于 <span class="math inline">\(0\)</span> 的概率为 <span class="math inline">\(\left(\frac{c - 1}{c}\right)^{k^2}\)</span>。最坏情况下，合法的 <span class="math inline">\(c\)</span> 只有一个，且等于 <span class="math inline">\(\sqrt{n}\)</span> 根据</p>
<p><span class="math display">\[\begin{equation}\left(\frac{n-1}{n}\right)^{n} \approx \frac{1}{e}\end{equation}\]</span></p>
<p>当 <span class="math inline">\(k = n^{1/4}\)</span> 时，取不到值得概率为 <span class="math inline">\(\frac{1}{e}\)</span>。稍微增大几倍的 <span class="math inline">\(k\)</span> 可以降低找不到概率。 注意这样的做法需要枚举所有 <span class="math inline">\(k^2\)</span> 对差值，再加上判断和取不到约数情况的出现，复杂度要劣于 <span class="math inline">\(\mathcal{O}(\sqrt{n})\)</span>。 枚举 <span class="math inline">\(k^2\)</span> 对差值是上面算法的瓶颈。引入伪随机函数 <span class="math inline">\(f(x) = f^2(x-1) + c \mod n\)</span>。 这个函数有几点比较优良性质：</p>
<ol type="1">
<li>仍然可以看成是一种随机函数，保证了上面推导中对随机的依赖性。<del>（个人感觉不能保证完全随机……）</del></li>
<li>经过一段次数的递推之后会进入一个循环，因为之和前一项的值有关，而且取值只能在 <span class="math inline">\([0, n-1]\)</span> 内，所以至多 <span class="math inline">\(\mathcal{O}(n)\)</span> 次递推，一定会进入一个循环。</li>
<li><span class="math display">\[g \mid f(i) - f(j)\ \ \  \Rightarrow\ \ \ g \mid f(i + 1) - f(j - 1)\]</span> 证明： <span class="math display">\[f(i + 1) - f(j + 1) = (f^2(i) + c) - (f^2(j) + c) = (f(i) - f(j))(f(i) + f(j))\]</span> 也就是 <span class="math inline">\(g\)</span> 是否为某两个差值的约数之和两个差值下标的差有关。</li>
</ol>
<p>考虑两个指针，分别为 <span class="math inline">\(L, R\)</span> ，每次 <span class="math inline">\(L\)</span> 递推一个， <span class="math inline">\(R\)</span> 递推两个，因为函数存在环，这两个差值总会在环上相遇，从开始到相遇之间的时间，每次执行后，判断其差值与 <span class="math inline">\(n\)</span> 的 <code>gcd</code> 是否不等于 <span class="math inline">\(1\)</span> 即可。相遇所需时间，即环的大小约为 <span class="math inline">\(\sqrt{n}\)</span> 。环的大小决定运行最坏时间。</p>
<p>这样还是不够快，其实不需要每次执行都算一下 <span class="math inline">\(gcd\)</span> 可以执行一些步数之后，将其差值乘到一起，一起求 <span class="math inline">\(gcd\)</span> 即可，可以证明，这样的变化保证答案不会变劣。 考虑让两个指针倍增的往前跳，倍增若干次后，每次计算两个指针距离之间的所有差值取值，乘在一起计算 <span class="math inline">\(gcd\)</span>。</p>
<del>
标准代码中：差值相同的解会计算多次。但是确实大大提升运行效率。这里就不会分析了，但是直观感觉就是，其实那个函数往后递推的次数越多会包含更多的因子。也就是说，如果两对函数值差值下标距离一样，其实下标大的那一对会更优。
</del>
<p>总的来说，快的玄学。</p>
<p>可以写出如下代码： <pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">LL Pollard_Rho(LL n)&#123;
	LL c &#x3D; rand(n - 1) + 1;
	LL L &#x3D; 0;
	for(int s &#x3D; 0, t &#x3D; 1; ; s &lt;&lt;&#x3D; 1, t &lt;&lt;&#x3D; 1)&#123;
		LL R &#x3D; L, M &#x3D; 1;
		for(int i &#x3D; s, step &#x3D; 1; i &lt; t; i++, step ++)&#123;
			R &#x3D; f(R, c, n);
			M &#x3D; mul(M, abs(L - R), n);
			if(step % 1000 &#x3D;&#x3D; 0) &#123; LL g &#x3D; gcd(M, n); if(g &gt; 1) return g; &#125;
			&#x2F;&#x2F; 不一定必须等到一轮计算结束之后再计算 gcd 可能中间就已经出现答案了，中间每隔一段时间算几次，可以在出现答案之后快速返回答案。
		&#125;
		LL g &#x3D; gcd(M, n); if(g &gt; 1) return g;
		L &#x3D; R;
	&#125;
&#125;

void factorize(LL n)&#123;
	if(Prime(n)) &#123; ans &#x3D; max(ans, n); return ; &#125;
	LL g &#x3D; n;
	while(g &#x3D;&#x3D; n) g &#x3D; Pollard_Rho(n);
	factorize(g); factorize(n &#x2F; g);
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre> ## 阶 若 <span class="math inline">\(a \perp P\)</span>，则使 <span class="math inline">\(a^k \equiv 1 \pmod P\)</span> 成立的最小的 <span class="math inline">\(k\)</span>，称为 <span class="math inline">\(a\)</span> 关于模 <span class="math inline">\(P\)</span> 的阶，记作 <span class="math inline">\(\text{ord}_m(a)\)</span>。</p>
<p>求法： 根据欧拉定理，<span class="math inline">\(\text{ord}_m(a) \mid \varphi(m)\)</span>，先求出 <span class="math inline">\(\varphi(m)\)</span>，记作 <span class="math inline">\(t\)</span>。</p>
<ul>
<li>枚举 <span class="math inline">\(t\)</span> 的每一个因子，检查是否满足阶的性质。</li>
<li>对 <span class="math inline">\(t\)</span> 质因数拆分，以此考虑每个质因子，试图减少质因子的幂次——即如果减少了某个质因子的幂次，<span class="math inline">\(a^t \equiv 1 \pmod P\)</span> 依然成立，那么就直接减少即可。感性理解一下肯定是对的。 <span class="math inline">\(\mathcal{O}(\log \varphi(P))\)</span></li>
</ul>
<h2 id="原根">原根</h2>
<p>若 <span class="math inline">\(\text{ord}_mg = \varphi(m)\)</span> 则称 <span class="math inline">\(g\)</span> 为 <span class="math inline">\(m\)</span> 的原根。</p>
<p>通俗的讲：称 <span class="math inline">\(g\)</span> 为 <span class="math inline">\(P\)</span> 的原根，当且仅当 <span class="math inline">\(\{g^0, g^1, g^2, \dots, g^{\varphi(P) - 1}\}\)</span> 数两两不同。</p>
<p>即对于任意一个和 <span class="math inline">\(P\)</span> 互质的数字，在 <span class="math inline">\(P\)</span> 的剩余系下，都可以表示成 <span class="math inline">\(g^t\)</span> 的形式。</p>
<p>一个模数存在原根，当且仅当这个模数为 <span class="math inline">\(2, 4, p^s, 2p^s\)</span>，<span class="math inline">\(p\)</span> 为奇素数。</p>
<p>判断一个数是否为原根：根据定义可以考虑枚举每一个 <span class="math inline">\(t \in [1, \varphi(P) - 1]\)</span> 判断 <span class="math inline">\(g^t\)</span> 是否都不等于 <span class="math inline">\(1\)</span>。事实上，根据欧拉定理，可能使 <span class="math inline">\(g^t \equiv 1 \pmod P\)</span> 的 <span class="math inline">\(t\)</span> 只可能是是 <span class="math inline">\(\varphi(P)\)</span> 的约数。枚举 <span class="math inline">\(\varphi(P)\)</span> 的每个约数，进行判断即可，复杂度为 <span class="math inline">\(\mathcal{O}(\sqrt{\varphi(P)})\)</span></p>
<p>原根的求法：若一个数 <span class="math inline">\(m\)</span> 存在原根，其最小原根大概在 <span class="math inline">\(m^{1/4}\)</span> 级别。枚举原根再判断一般是可以接受的。 <pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">bool JudgePrimitiveRoot(int g, int P)&#123;
	int phi &#x3D; P - 1;
	for(int i &#x3D; 2; i * i &lt;&#x3D; phi; i++)&#123;
		if(phi % i !&#x3D; 0) continue;
		if(pow(g, i, P) &#x3D;&#x3D; 1) return false;
		if(pow(g, P &#x2F; i, P) &#x3D;&#x3D; 1) return false;
	&#125;
	return true;
&#125;
int GetPrimitiveRoot(int P)&#123; for(int i &#x3D; 2; ; i++) if(JudgePrimitiveRoot(i, P)) return i; &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre> 地位相当于自然数域下的唯一分解定理。</p>
]]></content>
      <categories>
        <category>学习总结</category>
      </categories>
      <tags>
        <tag>数学</tag>
        <tag>数论</tag>
      </tags>
  </entry>
  <entry>
    <title>「题单」IOI2020国家集训队作业 Part 1</title>
    <url>//%E3%80%8C%E6%9D%82%E9%A2%98%E8%AE%B0%E5%BD%95%E3%80%8DIOI2020%E5%9B%BD%E5%AE%B6%E9%9B%86%E8%AE%AD%E9%98%9F%E4%BD%9C%E4%B8%9A-Part-1/</url>
    <content><![CDATA[<h1 id="cf505e-mr.-kitayuta-vs.-bamboos">CF505E Mr. Kitayuta vs. Bamboos</h1>
<ul>
<li>给定 <span class="math inline">\(n\)</span> 个数（竹子的高度） <span class="math inline">\(h_{1 \dots n}\)</span>。</li>
<li>你需要进行 <span class="math inline">\(m\)</span> 轮操作，每轮操作为 <span class="math inline">\(k\)</span> 次修改，每次修改可以选择一个数 <span class="math inline">\(h_i\)</span> 修改为 <span class="math inline">\(\max(h_i - p, 0)\)</span>（砸到地下）。</li>
<li>每轮操作后每个 <span class="math inline">\(h_i\)</span> 将会被修改为 <span class="math inline">\(h_i + a_i\)</span>（每天竹子会生长）。</li>
<li>你需要最小化最终 <span class="math inline">\(h_{1 \dots n}\)</span> 中的最大值。</li>
<li><span class="math inline">\(n \le 10^5\)</span>，<span class="math inline">\(m \le 5 \times 10^3\)</span>，<span class="math inline">\(k \le 10\)</span> <a id="more"></a> 要求最小化最大值，考虑二分一个最大的高度，将问题转化成可行性问题，即，给出一个高度，问能否使这些竹子最终不超过这个高度。</li>
</ul>
<p>考虑限制这个问题不平凡的因素：因为每次降低竹子高度的时候不能保证竹子一定降低 p ，也就是说，“砸竹子”这一动作存在浪费。我们考虑尽可能的让“砸竹子”这一动作更少的浪费，即：尽可能在后面的时间点砸竹子，但是无法保证到底是在哪一次砸竹子，有可能已经结束了，没有形式化的计算流程。</p>
<p>可以考虑反向思考，即：假设已经长到 二分的高度。每次生长操作相当于每次会下落 <span class="math inline">\(a_i\)</span>，而每次砸的操作相当于提升了 <span class="math inline">\(p\)</span> 的高度。</p>
<p>开始时，对每一个竹子计算出其需要多少次会下落到负高度，用堆维护，每次取出最快的可能下落到负高度的 k 个竹子，进行 “拔高” 操作。然后判断最后的高度是否大于等于<span class="math inline">\(h_i\)</span>。</p>
<p>其实二分的本质是为了确定“尽可能的靠后砸竹子”的标准。反向思考是为了便于贪心处理策略。 ## code <details class="note info"><summary><p>CF505E Mr. Kitayuta vs. Bamboos</p>
</summary>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">int n, m, k, p;
int H[_], A[_];
#define mp make_pair
#define fi first
#define se second
int height[_];
bool check(int MaxH)&#123;
	fill(height + 1, height + 1 + n, MaxH);
	priority_queue&lt;pair&lt;int, int&gt;, vector&lt;pair&lt;int, int&gt; &gt; , greater&lt;pair&lt;int, int&gt; &gt; &gt; Q;
	while(!Q.empty()) Q.pop();
	for(int i &#x3D; 1; i &lt;&#x3D; n; i++) if(MaxH - m * A[i] &lt; H[i]) Q.push(mp( MaxH &#x2F; A[i], i ));

	for(int i &#x3D; 1; i &lt;&#x3D; m; i++) &#123;
		for(int j &#x3D; 1; j &lt;&#x3D; k; j++)&#123;
			if(Q.empty()) return true;
			pair&lt;int, int&gt; now &#x3D; Q.top(); Q.pop();
			if(now.fi &lt; i) return false;
			height[now.se] +&#x3D; p;
			now.fi &#x3D; height[now.se] &#x2F; A[now.se];
			if(height[now.se] - m * A[now.se] &lt; H[now.se]) Q.push(now);
		&#125;
	&#125;
	return Q.empty();
&#125;
signed main()&#123;
	n &#x3D; read(), m &#x3D; read(), k &#x3D; read(), p &#x3D; read(); &#x2F;&#x2F; 竹子数 天数 修改次数 最大降低高度
	for(int i &#x3D; 1; i &lt;&#x3D; n; i++) H[i] &#x3D; read(), A[i] &#x3D; read();

	int L &#x3D; 0, ans &#x3D; 0, R &#x3D; 1LL &lt;&lt; 60; for(int i &#x3D; 1; i &lt;&#x3D; n; i++) L &#x3D; min(L, A[i]);
	while(L &lt; R)&#123;
		int mid &#x3D; (L + R) &gt;&gt; 1;
		if(check(mid)) ans &#x3D; mid, R &#x3D; mid;
		else L &#x3D; mid + 1;
	&#125;
	printf(&quot;%lld\n&quot;, ans);
	return 0;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

</details></p>
<h1 id="cf521d-shop">CF521D Shop</h1>
<ul>
<li>有 <span class="math inline">\(k\)</span> 个正整数 <span class="math inline">\(a_{1\dots k}\)</span>。</li>
<li>有 <span class="math inline">\(n\)</span> 个操作，每个操作给定正整数 <span class="math inline">\(b\)</span>，有三种可能：将 <span class="math inline">\(a_i\)</span> 赋值为 <span class="math inline">\(b\)</span>，将 <span class="math inline">\(a_i\)</span> 加上 <span class="math inline">\(b\)</span>，将 <span class="math inline">\(a_i\)</span> 乘以 <span class="math inline">\(b\)</span>。</li>
<li>你可以从 <span class="math inline">\(n\)</span> 个操作中选择最多 <span class="math inline">\(m\)</span> 个操作，并按照一定顺序执行。</li>
<li>你的目标是最大化 <span class="math inline">\(\prod_{i=1}^k a_i\)</span> 的值。</li>
<li><span class="math inline">\(k,n \le 10^5\)</span>。</li>
</ul>
<p>化归思想，考虑如果只有乘法，那一定是把操作数字从大到小排序，然后以此操作。</p>
<p>考虑操作顺序，最优的操作一定是先赋值，再加法，最后乘法。其中赋值只可能选相应位置最大的赋值，加法也是从大到小考虑。</p>
<p>显然赋值可以直接转化成加法，而加法如果从大到小考虑也可以直接转化成乘法（乘一个实数）。</p>
<p>这样就把所有操作转化成了乘法。 贪心考虑即可。</p>
<p>最后输出有顺序，应按照上面的策略（先赋值，再加法，最后乘法）以此输出（操作顺序）。</p>
<h2 id="code">code</h2>
<details class="note info"><summary><p>CF521D Shop</p>
</summary>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">#include &lt;climits&gt;
#include &lt;cstring&gt;
#include &lt;cstdio&gt;
#include &lt;cmath&gt;
#include &lt;iostream&gt;
#include &lt;algorithm&gt;
#include &lt;vector&gt;
using namespace std;
const int _ &#x3D; 1e5 + 100;
#define LL long long
int read() &#123; int x; scanf(&quot;%d&quot;, &amp;x); return x; &#125;
int n, m, k;
int v[_];
pair&lt;int, int&gt; Give[_];
vector&lt;pair&lt;int, int &gt; &gt; add[_];
vector&lt;pair&lt;double, int&gt; &gt; mul[_];
vector&lt;pair&lt;double, int&gt; &gt; All;
int T[_];
int id[_];
#define double long double
bool ICMP  (const pair&lt;int, int&gt; &amp; x, const pair&lt;int, int&gt; &amp; y) &#123; return (x &gt; y); &#125;
bool ICMP_D(const pair&lt;double, int&gt; &amp; x, const pair&lt;double, int&gt; &amp; y) &#123; return (x &gt; y); &#125;
bool MAGIC(const int &amp;x, const int &amp;y) &#123; return T[x] &lt; T[y]; &#125;
int main()&#123;
	k &#x3D; read(), n &#x3D; read(), m &#x3D; read();
	for(int i &#x3D; 1; i &lt;&#x3D; k; i++) v[i] &#x3D; read();

	for(int i &#x3D; 1; i &lt;&#x3D; n; i++)&#123;
		int type &#x3D; read(); T[i] &#x3D; type;
		int a &#x3D; read(), b &#x3D; read();
		if(type &#x3D;&#x3D; 1)&#123;
			Give[a] &#x3D; max(Give[a], make_pair(b, i));
		&#125; else if(type &#x3D;&#x3D; 2)&#123;
			add[a].push_back(make_pair(b, i));
		&#125; else &#123;
			mul[a].push_back(make_pair((double)(b), i));
		&#125;
	&#125;
	for(int i &#x3D; 1; i &lt;&#x3D; k; i++)
		if(Give[i].first)
			add[i].push_back(make_pair(Give[i].first - v[i], Give[i].second));
	for(int i &#x3D; 1; i &lt;&#x3D; k; i++) sort(add[i].begin(), add[i].end(), ICMP);
	for(int i &#x3D; 1; i &lt;&#x3D; k; i++)&#123;
		LL now &#x3D; v[i];
		for(int j &#x3D; 0; j &lt; add[i].size(); j++)&#123;
			mul[i].push_back(
				make_pair(
					(double)(now +0ll+ add[i][j].first) &#x2F; (double)(now),
					add[i][j].second
				)
			); now +&#x3D; add[i][j].first;
		&#125;
	&#125;
	for(int i &#x3D; 1; i &lt;&#x3D; k; i++) for(int j &#x3D; 0; j &lt; mul[i].size(); j++) All.push_back(mul[i][j]);
	sort(All.begin(), All.end(), ICMP_D);
	int tot &#x3D; 0;
	for(int i &#x3D; 0; i &lt; All.size(); i++) if(All[i].first &gt; 1) &#123; tot++; &#125;
	tot &#x3D; min(tot, m);
	for(int i &#x3D; 1; i &lt;&#x3D; tot; i++) id[i] &#x3D; All[i - 1].second;
	sort(id + 1, id + 1 + tot, MAGIC);	printf(&quot;%d\n&quot;, tot);
	for(int i &#x3D; 1; i &lt;&#x3D; tot; i++) printf(&quot;%d%c&quot;, id[i], &quot; \n&quot;[i &#x3D;&#x3D; n]);
	return 0;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

</details>
<h1 id="cf526f-pudding-monsters">CF526F Pudding Monsters</h1>
<ul>
<li>给定一个 <span class="math inline">\(n \times n\)</span> 的棋盘，其中有 <span class="math inline">\(n\)</span> 个棋子，每行每列恰好有一个棋子。</li>
<li>求有多少个 <span class="math inline">\(k \times k\)</span> 的子棋盘中恰好有 <span class="math inline">\(k\)</span> 个棋子。</li>
<li><span class="math inline">\(n \le 3 \times 10^5\)</span>。</li>
</ul>
<p>每行每列<strong>恰好有一个</strong>棋子的棋盘，可以抽象成一个排列。 而操作也是对于一个排列的一段进行操作的。</p>
<p>题意可以转化为： - 给出一个排列 - 求连续段数量，即连续的一段，且段中的元素排好序之后必须是公差为<span class="math inline">\(1\)</span>的等差数列.</p>
<p><strong>连续段计数</strong></p>
<p>考虑如何刻画“<strong>连续的一段，且段中的元素排好序之后必须是公差为<span class="math inline">\(1\)</span>的等差数列</strong>”这个条件，可以形式化的定义：</p>
<p><span class="math display">\[\operatorname{MaxVal} - \operatorname{MinVal} = (R - L)\]</span></p>
<p>即</p>
<p><span class="math display">\[f_{R}(L) = \operatorname{MaxVal} - \operatorname{MinVal} - (R - L) = 0\]</span></p>
<p>这个条件成立的基础在于，所求数列不能有重复元素，而且也保证了函数<span class="math inline">\(f_x(L) \ge 0\)</span>, 查询时只需要维护<strong>最小值</strong>以及最小值的<strong>数量</strong>即可。</p>
<p>可以考虑枚举一个端点，比如右端点 <span class="math inline">\(R\)</span>，然后查找有多少符合条件的左端点 <span class="math inline">\(L\)</span> ，用线段树维护<span class="math inline">\(f_R(x)\)</span>在每个点处的函数值。</p>
<p>考虑当<span class="math inline">\(f_x(L)\)</span> 移动到 <span class="math inline">\(f_{x + 1}(L)\)</span> 时， 值的变化。变化的值有 <span class="math inline">\(R\)</span> , 可能变化的有<span class="math inline">\(MaxVal, MinVal\)</span>。用单调栈实时维护更新后会波及哪些元素的最小值。事实上，单调栈处理的过程就是在动态维护一个后缀最小。</p>
<p>这里有几个与其有相似之处的题目，但是可能做法并不一样，遇到不要想成一样的题目： - <a href="https://www.luogu.com.cn/problem/P5278">算术天才⑨与等差数列</a> (不保证序列中一定元素不重复) - 考虑判断一个序列排好序后是否为等差数列 - 准确做法 - <span class="math inline">\(\max−\min=(r−l)k\)</span> - 相邻两数差的绝对值的 <span class="math inline">\(\operatorname{gcd}\)</span>是 <span class="math inline">\(k\)</span> - 区间 <span class="math inline">\([l,r]\)</span> 内的数不重复 - 概率性做法 - hash思想，维护 <span class="math inline">\(n\)</span> 次方和 - <a href="http://www.zhengruioi.com/contest/718/problem/1615">树上排列(ZROI)</a> (同样不保证元素一定不重复) - 给定一颗 <span class="math inline">\(n\)</span> 个点的树。每个点都一个正整数点权 <span class="math inline">\(A_i\)</span> ，你需要支持以下两种操作： - 1、询问点 <span class="math inline">\(x\)</span> 和点 <span class="math inline">\(y\)</span> 之间的路径上的所有点（包括点 <span class="math inline">\(x\)</span> 和点 <span class="math inline">\(y\)</span> ）的点权是否构成一个从 <span class="math inline">\(1\)</span> 开始的排列（即若这条链长度为 <span class="math inline">\(len\)</span> ，那么问点权集合为 <span class="math inline">\({1,2,⋯,len}\)</span> ）。 - 2、将 <span class="math inline">\(A_x\)</span> 修改为 <span class="math inline">\(y\)</span> 。 - 由于在树上难以判断某区间内的数字不重复，Hash维护n次方和。 - 给出一个没有重复元素的序列，询问某区间中的元素是否能加入小于<span class="math inline">\(k\)</span>个元素使其拍好序后构成一个等差数列。 - 条件变成了 <span class="math display">\[f_{R}(L) = \operatorname{MaxVal} - \operatorname{MinVal} - (R - L) \ge k\]</span> - <a href="http://www.zhengruioi.com/problem/1532">count(ZROI)</a>已知一个集合<span class="math inline">\(S\)</span>中的最大元素为 <span class="math inline">\(N\)</span>， 且这个集合中的元素可以构成一个等差数列，给出一些形如<span class="math inline">\(x \in S\)</span>、<span class="math inline">\(x \notin S\)</span>的限制。求最终的集合有多少种情况。 - 考虑刻画一个等差数列需要什么参数：公差，和每个元素$$ 公差的值。枚举这两个参数，依次计数即可。</p>
<p>（引用正睿的两道题目，不知道是不是有版权问题，如果有，会立即删除（<del>顺便给正睿OI打个广告</del>））。</p>
<h2 id="code-1">code</h2>
<details class="note info"><summary><p>CF526F Pudding Monsters</p>
</summary>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">int n;
int A[_];
#define fir first
#define sec second
namespace SegmentTree&#123;
    const int _ &#x3D; 3e6 + 100;
    struct Node&#123;
        int MIN;
        int sMIN;
        int tar;
        Node operator + (const Node &amp; rhs) const &#123;
            Node res;
            res.MIN  &#x3D; min(MIN, rhs.MIN);
            res.sMIN &#x3D; MIN &#x3D;&#x3D; rhs.MIN ? ( sMIN + rhs.sMIN) : (MIN &lt; rhs.MIN ? sMIN : rhs.sMIN) ;
            return res;
        &#125;
    &#125;v[_];
    int tot &#x3D; 0;
    int ch[_][2];
    #define ls(o) (ch[o][0])
    #define rs(o) (ch[o][1])
    #define make (tot++, ch[tot][0] &#x3D; ch[tot][1] &#x3D; v[tot].MIN &#x3D; v[tot].sMIN &#x3D; 0, tot)
    int Groot() &#123; return make; &#125;
    void maintain(int o) &#123;
        v[o].MIN  &#x3D; min(v[ls(o)].MIN, v[rs(o)].MIN);
        v[o].sMIN &#x3D; v[ls(o)].MIN &#x3D;&#x3D; v[rs(o)].MIN ? v[ls(o)].sMIN + v[rs(o)].sMIN : ( v[ls(o)].MIN &lt; v[rs(o)].MIN ? v[ls(o)].sMIN : v[rs(o)].sMIN );
    &#125;
    void tar(int o, int x) &#123; v[o].MIN +&#x3D; x; v[o].tar +&#x3D; x; &#125;
    void pushdown(int o)&#123;
        if(v[o].tar)&#123;
            tar(ls(o), v[o].tar); tar(rs(o), v[o].tar);
            v[o].tar &#x3D; 0;
        &#125;
    &#125;
    void build(int o, int L, int R)&#123;
        if(L &#x3D;&#x3D; R) &#123; v[o].MIN &#x3D; 0; v[o].sMIN &#x3D; 1; return; &#125;
        int mid &#x3D; (L + R) &gt;&gt; 1;
        ls(o) &#x3D; make; rs(o) &#x3D; make;
        build(ls(o), L, mid); build(rs(o), mid + 1, R);
        maintain(o);
    &#125;
    void update(int o, int nowl, int nowr, int L, int R, int x)&#123;
        if(L &gt; R) return ;
        if(L &lt;&#x3D; nowl &amp;&amp; nowr &lt;&#x3D; R) return tar(o, x);
        int mid &#x3D; (nowl + nowr) &gt;&gt; 1;  pushdown(o);
        if(L &lt;&#x3D; mid) update(ls(o), nowl, mid, L, R, x);
        if(R  &gt; mid) update(rs(o), mid + 1, nowr, L, R, x);
        maintain(o);
    &#125;
    Node query(int o, int nowl, int nowr, int L, int R) &#123;
        if(L &lt;&#x3D; nowl &amp;&amp; nowr &lt;&#x3D; R) return v[o];
        int mid &#x3D; (nowl + nowr) &gt;&gt; 1; pushdown(o);
        Node Ans; Ans.MIN &#x3D; INT_MAX;
        if(L &lt;&#x3D; mid) Ans &#x3D; Ans + query(ls(o), nowl, mid, L, R);
        if(R  &gt; mid) Ans &#x3D; Ans + query(rs(o), mid + 1, nowr, L, R);
        return Ans;
    &#125;
    int query(int o, int L, int R)&#123;
        Node res &#x3D; query(o, 1, n, L, R);
        return res.MIN &#x3D;&#x3D; 0 ? res.sMIN : 0;
    &#125;
&#125;  using SegmentTree::Groot; using SegmentTree::build; using SegmentTree::query; using SegmentTree::update;
namespace Mon_Stack&#123;
    int t0t &#x3D; 0, t1t &#x3D; 0;
    pair&lt;int, int&gt; S0[_], S1[_];
    int work(int *A, int n)&#123;
        int Ans &#x3D; 0;
        int root &#x3D; Groot();
        build(root, 1, n);
        S0[0].fir &#x3D; S1[0].fir &#x3D; 0;
        for(int i &#x3D; 1; i &lt;&#x3D; n; i++) &#123;
            update(root, 1, n, 1, i - 1, -1);
            while(t0t !&#x3D; 0 &amp;&amp; S0[t0t].sec &gt;&#x3D; A[i]) &#123; update(root, 1, n, S0[t0t - 1].fir + 1, S0[t0t].fir,  S0[t0t].sec); t0t--; &#125;
            while(t1t !&#x3D; 0 &amp;&amp; S1[t1t].sec &lt;&#x3D; A[i]) &#123; update(root, 1, n, S1[t1t - 1].fir + 1, S1[t1t].fir, -S1[t1t].sec); t1t--; &#125;
            update(root, 1, n, S0[t0t].fir + 1, i, -A[i]);
            update(root, 1, n, S1[t1t].fir + 1, i, A[i]);
            int t &#x3D; query(root, 1, i);
            Ans +&#x3D; t;
            S0[++t0t] &#x3D; make_pair(i, A[i]); S1[++t1t] &#x3D; make_pair(i, A[i]);
        &#125;
        return Ans;
    &#125;
&#125; using Mon_Stack::work;
signed main()&#123;
    n &#x3D; read(); for(int i &#x3D; 1; i &lt;&#x3D; n; i++) &#123; int x &#x3D; read(), y &#x3D; read(); A[x] &#x3D; y; &#125;
    printf(&quot;%lld\n&quot;, work(A, n));
    return 0;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

</details>
<details class="note info"><summary><p>count(ZROI)</p>
</summary>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">#include &lt;climits&gt;
#include &lt;cmath&gt;
#include &lt;cstring&gt;
#include &lt;iostream&gt;
#include &lt;cstdio&gt;
#include &lt;algorithm&gt;
using namespace std;
#define int long long
const int MOD &#x3D; 1e9 + 7;
const int _M &#x3D; 2e5 + 100;
inline int read() &#123; char c &#x3D; getchar(); int sign &#x3D; 1; int x &#x3D; 0; while(c &gt; &#39;9&#39; || c &lt; &#39;0&#39;) &#123; if(c&#x3D;&#x3D;&#39;-&#39;)sign &#x3D; -1; c &#x3D; getchar(); &#125; while(c &lt;&#x3D; &#39;9&#39; &amp;&amp; c &gt;&#x3D; &#39;0&#39;) &#123; x *&#x3D; 10; x +&#x3D; c - &#39;0&#39;; c &#x3D; getchar(); &#125; return x * sign; &#125;
int MAX, m;
int have[_M], tht &#x3D; 0;
int none[_M], tnt &#x3D; 0;
int d[_M], tdt &#x3D; 0;
int c[_M];&#x2F;&#x2F;tct &#x3D; tdt
bool CanBe[_M];
int ToL[_M];
int ToR[_M];
void divide(int s, int x) &#123;
    for(int i &#x3D; 1; i * i &lt;&#x3D; x; i++)&#123;
        if(x % i &#x3D;&#x3D; 0) d[++tdt] &#x3D; i, c[tdt] &#x3D; s % i;
        if(i * i !&#x3D; x) d[++tdt] &#x3D; x &#x2F; i, c[tdt] &#x3D; s % d[tdt];
    &#125;
    for(int i &#x3D; 1; i &lt;&#x3D; tdt; i++) CanBe[i] &#x3D; true;
&#125;
signed main()&#123;
    int t;
    MAX &#x3D; read(), m &#x3D; read();
    for(int i &#x3D; 1; i &lt;&#x3D; m; i++)&#123;
        int type &#x3D; read();
        if(type &#x3D;&#x3D; 1) have[++tht] &#x3D; read();
        else          none[++tnt] &#x3D; read();
    &#125;
    sort(have + 1, have + 1 + tht); sort(none + 1, none + 1 + tnt);
    int maxd &#x3D; INT_MAX, Sta;
    for(int i &#x3D; 2; i &lt;&#x3D; tht; i++) &#123;
        if(maxd &gt; have[i] - have[i - 1])&#123;
            maxd &#x3D; have[i] - have[i - 1];
            Sta &#x3D; have[i - 1];
        &#125;
    &#125;
    divide(Sta, maxd);

    &#x2F;* 公差 及 特征 检查   *&#x2F;
    for(int i &#x3D; 1; i &lt;&#x3D; tht; i++)&#123;
        for(int j &#x3D; 1; j &lt;&#x3D; tdt; j++)&#123;
            if(!CanBe[j]) continue;
            if(have[i] % d[j] !&#x3D; c[j]) CanBe[j] &#x3D; false;
        &#125;
    &#125;
    for(int i &#x3D; 2; i &lt;&#x3D; tht; i++)&#123;
        int D &#x3D; have[i] - have[i - 1];
        for(int j &#x3D; 1; j &lt;&#x3D; tdt; j++)&#123;
            if(!CanBe[j]) continue;
            if(D % d[j] !&#x3D; 0) CanBe[j] &#x3D; false;
        &#125;
    &#125;
    t &#x3D; 0;
    for(int i &#x3D; 1; i &lt;&#x3D; tdt; i++)&#123;
        if(!CanBe[i]) continue;
        d[++t] &#x3D; d[i];
        c[  t] &#x3D; c[i];
        CanBe[t] &#x3D; true;
    &#125; tdt &#x3D; t;
    &#x2F;* 公差 及 特征 检查   完成*&#x2F;
    for(int i &#x3D; 1; i &lt;&#x3D; tdt; i++) &#123;
        if(CanBe[i]) &#123;
            ToL[i] &#x3D; (c[i] &#x3D;&#x3D; 0 ? d[i] : c[i]) - 1;
            int t &#x3D; MAX % d[i];
            if(t &#x3D;&#x3D; c[i]) ToR[i] &#x3D; MAX + 1;
            if(t  &gt; c[i]) ToR[i] &#x3D; MAX - (t - c[i]) + 1;
            if(t  &lt; c[i]) ToR[i] &#x3D; MAX - d[i] + (c[i] - t) + 1;
        &#125;
    &#125;
    t &#x3D; 0;
    for(int i &#x3D; 1; i &lt;&#x3D; tdt; i++)&#123;
        if(!CanBe[i]) continue;
        d[++t] &#x3D; d[i];
        c[  t] &#x3D; c[i];
        CanBe[t] &#x3D; true;
    &#125; tdt &#x3D; t;
    int MINS &#x3D; have[1], MAXE &#x3D; have[tht];
    for(int i &#x3D; 1; i &lt;&#x3D; tnt; i++)&#123;
        int now &#x3D; none[i];
        for(int j &#x3D; 1; j &lt;&#x3D; tdt; j++)&#123;
            if(!CanBe[j]) continue;
            if(now % d[j] &#x3D;&#x3D; c[j])&#123;
                if(now &lt; MINS)
                    ToL[j] &#x3D; max(ToL[j], now);
                else if(now &gt; MAXE)
                    ToR[j] &#x3D; min(ToR[j], now);
                else CanBe[j] &#x3D; false;
            &#125;
        &#125;
    &#125;
    for(int i &#x3D; 1; i &lt;&#x3D; tdt; i++) if(ToL[i] &gt; MINS || ToR[i] &lt; MAXE) CanBe[i] &#x3D; false; else ToL[i]++, ToR[i] --;
    &#x2F;* 非法数字存在性检查 *&#x2F;
    int ans &#x3D; 0;
    for(int i &#x3D; 1; i &lt;&#x3D; tdt; i++)&#123;
        if(!CanBe[i]) continue;
        int k &#x3D; (  (MINS - ToL[i]) &#x2F; d[i] + 1) * ( (ToR[i] - MAXE) &#x2F; d[i] + 1) % MOD; &#x2F;&#x2F; TODO;
        ans &#x3D; (ans + k) % MOD;
    &#125;
    printf(&quot;%lld&quot;, ans);
    return 0;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

</details>
<details class="note info"><summary><p>A.20联赛集训day3 树上排列(维护15次方和hash)</p>
</summary>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">#include &lt;climits&gt;
#include &lt;cstring&gt;
#include &lt;cmath&gt;
#include &lt;iostream&gt;
#include &lt;algorithm&gt;
#include &lt;vector&gt;
inline int read() &#123; char c &#x3D; getchar(); int sign &#x3D; 1; int x &#x3D; 0; while(c &gt; &#39;9&#39; || c &lt; &#39;0&#39;) &#123; if(c&#x3D;&#x3D;&#39;-&#39;)sign &#x3D; -1; c &#x3D; getchar(); &#125; while(c &lt;&#x3D; &#39;9&#39; &amp;&amp; c &gt;&#x3D; &#39;0&#39;) &#123; x *&#x3D; 10; x +&#x3D; c - &#39;0&#39;; c &#x3D; getchar(); &#125; return x * sign; &#125;
using namespace std;
const int _ &#x3D; 6e5 + 100;
const int base &#x3D; 15;
const int MOD &#x3D; 1020031005;
int SS[_];
int pow(int a, int b &#x3D; base)&#123; int ans &#x3D; 1; while(b)&#123; if(b &amp; 1) ans &#x3D; (ans *1ll* a) % MOD; a &#x3D; (a *1ll* a) % MOD; b &gt;&gt;&#x3D; 1; &#125; return ans; &#125;

int head[_];
int NodeVal[_];
struct edges&#123;
	int node;
	int nxt;
&#125;edge[_];
int tot &#x3D; 0;
void add(int u, int v)&#123;
	tot++;
	edge[tot].node &#x3D; v;
	edge[tot].nxt  &#x3D; head[u];
	head[u]        &#x3D; tot;
&#125;

int n, q;
int dep[_], fa[_], dfn[_], rnk[_], top[_], son[_], si[_], dfc &#x3D; 0;
void dfs0(int now, int f, int dp)&#123;
	int &amp;S &#x3D; si[now] &#x3D; 1; int &amp;Mid &#x3D; son[now] &#x3D; 0; fa[now] &#x3D; f; dep[now] &#x3D; dp;
	for(int i &#x3D; head[now]; i ; i &#x3D; edge[i].nxt)&#123;
		int ex &#x3D; edge[i].node; if(ex &#x3D;&#x3D; f) continue;
		dfs0(ex, now, dp + 1); S +&#x3D; si[ex];
		if(si[ex] &gt; si[Mid]) Mid &#x3D; ex;
	&#125; if(!Mid) Mid &#x3D; 0;
&#125;
void dfs1(int now, int f, int tp)&#123;
	dfn[now] &#x3D; ++dfc; rnk[dfc] &#x3D; now;
	top[now] &#x3D; tp;
	if(son[now]) dfs1(son[now], now, tp);
	for(int i &#x3D; head[now]; i ; i &#x3D; edge[i].nxt)&#123;
		int ex &#x3D; edge[i].node; if(ex &#x3D;&#x3D; f || ex &#x3D;&#x3D; son[now]) continue;
		dfs1(ex, now, ex);
	&#125;
&#125;
void clear()&#123;
	memset(head, 0, sizeof(head));
	dfn[0] &#x3D; rnk[0] &#x3D; si[0] &#x3D; top[0] &#x3D; fa[0] &#x3D; son[0] &#x3D; 0;
	tot &#x3D; 0;
	dfc &#x3D; 0;
&#125;
namespace SegmentTree&#123;
	const int _ &#x3D; 3e6 + 100;
	int tot &#x3D; 0;
	int ch[_][2];
	int v[_];
	#define make (tot++, ch[tot][0] &#x3D; ch[tot][1] &#x3D; v[tot] &#x3D; 0, tot);
	#define ls(x) (ch[x][0])
	#define rs(x) (ch[x][1])
	#define maintain(o) (v[o] &#x3D; (v[ls(o)] +0ll+ v[rs(o)]) % MOD )
	void init_s() &#123; tot &#x3D; 0; &#125;
	int  Groot()&#123; return make; &#125;
	void build(int o, int L, int R)&#123;
		if(L &#x3D;&#x3D; R) return (void)(v[o] &#x3D; pow(NodeVal[rnk[L]]));
		int mid &#x3D; (L + R) &gt;&gt; 1;
		ls(o) &#x3D; make; rs(o) &#x3D; make;
		build(ls(o), L, mid); build(rs(o), mid + 1, R);
		maintain(o);
	&#125;
	void update(int o, int nowl, int nowr, int p, int x)&#123;
		if(nowl &#x3D;&#x3D; nowr) return (void)(v[o] &#x3D; pow(x));
		int mid &#x3D; (nowl + nowr) &gt;&gt; 1;
		if(p &lt;&#x3D; mid) update(ls(o), nowl, mid, p, x);
		if(p  &gt; mid) update(rs(o), mid + 1, nowr, p, x);
		maintain(o);
	&#125;
	int query(int o, int nowl, int nowr, int L, int R)&#123;
		if(L &gt; R) return 0;
		if(L &lt;&#x3D; nowl &amp;&amp; nowr &lt;&#x3D; R) return v[o];
		int mid &#x3D; (nowl + nowr) &gt;&gt; 1;
		int ans &#x3D; 0;
		if(L &lt;&#x3D; mid) ans &#x3D; (ans +0ll+ query(ls(o), nowl, mid, L, R)) % MOD;
		if(R  &gt; mid) ans &#x3D; (ans +0ll+ query(rs(o), mid + 1, nowr, L, R)) % MOD;
		return ans;
	&#125;
&#125; using SegmentTree::Groot; using SegmentTree::init_s; using SegmentTree::build; using SegmentTree::update; using SegmentTree::query;
int root &#x3D; 0;
int LCA;
int QueryOnPath(int x, int y)&#123;
	int ans &#x3D; 0;
	while(top[x] !&#x3D; top[y])&#123;
		if(dep[top[x]] &gt; dep[top[y]]) swap(x, y);
		ans &#x3D; (ans +0ll+ query(root, 1, n, dfn[top[y]], dfn[y])) % MOD;
		y &#x3D; fa[top[y]];
	&#125;
	if(dep[x] &lt; dep[y]) swap(x, y); LCA &#x3D; y;
	ans &#x3D; (ans +0ll+ query(root, 1, n, dfn[y], dfn[x])) % MOD;
	return ans;
&#125;
void doit()&#123;
	clear();
	n &#x3D; read(), q &#x3D; read();
	for(int i &#x3D; 1; i &lt;&#x3D; n; i++) NodeVal[i] &#x3D; read();
	for(int i &#x3D; 1; i &lt;  n; i++)&#123; int u &#x3D; read(), v &#x3D; read(); add(u, v); add(v, u); &#125;
	dfs0(1, 1, 1);
	dfs1(1, 1, 1);
	init_s(); root &#x3D; Groot();
	build(root, 1, n);
	while(q--)&#123;
		int opt &#x3D; read(), x &#x3D; read(), y &#x3D; read();
		if(opt &#x3D;&#x3D; 1)&#123;
			int r &#x3D; QueryOnPath(x, y);
			int Len &#x3D; dep[x] + dep[y] - (dep[LCA] &lt;&lt; 1) + 1;
			puts(SS[Len] &#x3D;&#x3D; r ? &quot;Yes&quot; : &quot;No&quot;);
		&#125; else&#123;
			update(root, 1, n, dfn[x], y);
		&#125;
	&#125;
&#125;
int main()&#123;
	for(int i &#x3D; 1; i &lt;&#x3D; 3e5; i++) SS[i] &#x3D; ( SS[i - 1] +0ll+ pow(i) ) % MOD;
	int T &#x3D; read();
	while(T--) doit();
	return 0;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

</details>
<h1 id="cf521e-cycling-city">CF521E Cycling City</h1>
<ul>
<li>给定一张 <span class="math inline">\(n\)</span> 个点 <span class="math inline">\(m\)</span> 条边的无向简单图。</li>
<li>问图中能否找到两个点，满足这两个点之间有至少三条完全不相交的简单路径。</li>
<li><span class="math inline">\(n,m \le 2 \times 10^5\)</span>，图不保证连通</li>
</ul>
<p>考虑生成树，对原图做一个生成树，考虑每个在生成树外的边，覆盖在树上，树上边被覆盖两次的，即为一种方案</p>
<p>由于树的拓扑结构比图要简单很多，直接思考图的生成树解决图内问题是一个常见思路。</p>
<h1 id="cf547d-mike-and-fish">CF547D Mike and Fish</h1>
<p><strong>待填</strong></p>
]]></content>
      <categories>
        <category>杂题记录</category>
      </categories>
      <tags>
        <tag>题解</tag>
      </tags>
  </entry>
  <entry>
    <title>「比赛总结」清北学堂省选十连测</title>
    <url>//%E3%80%8C%E6%AF%94%E8%B5%9B%E6%80%BB%E7%BB%93%E3%80%8D%E6%B8%85%E5%8C%97%E5%AD%A6%E5%A0%82%E7%9C%81%E9%80%89%E5%8D%81%E8%BF%9E%E6%B5%8B/</url>
    <content><![CDATA[<p>之后应该会按照算法分类，后面有一些题目没有补完…</p>
<a id="more"></a>
<h2 id="round-1">Round 1</h2>
<h3 id="problem-a-string">Problem A (string)</h3>
<p>你有一个字符串 <span class="math inline">\(S_0\)</span>，想要用它造出共 <span class="math inline">\(n\)</span> 个新字符串 <span class="math inline">\(S_{0},\cdots,S_{n-1}\)</span>。</p>
<p>你会按顺序进行 <span class="math inline">\(n-1\)</span> 次操作，造出新字符串。第 <span class="math inline">\(i\)</span> 次操作有两种方法：</p>
<ul>
<li><code>S x l r</code> 截取 <span class="math inline">\(S_x\)</span> 的 <span class="math inline">\([l,r)\)</span> 子串，即第 <span class="math inline">\(l\)</span> 到第 <span class="math inline">\(r-1\)</span> 个字符作为 <span class="math inline">\(S_i\)</span></li>
<li><code>A x y</code> 将 <span class="math inline">\(S_x\)</span> 和 <span class="math inline">\(S_y\)</span> 拼接作为 <span class="math inline">\(S_i\)</span></li>
</ul>
<p>最后，你会关心 <span class="math inline">\(S_{n-1}\)</span> 长什么样，因此请输出 <span class="math inline">\(S_{n-1}\)</span> 所有字符的 ASCII 码之和，结果对 <span class="math inline">\(10^9+7\)</span> 取模。</p>
<p>本题中字符串下标均从 <span class="math inline">\(0\)</span> 开始编号，且保证所有字符串串长不超过 <span class="math inline">\(2^{63}-1\)</span>，并且所有操作均合法（即<span class="math inline">\(0\leq x,y&lt;i,0\leq l &lt; r\leq Len(S_x)\)</span>）</p>
<p>第一行一个整数 <span class="math inline">\(n\)</span>。</p>
<p>接下来一行一个小写字母字符串 <span class="math inline">\(S_0\)</span>。</p>
<p>接下来 <span class="math inline">\(n-1\)</span> 行描述 <span class="math inline">\(n-1\)</span> 次操作，每行的操作格式见题目描述。</p>
<p>对于全部数据，<span class="math inline">\(n\leq 2000, 1\leq Len(S_0)\leq 2000\)</span>，同时满足题目描述中给的限制。</p>
<hr />
<p>考虑如果存储每个串对应原串 <span class="math inline">\(S_0\)</span> 的一段连续区间，每一次截取操作最多会产生两段不同的 <span class="math inline">\(S_0\)</span> 区间，不妨利用这个思路，只要能够实现对操作的解析，复杂度不是问题，我的实现比较复杂…考虑把问题转化成一些简单的问题，<span class="math inline">\(f(n, L)\)</span> 表示查询第 <span class="math inline">\(n\)</span> 个串的 <span class="math inline">\([1, L]\)</span> 子区间的 Ascii 和。 递归处理即可</p>
<hr />
<p>应该时刻记住尝试使用递归这种方法。</p>
<hr />
<h3 id="problem-b-different">Problem B (different)</h3>
<p>你有 <span class="math inline">\(n\)</span> 株植物，高度为 <span class="math inline">\(a_i\)</span>。你希望让它们的高度看起来不太相同，具体来说：任意两株高度差的绝对值不小于 <span class="math inline">\(d\)</span>。</p>
<p>每次你可以选择一株植物，将其拔高或压低 <span class="math inline">\(1\)</span>，这花费你 <span class="math inline">\(1\)</span> 的力气，这个操作可以进行任意多次。注意，植物高度不能是负的，即你需要保证任意时刻 <span class="math inline">\(a_i\geq 0\)</span>。</p>
<p>你最少需要使用多少力气，才能使得植物高度看起来不太相同呢？</p>
<p>多组测试数据。第一行一个整数 <span class="math inline">\(T\)</span> 为数据组数，接下来每组格式如下：</p>
<p><span class="math inline">\(\sum n\leq 3\cdot 10^5,1\leq d\leq 10^6, 0\leq a_i\leq 10^{11}\)</span>。</p>
<hr />
<p>首先考虑一个转化，任意这样的限制不太好处理。考虑对原序列排序，然后第 <span class="math inline">\(i\)</span> 株植物的高度减去 <span class="math inline">\((i-1)\times d\)</span>，然后问题转化为 对转化后的序列求最少需要支付多少代价，使得原序列不降。</p>
<p>考虑一个显然的 dp：<span class="math inline">\(f[i][j]\)</span> 表示考虑了前 <span class="math inline">\(i\)</span> 个植物，第 <span class="math inline">\(i\)</span> 个植物的高度为 <span class="math inline">\(j\)</span> 的最小代价。</p>
<p>转移显然： <span class="math display">\[
f[i][j] = \min_{k=0}^{j}\{f[i-1][k]\}
\]</span></p>
<p>转移比较简单，设函数 <span class="math inline">\(F_i(n)=f[i][n]\)</span> 。</p>
<p>考虑每一个函数形态：</p>
<p><span class="math inline">\(F_1(n)\)</span> 是一个绝对值函数，转移过程取前缀最小值中实际上是对其斜率为正的后半部分 “压平”，向下一个 <span class="math inline">\(F_i(n)\)</span> 转移其实是在原来的函数上加上去另一个绝对值函数，和一个常数。</p>
<p>这样形成的函数在任何时刻都是一个下凸壳，考虑使用堆来维护每一个拐点，如果在每次压入拐点的时候压入两个一样的拐点，就能够使得堆中的每个拐点前后斜率变化恰好为 <span class="math inline">\(1\)</span> ，每次取前缀最小值就相当于在堆中弹出函数值最大的拐点。</p>
<p>这样就可以实现堆维护转移了，再同时记一下 <span class="math inline">\(F(0)\)</span> 的函数值变化，最后遍历一遍堆种的拐点就能够取出最小值了。</p>
<hr />
<p>需要分析 dp 特殊性质，然后从特殊性质入手进行优化。</p>
<hr />
<h2 id="round-2">Round 2</h2>
<h3 id="problem-a-grid">Problem A (grid)</h3>
<p>你有一个 <span class="math inline">\(n\)</span> 行 <span class="math inline">\(m\)</span> 列的教室，其中某些位置不能坐人。</p>
<p>你的班上有 <span class="math inline">\(k\)</span> 对 CP，你对八卦早已失去了兴趣，转而想要知道有多少种给这 <span class="math inline">\(2k\)</span> 位同学排座位的方式，使得每对 CP 的座位<strong>不</strong>相邻（有些位置可能会空出来，方案不同当且仅当某个位置状态不同，即坐着不同的同学）。</p>
<p>结果对 <span class="math inline">\(10^9+7\)</span> 取模。</p>
<p>对于全部数据，<span class="math inline">\(1\leq nm\leq 144,1\leq k\leq \frac{nm}{2}\)</span>，保证空位置个数不少于 <span class="math inline">\(2k\)</span>。</p>
<hr />
<p>考虑问题转化，不相邻不太好搞，但是如果钦定 <span class="math inline">\(k\)</span> 个相邻，就可以直接 状压dp 解决。</p>
<p>考虑一种填放的方案，如果从上到下依次填放这些 <span class="math inline">\(**\)</span> 每一次填放的方案只和这个这个点和这个点周围的情况有关。考虑状压一个上轮廓即可。</p>
<p>设 <span class="math inline">\(f[x][y][S][k]\)</span> 表示考虑到了 <span class="math inline">\((x, y)\)</span> 这个位置，这个位置上轮廓的格子状态 <span class="math inline">\(S\)</span>，有 <span class="math inline">\(k\)</span> 个配对的 <span class="math inline">\(**\)</span>，的方案数。（这里可以先把 <span class="math inline">\(**\)</span> 考虑成无标号的最后统计的时候再给标号）。</p>
<p>转移只需要枚举是不放 / 竖着放一对 / 横着放一对。</p>
<p>将 <span class="math inline">\(f[n][m][*][l]\)</span> 累加后就能够得到无标号的 <span class="math inline">\(**\)</span> 配对 <span class="math inline">\(l\)</span> 对的方案数。赋予标号，就能够得到钦定 <span class="math inline">\(l\)</span> 的方案数。</p>
<p>可以用二项式定理转化为恰好 <span class="math inline">\(0\)</span> 对匹配的方案数。</p>
<hr />
<h3 id="problem-b-cactus">Problem B (cactus)</h3>
<p>你有一棵仙人掌，你想要知道所有点两两最短路之和！即，<span class="math inline">\(\sum\limits_{i&lt;j} dis(i,j)\)</span>。</p>
<p>仙人掌是一张无向简单连通图，无重边自环，且每条边属于至多一个简单环。</p>
<p>本题中边没有权值，即可以认为边权均为 <span class="math inline">\(1\)</span>。</p>
<p>对于全部数据，<span class="math inline">\(1\leq n\leq 3\cdot 10^5,1\leq m\leq 6\cdot 10^5\)</span>。</p>
<hr />
<p>屑题。</p>
<p>设仙人掌的点数为 <span class="math inline">\(n\)</span> ，边数为 <span class="math inline">\(m\)</span> ，则：<span class="math inline">\(m\le 2n\)</span>。</p>
<p>证明考虑一张图的 dfs 树，每一条不在树上的边都一定是返祖边（设这条边为 <span class="math inline">\((u, v)\)</span> ，则：要么 <span class="math inline">\(u\)</span> 是 <span class="math inline">\(v\)</span> 的祖先，要么 <span class="math inline">\(v\)</span> 是 <span class="math inline">\(u\)</span> 的祖先）。</p>
<p>对于一张仙人掌来说，每个返祖边无交，所以证明显然。</p>
<p>考 虑每条边的贡献：</p>
<ul>
<li>树边显然是断开后两连通块大小乘积。</li>
<li>环上的边需要考虑每一条路径是经过这条边还是环上的对边。算贡献的时候不太好处理，可以考虑暴力算出一条边的答案，然后考虑环上下一条边和这条边的贡献会差哪些，这里就能实现 <span class="math inline">\(\mathcal{O}(1)\)</span> 转化为下一条边的贡献，<del>屡试不爽</del>。</li>
</ul>
<hr />
<h3 id="problem-c-color">Problem C (color)</h3>
<p>你有一个 <span class="math inline">\(2\)</span> 行 <span class="math inline">\(n\)</span> 列的网格，你要给每个格子染上三种颜色（红绿蓝）之一。</p>
<p>你还提了很多要求：任意两个相邻格子颜色不能相同；任何一个 <span class="math inline">\(2\times 2\)</span> 的块里，每种颜色都必须出现过。</p>
<p>现在你还想求出，恰好分别染了 <span class="math inline">\(R,G,B\)</span> 个红、绿、蓝格子的方案数，结果对 <span class="math inline">\(10^9+7\)</span> 取模。</p>
<p>一行四个整数 <span class="math inline">\(n,R,G,B\)</span>。</p>
<p>对于全部数据，<span class="math inline">\(2\leq n\leq 5\cdot 10^6,0\leq R,G,B\leq 2n,R+G+B=2n\)</span>。</p>
<hr />
<p>对于每一种染色方案，如果将每一列没有出现的字符写成一行，那么问题不难转化为求 限制三种字符的出现次数，然后排成一排使其满足相邻的两个字符不相同的合法方案数。</p>
<p>记录一种更加一般化的做法吧，直接考虑这样的一个<a href="https://loj.ac/p/6503">问题</a>：</p>
<p>给出 <span class="math inline">\(m​\)</span> 种颜色和其各自的出现次数 (<span class="math inline">\(a_i​\)</span>) 要求排成长度为 <span class="math inline">\(n=\sum{a_i}​\)</span> 的序列，且满足相邻两个颜色相同的 <strong>恰好</strong> 有 <span class="math inline">\(k​\)</span> 对。定义两个序列不同，当且仅当存在某一个位置，两个序列颜色不同。</p>
<p>条件反射：看到 <strong>恰好</strong> 应该想到容斥，考虑如何求出钦定有 <span class="math inline">\(k​\)</span> 个颜色相同的相邻元素对。</p>
<p>需要观察到一个性质，对于某一种有 <span class="math inline">\(a_i​\)</span> 个的颜色，如果其在原序列中被分成了不连续的 <span class="math inline">\(x​\)</span> 段，那么她对答案的贡献是 <span class="math inline">\(a_i-x​\)</span>。</p>
<p><strong>钦定</strong> <span class="math inline">\(k\)</span> 对 就可以转化为各个颜色一共被拆分成了 <span class="math inline">\(n-k\)</span> 段。这里的方案数就可以卷积统计了。</p>
<p>但是有一点点不太对，在有些情况下，颜色段的顺序交换后并不能算成不同情况，可以考虑给每种颜色相同的元素标号，最后对答案除以 <span class="math inline">\(\prod_{i}a_i\)</span> 。</p>
<p>考虑一种颜色 <span class="math inline">\(i\)</span> 的生成函数，设：<span class="math inline">\([x^n]F_i(x)\)</span> 表示 第 <span class="math inline">\(i\)</span> 种颜色拆成 <span class="math inline">\(n\)</span> 段的方案数。</p>
<p>然后把这些段拼起来：<span class="math inline">\(G(x)=\prod_{i}\limits{F_i(x)}\)</span>。</p>
<p>组合起来之后，注意到这样是每一段是强制了其拼起来的顺序，需要打乱这个顺序，则钦定选 <span class="math inline">\(k\)</span> 个的方案数就是 <span class="math inline">\((n-k)![x^k]G(x)\)</span>。</p>
<p>然后套一个二项式反演就行了。</p>
<h2 id="round-3">Round 3</h2>
<h3 id="problem-b-streeing">Problem B (streeing)</h3>
<p>给定一棵<span class="math inline">\(n​\)</span>个节点的树，树上的每个节点有一个字符<span class="math inline">\(c_i​\)</span>.</p>
<p>初始给出串 <span class="math inline">\(S\)</span> ，现在有 <span class="math inline">\(Q\)</span> 次询问 <span class="math inline">\((x,y)\)</span> ,你需要将 <span class="math inline">\(x\)</span> 到 <span class="math inline">\(y\)</span> 路径上的字符拼成一个字符串并回答串 <span class="math inline">\(S\)</span> 在其中出现了多少次。</p>
<hr />
<p>屑题。树上莫队 <del>模板题</del></p>
<p>考虑每次新加入 / 减少一个字符最多会产生 / 减少一个匹配。哈希判断即可。</p>
<h3 id="problem-c-tree-queries">Problem C (Tree Queries)</h3>
<p>给定一棵 <span class="math inline">\(n​\)</span> 个节点树，树上的每个节点有一个权值 <span class="math inline">\(a_i​\)</span>。</p>
<p>现在有 <span class="math inline">\(Q\)</span> 次询问 <span class="math inline">\((u,d,k)\)</span>, 你需要将所有距离点 <span class="math inline">\(u\)</span> 小于等于 <span class="math inline">\(d\)</span> 的点的点权排序并输出第 <span class="math inline">\(k\)</span> 小的点权，如果没有第 <span class="math inline">\(k\)</span> 小输出 <span class="math inline">\(-1\)</span>.</p>
<p><span class="math inline">\(a_i\le 10^9 \ \ n,Q \le 5\times 10^4\)</span></p>
<hr />
<p>屑题。 毫无思维难度的一道省选难度的题。</p>
<p>点分树 + 主席树二维数点 <del>模板题</del>。</p>
<p>std 写的是两个 <span class="math inline">\(\log\)</span> 的做法，就是考虑所谓的 <strong>同步二分</strong>。三个 <span class="math inline">\(\log\)</span> 卡常数卡了一年拿到了暴力分。</p>
<h2 id="round-4">Round 4</h2>
<h3 id="problem-a-matrix">Problem A (matrix)</h3>
<p>给定一个<span class="math inline">\(n\times m\)</span>的矩阵，矩阵的每个位置上都有一个整数。</p>
<p>你现在需要选择一个大小为<span class="math inline">\(1\times x(1\le x\le k)\)</span>或者一个大小为<span class="math inline">\(x\times 1(1\le x\le k)\)</span>的子矩阵并将其中的所有元素清零。</p>
<p>你想要使操作之后的最大子矩阵和尽可能大，输出这个值。</p>
<p>一个矩阵的子矩阵定义为连续的若干行与连续的若干列的交点对应位置构成的矩阵,子矩形可以为空。</p>
<p>对于所有数据，<span class="math inline">\(2\le n,m,k\le 300,-5000\le A_{i,j}\le 5000\)</span></p>
<hr />
<p>比较套路的一个做法，考虑枚举上下两个边界，然后中间压成一维，预处理出每一列能够取到的最小能扣去的一列。 设 <span class="math inline">\(\operatorname{sum}(n)\)</span> 为前缀和函数，<span class="math inline">\(d(l, r)\)</span> 表示在 <span class="math inline">\([l,r]\)</span> 这些列中最小的能够扣去的一竖条。</p>
<p>考虑 区间 <span class="math inline">\([L, R]\)</span> 的答案一定是： <span class="math display">\[
\operatorname{sum}(R) - \operatorname{sum}(L - 1) - d(L, R)
\]</span> 可以预处理出 <span class="math inline">\(d(n, n)\)</span> 然后单调栈处理每一个区间的 <span class="math inline">\(d\)</span> 值，然后使用 <span class="math inline">\(\operatorname{sum}\)</span> 初始化 ST 表，对于每一个 <span class="math inline">\(d\)</span> 自然是取后半个区间中最大的 <span class="math inline">\(\operatorname{sum}\)</span> 值，和前半个区间中最小的 <span class="math inline">\(\operatorname{sum}\)</span> 值。 能够做到复杂度 <span class="math inline">\(\mathcal{O}(n^2)\)</span>。有亿点点小问题，细节没处理好，应该不是做法假了吧…</p>
<hr />
<h3 id="problem-b-segment">Problem B (Segment)</h3>
<p>平面上有 <span class="math inline">\(n​\)</span> 条平行于 <span class="math inline">\(X​\)</span> 轴或平行于 <span class="math inline">\(Y​\)</span> 轴的线段，你需要求出这些线段将平面划分成了几个部分。</p>
<p>第一行一个正整数 <span class="math inline">\(n​\)</span></p>
<p>接下来<span class="math inline">\(n\)</span>行每行四个整数 <span class="math inline">\(x_1,y_1,x_2,y_2\)</span> 表示线段的两个端点。<span class="math inline">\((x_1=x_2\)</span> 或 <span class="math inline">\(y_1=y_2)\)</span></p>
<p>保证 <span class="math inline">\((x_1,y_1)\ne(x_2,y_2)\)</span></p>
<p>$ n10^5  ,  -10<sup>9x_1,x_2,y_1,y_210</sup>9$</p>
<hr />
<p>平面图的欧拉定理 <span class="math display">\[
V+F=E+2
\]</span></p>
<h3 id="problem-c-3-sat">Problem C (3-sat)</h3>
<p><strong>请注意： 本题是提交答案题</strong></p>
<p>你有 <span class="math inline">\(n​\)</span> 个 <span class="math inline">\(01​\)</span> 变量 <span class="math inline">\(x_1,...,x_n​\)</span> 和 <span class="math inline">\(m​\)</span> 个子句 <span class="math inline">\(C_i=(z_1| z_2 | z_3)​\)</span> 或者 <span class="math inline">\(C_i=(z_1| z_2)​\)</span> 其中<span class="math inline">\(z_1,z_2,z_3​\)</span>为某个 <span class="math inline">\(x_j​\)</span> 或者 <span class="math inline">\(\overline{x_j}(x_j取反)​\)</span>. 每个子句的权值为 <span class="math inline">\(w_i​\)</span>. ("|"为逻辑或)</p>
<p>你希望构造一组 <span class="math inline">\(x_1,...,x_n\)</span> 的取值，使<span class="math inline">\(\sum C_i\cdot w_i\)</span>尽可能大。</p>
<p>第一行两个正整数 <span class="math inline">\(n,m​\)</span></p>
<p>接下来 <span class="math inline">\(m\)</span> 行每行 第一个整数<span class="math inline">\(k\in\{2,3\}\)</span> 描述这个子句的变量个数，接下来 <span class="math inline">\(k\)</span> 个整数 <span class="math inline">\(z_1,...,z_k\)</span>, 如果 <span class="math inline">\(z_j&lt;0\)</span>则表示 <span class="math inline">\(\overline{x_{-z_j}}\)</span>, 否则表示 <span class="math inline">\(x_{z_j}\)</span>， 描述一个子句，最后一个整数 <span class="math inline">\(w_i\)</span> 表示这个子句的权值。</p>
<p>保证子句中的 <span class="math inline">\(|z_j|\)</span> 两两不同</p>
<p>最后一行十个正整数<span class="math inline">\(t_1\le t_2\le...\le t_{10}​\)</span>, 描述评分参数。</p>
<p>设你求出的解 <span class="math inline">\(\sum C_i \cdot w_i=ans​\)</span>,令 <span class="math inline">\(v​\)</span> 为最大的 <span class="math inline">\(i​\)</span> 满足<span class="math inline">\(ans\ge t_i​\)</span>, 该测试点你将获得 <span class="math inline">\(v​\)</span> 分.</p>
<p>一行 <span class="math inline">\(n\)</span> 个整数，表示<span class="math inline">\(x_1,...,x_n\)</span>的取值。</p>
<hr />
<p>认识了一下<a href="https://oi-wiki.org/misc/simulated-annealing/"><strong>模拟退火</strong></a>算法，除了做提交答案题目以外，有一些不太紧的 <strong>传统</strong> 题也可以使用。</p>
<p>需要注意模拟退火算法，一定要设计出合理的邻域。需要注意，退火可能算是乱搞，但是代码不能乱写…，迭代次数是退火答案优劣的保证，需要加快邻域答案的计算，以追求更多的迭代次数。</p>
<h2 id="round-5">Round 5</h2>
<h3 id="problem-a-星星">Problem A (星星)</h3>
<p>三维空间里有一些星星，第 <span class="math inline">\(i\)</span> 颗星星的坐标为 <span class="math inline">\((x_i,y_i,z_i)\)</span>，且有 <span class="math inline">\(p_i\)</span> 的概率发光，<span class="math inline">\(1-p_i\)</span> 的概率不发光。保证任意四颗星星不在同一个平面上。</p>
<p>称一个星星是美丽的，当且仅当他是发光的，且不存在另外四颗<strong>发光的</strong>星星，使得这颗星星被严格包含在这另外四颗星星形成的三棱锥中。你需要求出期望有多少星星是美丽的。</p>
<p>为了避免精度问题，你需要输出这个期望对 <span class="math inline">\(998244353\)</span> 取模的结果。</p>
<p>第一行一个正整数 <span class="math inline">\(n​\)</span>，表示星星个数。</p>
<p>接下来 <span class="math inline">\(n\)</span> 行每行四个非负整数，<span class="math inline">\(p&#39;_i,x_i,y_i,z_i\)</span>。其中 <span class="math inline">\(0 \le p&#39;_i \le 10000\)</span>，真实的 <span class="math inline">\(p_i=p&#39;_i\times10^{-4}​\)</span>。</p>
<p>对于所有数据，<span class="math inline">\(4 \le n \le 100,0 \le x_i,y_i,z_i \le 10^5\)</span>，保证不会有四点共面的情况。</p>
<hr />
<h3 id="problem-b-数字">Problem B (数字)</h3>
<p>给定 <span class="math inline">\(n,p\)</span> 以及长度为 <span class="math inline">\(p-1\)</span> 的数列 <span class="math inline">\(a_0,a_1,\cdots,a_{p-2}\)</span>，其中 <span class="math inline">\(p\)</span> 是个质数。你需要求出：</p>
<p><span class="math display">\[\sum_{i=1}^na_{i\bmod\ (p-1)}\cdot\varphi(i) \mod p\]</span></p>
<p>其中 <span class="math inline">\(\varphi\)</span> 是欧拉函数，即 <span class="math inline">\(\varphi(i)\)</span> 表示小于等于 <span class="math inline">\(i\)</span> 且与 <span class="math inline">\(i\)</span> 互质的正整数个数，<span class="math inline">\(p\)</span> 给定，且 <span class="math inline">\(p\)</span> 是个小质数，满足 <span class="math inline">\(2 \le p \le 23\)</span>。</p>
<p>总共会给定 <span class="math inline">\(T\)</span> 组数列 <span class="math inline">\(a_i\)</span>，你需要对于它们分别算出答案。</p>
<p>对于所有数据，<span class="math inline">\(1 \le n \le 10^9,1 \le T \le 10^4,0 \le a_i &lt; p,2 \le p \le 23\)</span> 且 <span class="math inline">\(p\)</span> 是质数。</p>
<hr />
<p>单位根反演</p>
<h3 id="problem-c-糖果">Problem C (糖果)</h3>
<p>有 <span class="math inline">\(n\)</span> 箱糖果，其中第 <span class="math inline">\(i\)</span> 箱里有 <span class="math inline">\(a_i\)</span> 堆糖果，每堆糖果都有 <span class="math inline">\(2i\)</span> 个，如果拿了 <span class="math inline">\(k\)</span> 个，得到的快乐值为 <span class="math inline">\(\displaystyle \sum_{j=\max(k,i)}^{2i}(-1)^{j-k}\binom jk\binom{i}{j-i}-[k=0]\)</span>。其中 <span class="math inline">\([k=0]\)</span> 表示当 <span class="math inline">\(k=0\)</span> 时值为 <span class="math inline">\(1\)</span>，否则为 <span class="math inline">\(0\)</span>。最终可以从每箱中的每堆里面各拿出一些糖果放在一起，得到的快乐值为每堆糖果的快乐值的乘积（注意可以是负数）。例如 <span class="math inline">\(n=2,a_1=a_2=1\)</span>，从第一堆里拿 <span class="math inline">\(0\)</span> 个，第二堆里拿 <span class="math inline">\(3\)</span> 个，获得的快乐值为 <span class="math inline">\((-1)\times(-2)=2\)</span>。</p>
<p>对于每一种拿法，你都需要把这些糖果分给 <span class="math inline">\(m\)</span> 个小朋友，小朋友可以不分到糖果，但是 <span class="math inline">\(m\)</span> 个糖果必须分完。</p>
<p>你需要算出所有方案下，快乐值的总和是多少。两种方案不同当且仅当从某堆里拿出的糖果数量不同，或者某个小朋友分到的糖果数量不同。小朋友都是有区别的，糖果是没有区别的。</p>
<p>由于答案很大，你只需要输出快乐值总和 <span class="math inline">\(\bmod\ 998244353\)</span> 的结果即可。</p>
<hr />
<h2 id="round-6">Round 6</h2>
<h3 id="problem-a-抽奖">Problem A (抽奖)</h3>
<p>有一袋球，其中有 <span class="math inline">\(R\)</span> 个红球和 <span class="math inline">\(B\)</span> 个蓝球，初始时你手上有 <span class="math inline">\(X\)</span> 元钱，你每次可以从手上拿出任意一部分钱（可以是任意实数）当作赌注，并猜一种颜色。然后你从这个不透明的袋子里随便拿出一个球，如果这个球的颜色和你猜的颜色一致，那么你的赌注会翻倍（即假设拿了 <span class="math inline">\(Y\)</span> 元当赌注，那么这一轮结束之后你的钱数将变成 <span class="math inline">\(X+Y\)</span>），否则你会失去赌注（即总钱数变成 <span class="math inline">\(X-Y\)</span>）。</p>
<p>拿出的球不会再放回去，这意味着游戏会持续恰好 <span class="math inline">\(R+B\)</span> 轮。你需要找到一种策略，使得<strong>最坏情况</strong>下最终获得的钱数尽量多。注意每次拿出球之后你就知道了它的颜色（即知道袋子里还剩余多少红色和蓝色球）。</p>
<p>可以证明，答案一定是个有理数。你只需要输出这个有理数在 <span class="math inline">\(\bmod\ 998244353\)</span> 意义下对应的整数即可。</p>
<p><span class="math inline">\(R +B\le 10^3\)</span></p>
<hr />
<p>一道少见的简单题。</p>
<h3 id="problem-b-排列">Problem B (排列)</h3>
<p>有 <span class="math inline">\(1,2,3,\cdots,n\)</span> 这 <span class="math inline">\(n\)</span> 个数排成一排，你需要解决下面两个问题：</p>
<ol type="1">
<li>你每次可以交换任意两个数，求<strong>恰好</strong> <span class="math inline">\(k\)</span> 次交换后能得到多少种不同的排列。</li>
<li>你每次可以交换相邻两个数，求<strong>恰好</strong> <span class="math inline">\(k\)</span> 次交换后能得到多少种不同的排列。</li>
</ol>
<p>由于答案可能很大，你只需要输出其对 <span class="math inline">\(998244353\)</span> 取模的结果即可。</p>
<p>共一行两个正整数 <span class="math inline">\(n,k\)</span>。</p>
<p>对于所有数据，保证 <span class="math inline">\(1 \le n \le 10^9,1 \le k \le 10^5\)</span>。</p>
<hr />
<h3 id="problem-c-图">Problem C (图)</h3>
<p>有一个 <span class="math inline">\(n\)</span> 个点 <span class="math inline">\(m\)</span> 条边的无向连通图，保证无重边无自环。你可以删掉原图的若干条边，然后给剩下的边赋上 <span class="math inline">\(1 \sim k-1\)</span> 的权值，使得每个点相邻的边的权值和都是 <span class="math inline">\(k\)</span> 的倍数，且剩下的这些边可以使整张图连通。</p>
<p>你需要求出方案数对 <span class="math inline">\(998244353\)</span> 取模的结果。</p>
<p>第二行三个正整数 <span class="math inline">\(n,m,k\)</span>，其中 <span class="math inline">\(1 \le n \le 19,n-1 \le m \le \dfrac{n(n-1)}{2},2 \le k \le 3\)</span>。</p>
<p>接下来 <span class="math inline">\(m\)</span> 行每行两个数 <span class="math inline">\(u,v\)</span>，表示一条边。保证无重边无自环。</p>
<hr />
<h2 id="round-7">Round 7</h2>
<h3 id="problem-a">Problem A</h3>
<p>众所周知，小葱同学擅长计算，尤其擅长计算组合数，但这个题和组合数没什么关系。</p>
<p><span class="math inline">\(N\)</span>个大皮克敏和<span class="math inline">\(M\)</span>个小皮克敏，大皮克敏有两滴血，小皮克敏有一滴血。你要开<span class="math inline">\(K\)</span>枪，会等概率击中任意一只还活着的皮克敏，掉一滴血。如果最后有<span class="math inline">\(a\)</span>只大皮克敏和<span class="math inline">\(b\)</span>只小皮克敏还活着，则你会得到<span class="math inline">\(a\times b\times (a+b)\)</span>的分数。求期望分数。</p>
<p><span class="math inline">\(N, M\le 2000\)</span></p>
<h3 id="problem-b">Problem B</h3>
<p>众所周知，小葱同学擅长计算，尤其擅长计算组合数，但这个题和组合数没什么关系。</p>
<p>定义<span class="math inline">\(F_0=0,F_1=1,F_i=F_{i-1}+F_{i-2}\)</span>。求<span class="math inline">\(F(F(\cdots F(n)))\bmod m\)</span>（一共<span class="math inline">\(k\)</span>个<span class="math inline">\(F\)</span>）。</p>
<p><span class="math inline">\(k\le 5, n\le 10^{18}, m\le 10^{18}\)</span></p>
<hr />
<p>这个题应该单独成文吧…</p>
<h3 id="problem-c">Problem C</h3>
<p>众所周知，小葱同学擅长计算，尤其擅长计算组合数，但这个题和组合数没什么关系。</p>
<p><span class="math inline">\(N​\)</span>个数组，每个数组有<span class="math inline">\(M​\)</span>个<span class="math inline">\(0​\)</span>。五种操作：</p>
<ol type="1">
<li>给定<span class="math inline">\(i,l,r,v\)</span>，将第<span class="math inline">\(i\)</span>个数组的第<span class="math inline">\(l-r\)</span>个数增加<span class="math inline">\(v\)</span>。</li>
<li>给定<span class="math inline">\(i,l,r\)</span>，询问第<span class="math inline">\(i\)</span>个数组第<span class="math inline">\(l-r\)</span>个数的和、最小值、最大值。</li>
<li>给定<span class="math inline">\(l,r\)</span>，询问第<span class="math inline">\(l-r\)</span>个数组上所有数的和、最小值、最大值。<br />
</li>
<li>给定<span class="math inline">\(l,r,v\)</span>，将第<span class="math inline">\(l-r\)</span>个数组的所有数增加<span class="math inline">\(v\)</span>。</li>
<li>给定<span class="math inline">\(i,l,r,j,t\)</span>，将第<span class="math inline">\(i\)</span>个数组的第<span class="math inline">\(l-r\)</span>个数，移动到第<span class="math inline">\(j\)</span>个数组的第<span class="math inline">\(t\)</span>个数的后面。</li>
</ol>
<p><span class="math inline">\(N, M\leq 10^5\)</span></p>
<hr />
<p>屑题。一道 <span class="math inline">\(0\)</span> 思维难度的省选难度的题目。</p>
<p>开个线段树，每个叶子上面建动态开点 <code>splay</code> 就完事了。</p>
<p>标称 500 行。<del>标称不压行，长得跟小葱一样</del></p>
<hr />
<h2 id="round-8">Round 8</h2>
<h3 id="problem-a-1">Problem A</h3>
<p>定义数列<span class="math inline">\(F_0=f_0,F_1=f_1,F_i=c_1\times F_{i-1}+c_2\times F_{i-2}+c_3\)</span>。现在定义一个长度为n的数组里面的元素为<span class="math inline">\(F_0,F_1,\cdots ,F_{n-1}\)</span>。我们需要做<span class="math inline">\(m\)</span>次操作，每次取出数组中前<span class="math inline">\(k\)</span>个元素求和放到数组最后面去（不足<span class="math inline">\(k\)</span>个取全部）。输出操作完后数组的第一个和最后一个元素。</p>
<p><span class="math inline">\(1\leq n\leq10^{18},0\leq k,m\leq10^{18},f_0,f_1,c_1,c_2,c_3\leq 10^9\)</span>。</p>
]]></content>
      <categories>
        <category>比赛总结</category>
      </categories>
      <tags>
        <tag>未完成</tag>
      </tags>
  </entry>
  <entry>
    <title>「学习总结」清北学堂 十连测</title>
    <url>//%E3%80%8C%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93%E3%80%8D%E6%B8%85%E5%8C%97%E5%AD%A6%E5%A0%82-%E5%8D%81%E8%BF%9E%E6%B5%8B/</url>
    <content><![CDATA[<p>济南 清北学堂，NOIP考前十连测，题目整理。 <a id="more"></a> # 清北学堂 10 连测</p>
<h2 id="round-1">Round 1</h2>
<h3 id="a.-yist">A. yist</h3>
<div class="note info"><p>给出 <span class="math inline">\(n\)</span> 求 <span class="math inline">\(n! \operatorname{mod} 2^{32}\)</span>。</p>
</div>
<details class="note warning"><summary><p>Code</p>
</summary>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">int main()&#123;
	A[0] &#x3D; 1; rep(i, 1, 50) A[i] &#x3D; (A[i - 1] * i) % MOD;
	int T &#x3D; read();
	while(T--)&#123;
		int x &#x3D; read();
		if(x &lt;&#x3D; 50) printf(&quot;%llu\n&quot;, A[x]);
		else puts(&quot;0&quot;);
	&#125;
	return 0;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

</details>
<h3 id="b.-ernd">B. ernd</h3>
<div class="note info"><p>有一个 <span class="math inline">\(n\times m\)</span> 的网格，网格上的数字都在 <span class="math inline">\([1,nm]\)</span> 之间且两两不同。</p>
<p>有个限制，直观描述是位置左、上的格子必须比右、下的格子小，精确地说：<span class="math inline">\(A_{i,j} &lt; A_{i+1,j},A_{i,j} &lt; A_{i,j+1}\)</span> 必须成立，如果不等式中的两个位置都在网格内的话。</p>
<p>你想知道对于一个 <span class="math inline">\(k\)</span>，有多少个格子的值可以是 <span class="math inline">\(k\)</span>（即存在一种网格，使得它的值是 <span class="math inline">\(k\)</span>）。</p>
</div>
<details class="note success"><summary><p>Solution</p>
</summary>
考虑每个位置 <span class="math inline">\((i, j)\)</span> 能填哪些数字，这个位置到 <span class="math inline">\((1, 1)\)</span> 形成的矩形中的值都要大于 <span class="math inline">\((i, j)\)</span> 的值，这个位置到 <span class="math inline">\(n, m\)</span> 同理。
<details class="note warning">
<summary>
<p>
Code
</p>
<p></summary> <pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">int ans[_T], C[_T];
void work(int n, int  m)&#123;
	memset(C, 0, sizeof(C));
	rep(i, 1, n) rep(j, 1, m)&#123;
		int L &#x3D; i * j, R &#x3D; n * m - ((n - i + 1) * (m - j + 1) - 1);
		C[L]++; C[R + 1]--;
	&#125;
	int now &#x3D; 0;
	rep(i, 1, n * m) now +&#x3D; C[i], ans[i] &#x3D; now;
	int q &#x3D; read();
	while(q--) printf(&quot;%d\n&quot;, ans[read()]);
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></p>
</details>

</details>
<h3 id="c.-sanrd">C. sanrd</h3>
<div class="note info"><p>小Y有一个排列 <span class="math inline">\(P_{1..n}\)</span>，作为强迫症患者，她想要把排列排好序。共有 3 种操作。</p>
<p>花费 <span class="math inline">\(a\)</span> 的代价交换相邻两个数。</p>
<p>花费 <span class="math inline">\(b\)</span> 的代价翻转整个排列。</p>
<p>花费 <span class="math inline">\(c\)</span> 的代价打乱整个排列，新排列随机生成。</p>
<p>小Y需要知道，在最优策略下，她需要花费多大的代价呢？</p>
</div>
<details class="note success"><summary><p>Solution</p>
</summary>
最优的操作，显然是先打乱排列（如果有），再翻转排列（如果有），最后交换相邻两个数（如果有）。
<div class="note danger">
<h4 id="几个事实">
几个事实
</h4>
<ul>
<li>
<span class="math inline">(A_i &gt; A_j, i + 1 = j)</span> 是交换相邻两个数字的必要条件。
</li>
<li>
执行一次交换操作逆序对数量会减少且仅减少一。
</li>
<li>
答案只与逆序对数量有关。
</li>
<li>
打乱后随机生成的代价就是 <span class="math inline">(c)</span> + 长度为 <span class="math inline">(n)</span> 的所有排列排好代价的平均值。只要使用最后一种操作，那么他们的答案一定相同。
</li>
</ul>
</div>
<p>
设排列 <span class="math inline">([P])</span> 的逆序对数为 <span class="math inline">(x)</span> ，如果只使用前两种操作， 代价就是 <span class="math inline">({( - x) a + b, x a})</span>。 把 <span class="math inline">([p])</span> 的所有排列按照只用前两种操作的花费排好序，那么可能使用最后一种操作的一定是一段后缀。
</p>
<p>
以 <span class="math inline">([p])</span> 的所有排列按照只用前两种操作的花费排好序的下标为 <span class="math inline">(x)</span> 轴，代价为 <span class="math inline">(y)</span> 轴，那么只用前两种操作就是绿色的图像。 如果对某些排列使用第三种操作，可以用橙色的图像表示。 <img src="/oi-blog/post_images/qbxt_Round0_C.png" alt="Round0_C.png" /> 其中被函数值压平的部分就是 <span class="math inline">(c)</span> + 所有排列代价的平均值。 枚举是多长的后缀被压平（使用第三种操作）。然后解方程解出函数值平均值，选取最小的平均值即可。
</p>
<p>
如果排列数比较多，无法一个一个的算出来，可以通过 dp 求出长度为 <span class="math inline">(n)</span> 的排列，逆序对个数为 <span class="math inline">(k)</span> 的排列数。可以注意到，逆序对数相同的排列，答案一定是一样的，可以把逆序对是相同的排列捆绑计算，逆序对数一共有 <span class="math inline">( + 1)</span> 种取值。
</p>
<details class="note warning">
<summary>
<p>
我的代码只能通过 70% 的数据
</p>
<p></summary> <pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">#include &lt;cstdio&gt;
#include &lt;cstring&gt;
#include &lt;cmath&gt;
#include &lt;iostream&gt;
#include &lt;cmath&gt;
#include &lt;algorithm&gt;
#include &lt;climits&gt;
#include &lt;assert.h&gt;
#include &lt;vector&gt;
#define LL long long
#define int long long
#define rep(i, l, r) for(int i &#x3D; (l), ___ &#x3D; (r); i &lt;&#x3D; ___; i++)
#define per(i, l, r) for(int i &#x3D; (r), ___ &#x3D; (l); i &gt;&#x3D; ___; i--)
using namespace std;
struct Read_t&#123;
	template&lt;typename T&gt; const Read_t &amp; operator() ( T &amp; target ) const &#123;
		T x &#x3D; 0; int sign &#x3D; 1; char c &#x3D; getchar();
		while(c &lt; &#39;0&#39; || c &gt; &#39;9&#39;) &#123; if(c &#x3D;&#x3D; &#39;-&#39;) sign &#x3D; -1; c &#x3D; getchar(); &#125;
		while(c &lt;&#x3D; &#39;9&#39; &amp;&amp; c &gt;&#x3D; &#39;0&#39;) &#123; x &#x3D; (x &lt;&lt; 1) + (x &lt;&lt; 3); x +&#x3D; c - &#39;0&#39;; c &#x3D; getchar(); &#125;
		target &#x3D; x * sign; return *this;
	&#125;
&#125; Read;
#warning dont forget enable int_64
const int _N &#x3D; 500;
const int _S &#x3D; 500;
LL gcd(LL a, LL b)&#123; return b &#x3D;&#x3D; 0 ? a : gcd(b,  a % b); &#125;
LL dp[_N][_S];
LL n, a, b, c, d;
#define pb push_back
#define mp make_pair
#define fi first
#define se second
pair&lt;LL, LL&gt; Val[_S];
bool operator &gt; (pair&lt;LL, LL&gt; A, pair&lt;LL, LL&gt; B)&#123; return (A.fi * B.se &gt; A.se * B.fi); &#125;
LL A[_S];
void doit()&#123;
	Read(n)(a)(b)(c)(d); vector&lt;pair&lt;LL, LL&gt; &gt; V; V.clear();
	rep(i, 0, (n) * (n - 1) &#x2F; 2) V.pb(mp(min(i * a, ((n * (n - 1) &#x2F; 2) - i) * a + b), dp[n][i]));
	sort(V.begin(), V.end());
	int tot &#x3D; 0;
	rep(L, 0, V.size() - 1)&#123;
		int R &#x3D; L; while(V[R + 1].fi &#x3D;&#x3D; V[L].fi &amp;&amp; R + 1 &lt;&#x3D; (int)(V.size()) - 1) R++; LL sum &#x3D; 0;
		rep(i, L, R) sum +&#x3D; V[i].se;

		V[tot].fi &#x3D; V[L].fi; V[tot].se &#x3D; sum;
		tot++;
		L &#x3D; R;
	&#125; LL S &#x3D; 0; rep(i, 0, tot - 1) S +&#x3D; V[i].se;
	rep(i, 0, tot - 1)&#123;
		LL cnt &#x3D; 0; rep(j, i, tot - 1) cnt +&#x3D; V[j].se;
		LL A &#x3D; cnt * c;  rep(j, 0, i - 1) A +&#x3D; V[j].fi * V[j].se;
		LL B &#x3D; S - cnt;
		LL g &#x3D; gcd(A, B); Val[i] &#x3D; mp(A &#x2F; g, B &#x2F; g);
	&#125;

	int Mid &#x3D; 0; rep(i, 0, tot - 1) if(Val[Mid] &gt; Val[i]) Mid &#x3D; i;
	pair&lt;LL, LL&gt; MAns &#x3D; Val[Mid]; MAns.fi +&#x3D; MAns.se * c; LL g &#x3D; gcd(MAns.fi, MAns.se); MAns.fi &#x2F;&#x3D; g; MAns.se &#x2F;&#x3D; g;
	while(d--)&#123;
		rep(i, 1, n) Read(A[i]);
		LL ans &#x3D; 0;
		rep(i, 1, n) rep(j, i + 1, n) ans +&#x3D; (A[i] &gt; A[j]);
		ans &#x3D; min(ans * a, b + a * ((n * (n - 1) &#x2F; 2) - ans));
		if(ans * MAns.se &lt; MAns.fi) printf(&quot;%lld&#x2F;1\n&quot;, ans);
		else printf(&quot;%lld&#x2F;%lld\n&quot;, MAns.fi, MAns.se); assert(MAns.fi &gt; 0);  assert(MAns.se &gt; 0);
	&#125;
&#125;
void Init(int n) &#123;
	dp[1][0] &#x3D; 1;
	rep(i, 2, n) &#123;
		rep(j, 0, ((i) * (i - 1)) &#x2F; 2) &#123;
			LL &amp;ans &#x3D; dp[i][j] &#x3D; 0;
			rep(k, 0, min(i - 1, j)) ans +&#x3D; dp[i - 1][j - k];
		&#125;
	&#125;
&#125;
signed main()&#123; freopen(&quot;in.txt&quot;, &quot;r&quot;, stdin);
	Init(17);
	int T; Read(T);
	while(T--) doit();
	return 0;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></p>
</details>
<details class="note warning">
<summary>
<p>
官方标程
</p>
<p></summary> <pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">#include &lt;bits&#x2F;stdc++.h&gt;
#define fi first
#define se second
#define pb push_back
#define mp make_pair
#define SZ(x) ((int)x.size())
#define ALL(x) x.begin(), x.end()
#define L(i, u) for (register int i &#x3D; head[u]; i; i &#x3D; nxt[i])
#define rep(i, a, b) for (register int i &#x3D; (a); i &lt;&#x3D; (b); i++)
#define per(i, a, b) for (register int i &#x3D; (a); i &gt;&#x3D; (b); i--)
using namespace std;
typedef long double ld;
typedef long long ll;
typedef unsigned int ui;
typedef pair&lt;ll, ll&gt; Pll;
typedef vector&lt;int&gt; Vi;
template &lt;class T&gt;
inline void read(T &amp;x)&#123;x &#x3D; 0;char c &#x3D; getchar();int f &#x3D; 1; while (!isdigit(c)) &#123; if (c &#x3D;&#x3D; &#39;-&#39;) f &#x3D; -1; c &#x3D; getchar(); &#125; while (isdigit(c)) &#123; x &#x3D; x * 10 + c - &#39;0&#39;; c &#x3D; getchar(); &#125; x *&#x3D; f; &#125;
template &lt;class T&gt;
T gcd(T a, T b) &#123; return !b ? a : gcd(b, a % b); &#125;
template &lt;class T&gt;
inline void umin(T &amp;x, T y) &#123; x &#x3D; x &lt; y ? x : y; &#125;
template &lt;class T&gt;
inline void umax(T &amp;x, T y) &#123; x &#x3D; x &gt; y ? x : y; &#125;
ll dp[1 &lt;&lt; 16 | 3][141];
struct Yzr
&#123;
	int n;
	ll gs[141];
	void ini(int nn)
	&#123;
		n &#x3D; nn;
		memset(dp, 0, sizeof(dp));
		dp[0][0] &#x3D; 1;
		rep(s, 0, (1 &lt;&lt; n) - 1) rep(i, 1, n) if (~s &gt;&gt; i - 1 &amp; 1)
		&#123;
			int del &#x3D; 0, cnt &#x3D; 0;
			rep(j, i + 1, n) del +&#x3D; s &gt;&gt; j - 1 &amp; 1;
			rep(j, 1, n) cnt +&#x3D; s &gt;&gt; j - 1 &amp; 1;
			rep(k, 0, cnt * (cnt + 1) &gt;&gt; 1) dp[s | 1 &lt;&lt; i - 1][k + del] +&#x3D; dp[s][k];
		&#125;
		rep(k, 0, n * (n + 1) &gt;&gt; 1) gs[k] &#x3D; dp[(1 &lt;&lt; n) - 1][k];
	&#125;
&#125; yzr[17];
bool cmp(Pll a, Pll b) &#123; return (ld)a.fi &#x2F; a.se &lt; (ld)b.fi &#x2F; b.se; &#125;
ll n, a, b, c, d, qz[141], p[166];
Pll s[166];
ll calc(ll x) &#123; return min(x * a, (n * (n - 1) &#x2F; 2 - x) * a + b); &#125;
int main()
&#123;
	freopen(&quot;in.txt&quot;, &quot;r&quot;, stdin);
	rep(n, 2, 16) yzr[n].ini(n);
	int T;
	read(T);
	while (T--)
	&#123;
		read(n); read(a); read(b); read(c); read(d);
		Pll res(1e18, 1);
		ll tot &#x3D; 1;
		rep(i, 1, n) tot *&#x3D; i;
		int len &#x3D; 0;
		rep(i, 0, n * (n + 1) &#x2F; 2) if (yzr[n].gs[i]) s[++len] &#x3D; mp(calc(i), yzr[n].gs[i]);
		sort(s + 1, s + len + 1);
		static ll qz[166], hz[166];
		rep(i, 1, len) qz[i] &#x3D; qz[i - 1] + s[i].fi * s[i].se;
		hz[len + 1] &#x3D; 0;
		per(i, len, 1) hz[i] &#x3D; hz[i + 1] + s[i].se;
		rep(i, 1, len)
		&#123;
			Pll cur &#x3D; mp(qz[i] + hz[i + 1] * c, tot - hz[i + 1]);
			if (cmp(cur, res))
				res &#x3D; cur;
		&#125;
		pair&lt;ll, ll&gt; ans &#x3D; mp(res.fi + c * res.se, res.se);
		cerr &lt;&lt; &quot;N &#x3D; &quot; &lt;&lt; n &lt;&lt; endl;
		cout &lt;&lt; ans.fi &lt;&lt; &quot; &quot; &lt;&lt; ans.se &lt;&lt; endl;
		while (d--)
		&#123;
			rep(i, 1, n) read(p[i]);
			int nx &#x3D; 0;
			rep(i, 1, n) rep(j, i + 1, n) nx +&#x3D; p[i] &gt; p[j];
			Pll ans &#x3D; mp(calc(nx), 1);
			if (cmp(mp(res.fi + c * res.se, res.se), ans))
				ans &#x3D; mp(res.fi + c * res.se, res.se);
			ll g &#x3D; gcd(ans.fi, ans.se);
			ans.fi &#x2F;&#x3D; g;
			ans.se &#x2F;&#x3D; g;
			printf(&quot;%lld&#x2F;%lld\n&quot;, ans.fi, ans.se);
		&#125;
	&#125;
	return 0;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></p>
</details>

</details>
<h3 id="d.-sith">D. sith</h3>
<div class="note info"><p>你有 <span class="math inline">\(k\)</span> 棵点数均为 <span class="math inline">\(n\)</span> 的树</p>
<p>对于每对点 <span class="math inline">\(i,j\)</span>，你都需要求出，有多少个点 <span class="math inline">\(x\)</span>，满足在所有树中都在 <span class="math inline">\(i\leftrightarrow j\)</span> 的树链上（树链包含端点即 <span class="math inline">\(i,j\)</span>）。</p>
</div>
<details class="note success"><summary><p>Solution</p>
</summary>
<p>定义函数 <span class="math inline">\(\operatorname{dis_t}(x, y)\)</span> 为 <span class="math inline">\(x\)</span>，<span class="math inline">\(y\)</span> 这两个结点在树 <span class="math inline">\(t\)</span> 上的最短距离（简单路径长度）。</p>
<p>对于一棵树 <span class="math inline">\(t\)</span> ，“<span class="math inline">\(\operatorname{dis_t}(i, j) = \operatorname{dis_t}(i, x) + \operatorname{dis_t}(x, j)\)</span>” 为 “点 <span class="math inline">\(x\)</span> 在 点<span class="math inline">\(i\)</span> <span class="math inline">\(\leftrightarrow\)</span> 点 <span class="math inline">\(j\)</span> 的树链上” 的充要条件。</p>
<p>扩展一下可以发现</p>
<p>对于森林 <span class="math inline">\(T\)</span>，“<span class="math inline">\(\sum_{t \in T}\limits{\operatorname{dis_t}(i, j)} = \sum_{t \in T}\limits{\operatorname{dis_t}(i, x)} + \sum_{t \in T}\limits{\operatorname{dis_t}(x, j)}\)</span>” 为 “对于每棵树 点 <span class="math inline">\(x\)</span> 在 点<span class="math inline">\(i\)</span> <span class="math inline">\(\leftrightarrow\)</span> 点 <span class="math inline">\(j\)</span> 的树链上” 的充要条件。</p>
这样就可以分开算了，随便做就好了。
<details class="note warning">
<summary>
<p>
code
</p>
<p></summary> <pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">#include &lt;bits&#x2F;stdc++.h&gt;
#define fi first
#define se second
#define pb push_back
#define mp make_pair
#define SZ(x) ((int)x.size())
#define ALL(x) x.begin(), x.end()
#define L(i, u) for (register int i &#x3D; head[u]; i; i &#x3D; nxt[i])
#define rep(i, a, b) for (register int i &#x3D; (a); i &lt;&#x3D; (b); i++)
#define per(i, a, b) for (register int i &#x3D; (a); i &gt;&#x3D; (b); i--)
using namespace std;
typedef long double ld;
typedef long long ll;
typedef unsigned int ui;
typedef pair&lt;int, int&gt; Pii;
typedef vector&lt;int&gt; Vi;
template &lt;class T&gt;
inline void read(T &amp;x)&#123;x &#x3D; 0;char c &#x3D; getchar();int f &#x3D; 1;while (!isdigit(c))&#123;if (c &#x3D;&#x3D; &#39;-&#39;)f &#x3D; -1;c &#x3D; getchar();&#125;while (isdigit(c))&#123;x &#x3D; x * 10 + c - &#39;0&#39;;c &#x3D; getchar();&#125;x *&#x3D; f;&#125;
template &lt;class T&gt;
T gcd(T a, T b) &#123; return !b ? a : gcd(b, a % b); &#125;
template &lt;class T&gt;
inline void umin(T &amp;x, T y) &#123; x &#x3D; x &lt; y ? x : y; &#125;
template &lt;class T&gt;
inline void umax(T &amp;x, T y) &#123; x &#x3D; x &gt; y ? x : y; &#125;
template &lt;class T&gt;
inline T Abs(const T &amp;x) &#123; return x &gt; 0 ? x : -x; &#125;
inline ui R()
&#123;
	static ui seed &#x3D; 613;
	return seed ^&#x3D; seed &gt;&gt; 5, seed ^&#x3D; seed &lt;&lt; 17, seed ^&#x3D; seed &gt;&gt; 13;
&#125;
const int N &#x3D; 505;
int n, k, dis[N][N];
Vi e[N];
void dfs(int s, int u, int fa, int dep)
&#123;
	dis[s][u] +&#x3D; dep;
	for (int v : e[u])
		if (v !&#x3D; fa)
			dfs(s, v, u, dep + 1);
&#125;
int main()
&#123;
	read(n);read(k);
	rep(tt, 1, k)&#123;
		rep(i, 1, n) e[i].clear();
		rep(i, 1, n - 1)&#123;
			int u, v;read(u);read(v);
			e[u].pb(v);e[v].pb(u);
		&#125;
		rep(i, 1, n) dfs(i, i, 0, 0);
	&#125;
	rep(i, 1, n) rep(j, 1, n)
	&#123;
		int ans &#x3D; 0;
		rep(x, 1, n) ans +&#x3D; dis[i][x] + dis[j][x] &#x3D;&#x3D; dis[i][j];
		printf(&quot;%d%c&quot;, ans, j &lt; n ? &#39; &#39; : &#39;\n&#39;);
	&#125;
	return 0;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></p>
</details>

</details>
<h2 id="round-2">Round 2</h2>
<h3 id="a.-one">A. one</h3>
<div class="note info"><p>给你一个长度为 <span class="math inline">\(n\)</span> 的数组，你需要将其划分为若干个连续段。对于一种划分，定义其权值为，求出每段的段内所有元素 xor 值，再把所有段的 xor 值相加即为权值。</p>
<p>你需要计算对于所有划分，这个权值的最小、最大值分别是多少。 <span class="math inline">\(n \le 10^6\)</span></p>
</div>
<details class="note success"><summary><p>Solution</p>
</summary>
<p><span class="math inline">\(A \operatorname{xor} B \le A + B\)</span></p>
<p><span class="math inline">\(A \ \And B \le A\ |\ B \le A + B\)</span></p>
<p>全部拆开最大，全部合并最小。 <pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">int main()&#123;
	int n, MIN &#x3D; 0; LL MAX &#x3D; 0; Read(n);
	rep(i, 1, n) &#123; int x; Read(x); MIN ^&#x3D; x; MAX +&#x3D; x; &#125;
	printf(&quot;%d %lld&quot;, MIN, MAX);
	return 0;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></p>

</details>
<h3 id="b.-two">B. two</h3>
<div class="note info"><p>有一个 <span class="math inline">\(1..n\)</span> 依次连成的环，有一个从 <span class="math inline">\(1\)</span> 开始移动的指针，每次指针所在位置有<span class="math inline">\(p\)</span>的概率消失并将这个位置对应的下标（在 <span class="math inline">\(1..n\)</span> 中）插入序列 <span class="math inline">\(B\)</span> 的末尾，然后指针移动一格（ <span class="math inline">\(1\)</span> 移到 <span class="math inline">\(2\)</span>，<span class="math inline">\(n\)</span> 移到 <span class="math inline">\(1\)</span> 这样，一个位置若已经消失则不会被移动到）。所有位置都消失时游戏结束。最后 <span class="math inline">\(B\)</span> 会是一个排列。</p>
<p>这道题跟序列 <span class="math inline">\(B\)</span> 没什么关系，你只需要求出游戏期望进行几轮，答案对 <span class="math inline">\(998244353\)</span> 取模。</p>
<p>读入描述： 一行三个整数 <span class="math inline">\(n,x,y\)</span>。概率 <span class="math inline">\(p=\frac x y\)</span></p>
</div>
<details class="note success"><summary><p>solution</p>
</summary>
<p>设 <span class="math inline">\(f[n]\)</span> 为 长度为 <span class="math inline">\(n\)</span> 还需要进行多少轮。</p>
<p>易知 <span class="math inline">\(f[n] = 1 + p \times f[n - 1] + \left(1 - p \right) \times f[n]\)</span></p>
<p>移项得 <span class="math inline">\(f[n] = n \times \frac{1}{p}\)</span> <pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">int main()&#123;
	Read(n)(x)(y);
	printf(&quot;%d&quot;, int(n *1ll* y % MOD *1ll* inv(x, MOD) % MOD));
	return 0;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre></p>

</details>
<h3 id="c.-three">C. three</h3>
<div class="note info"><p>小Y拥有一个序列<span class="math inline">\(a_i\)</span>（从0开始标号）。</p>
<p>小Y想要对序列进行<span class="math inline">\(Q\)</span>次操作，操作有下面几种：</p>
<ul>
<li><span class="math inline">\(t=0\)</span>：对区间<span class="math inline">\([l,r]\)</span>执行<span class="math inline">\(a_i=a_i+x\)</span></li>
<li><span class="math inline">\(t=1\)</span>：对区间<span class="math inline">\([l,r]\)</span>执行<span class="math inline">\(a_i=\lfloor \frac {a_i} {x} \rfloor\)</span></li>
<li><span class="math inline">\(t=2\)</span>：查询区间<span class="math inline">\([l,r]\)</span>的<span class="math inline">\(\max {a_i}\)</span></li>
<li><span class="math inline">\(t=3\)</span>：把区间<span class="math inline">\([l,r]\)</span>的<span class="math inline">\(a_i\)</span>恢复为初始给出的<span class="math inline">\(a_i\)</span> <span class="math inline">\(a_i \le 10^8; n, Q \le 10^5\)</span></li>
</ul>
</div>
<details class="note success"><summary><p>Solution</p>
</summary>
<h4 id="定义一类特殊标记">定义一类特殊标记</h4>
<p>记录标记 <span class="math inline">\(a, b, c\)</span> 表示 <span class="math inline">\(x\)</span> 变成 <span class="math inline">\(\lfloor \frac{x + a}{b} \rfloor + c\)</span>。 其中要求 <span class="math inline">\(a &lt; b\)</span>。 - 对于加法操作 <span class="math inline">\(c += x\)</span> 即可。 - 对于除法操作如果是除 <span class="math inline">\(d\)</span> ：<span class="math inline">\(\lfloor \frac{ \lfloor \frac{x + a}{b} \rfloor + c}{d} \rfloor = \lfloor \frac{ \lfloor \frac{x + a + bc}{b} \rfloor}{d} \rfloor = \lfloor \frac{x + a + bc}{bd} \rfloor\)</span> 然后优化一下 <span class="math inline">\(x + a + bc\)</span> 保持 <span class="math inline">\(a&#39; &lt; b&#39;\)</span>，类似于假分数换算带分数，保证不会爆<code>long long</code>。</p>
<p>对于处理除数过大的情况： <pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">if (fm &gt; inf) fz &#x3D; max(0ll, fz + (inf - fm)), fm &#x3D; inf;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre> 如果分母 <span class="math inline">\(&gt; \operatorname{inf}\)</span>，那么 <span class="math inline">\(\lfloor \frac{x + a}{b} \rfloor + c\)</span> 等价于 <span class="math inline">\([x \ge b - a] + c\)</span> 当分母很大时，可以使得 <span class="math inline">\(a, b\)</span> 同时减去一个常数使得 <span class="math inline">\(b\)</span> 不会溢出，对于 <span class="math inline">\([x \ge b - a] + c\)</span> 不影响取值。 <pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">#include &lt;bits&#x2F;stdc++.h&gt;
#define fi first
#define se second
#define pb push_back
#define mp make_pair
#define SZ(x) ((int)x.size())
#define ALL(x) x.begin(), x.end()
#define L(i, u) for (register int i &#x3D; head[u]; i; i &#x3D; nxt[i])
#define rep(i, a, b) for (register int i &#x3D; (a); i &lt;&#x3D; (b); i++)
#define per(i, a, b) for (register int i &#x3D; (a); i &gt;&#x3D; (b); i--)
using namespace std;
typedef long double ld;
typedef long long ll;
typedef unsigned int ui;
typedef pair&lt;int, int&gt; Pii;
typedef vector&lt;int&gt; Vi;
template &lt;class T&gt;
T gcd(T a, T b) &#123; return !b ? a : gcd(b, a % b); &#125;
template &lt;class T&gt;
inline void umin(T &amp;x, T y) &#123; x &#x3D; x &lt; y ? x : y; &#125;
template &lt;class T&gt;
inline void umax(T &amp;x, T y) &#123; x &#x3D; x &gt; y ? x : y; &#125;
inline ui R()
&#123;
	static ui seed &#x3D; 416;
	return seed ^&#x3D; seed &gt;&gt; 5, seed ^&#x3D; seed &lt;&lt; 17, seed ^&#x3D; seed &gt;&gt; 13;
&#125;
const int N &#x3D; 233333, inf &#x3D; 2e9 + 1e8;
struct node
&#123;
	ll ans;
	bool emp;
	ll a, b, c, mx; &#x2F;&#x2F;(x+a)&#x2F;b+c (a&lt;b&lt;&#x3D;inf)
	node() &#123; b &#x3D; 1; &#125;
&#125; tree[N &lt;&lt; 2];
inline void pushadd(int k, ll x) &#123;
	tree[k].ans +&#x3D; x; tree[k].c +&#x3D; x;
&#125;
inline void pushdiv(int k, int d) &#123;
	tree[k].ans &#x2F;&#x3D; d;
	ll fm &#x3D; 1ll * tree[k].b * d, tmp &#x3D; (tree[k].a + 1ll * tree[k].b * tree[k].c) &#x2F; fm;
	ll fz &#x3D; (tree[k].a + 1ll * tree[k].b * tree[k].c) - fm * tmp;
	tree[k].c &#x3D; tmp;
	if (fm &gt; inf) fz &#x3D; max(0ll, fz + (inf - fm)), fm &#x3D; inf;
	tree[k].a &#x3D; fz, tree[k].b &#x3D; fm;
	&#x2F;&#x2F;	printf(&quot;%d:%lld %lld %lld\n&quot;,k,tree[k].a,tree[k].b,tree[k].c);
&#125;
inline void pushemp(int k) &#123;
	tree[k].emp &#x3D; 1;
	tree[k].a &#x3D; tree[k].c &#x3D; 0;
	tree[k].b &#x3D; 1;
	tree[k].ans &#x3D; tree[k].mx;
&#125;
inline void pushdown(int k) &#123;
	if (tree[k].emp) pushemp(k &lt;&lt; 1), pushemp(k &lt;&lt; 1 | 1), tree[k].emp &#x3D; 0;
	if (tree[k].a) pushadd(k &lt;&lt; 1, tree[k].a), pushadd(k &lt;&lt; 1 | 1, tree[k].a), tree[k].a &#x3D; 0;
	if (tree[k].b !&#x3D; 1) pushdiv(k &lt;&lt; 1, tree[k].b), pushdiv(k &lt;&lt; 1 | 1, tree[k].b), tree[k].b &#x3D; 1;
	if (tree[k].c) pushadd(k &lt;&lt; 1, tree[k].c), pushadd(k &lt;&lt; 1 | 1, tree[k].c), tree[k].c &#x3D; 0;
&#125;
inline void upd(int k)&#123; tree[k].ans &#x3D; max(tree[k &lt;&lt; 1].ans, tree[k &lt;&lt; 1 | 1].ans); &#125;
void mdy1(int k, int l, int r, int x, int L, int R) &#123;
	if (l &#x3D;&#x3D; L &amp;&amp; r &#x3D;&#x3D; R) &#123; pushadd(k, x); return; &#125;
	int mid &#x3D; (L + R) &gt;&gt; 1;
	pushdown(k);
	if (r &lt;&#x3D; mid) mdy1(k &lt;&lt; 1, l, r, x, L, mid);
	else if (l &gt; mid) mdy1(k &lt;&lt; 1 | 1, l, r, x, mid + 1, R);
	else mdy1(k &lt;&lt; 1, l, mid, x, L, mid), mdy1(k &lt;&lt; 1 | 1, mid + 1, r, x, mid + 1, R);
	upd(k);
&#125;
void mdy2(int k, int l, int r, int x, int L, int R) &#123;
	if (l &#x3D;&#x3D; L &amp;&amp; r &#x3D;&#x3D; R) &#123; pushdiv(k, x); return; &#125;
	int mid &#x3D; (L + R) &gt;&gt; 1;
	pushdown(k);
	if (r &lt;&#x3D; mid) mdy2(k &lt;&lt; 1, l, r, x, L, mid);
	else if (l &gt; mid) mdy2(k &lt;&lt; 1 | 1, l, r, x, mid + 1, R);
	else mdy2(k &lt;&lt; 1, l, mid, x, L, mid), mdy2(k &lt;&lt; 1 | 1, mid + 1, r, x, mid + 1, R);
	upd(k);
&#125;
void mdy3(int k, int l, int r, int x, int L, int R) &#123;
	if (l &#x3D;&#x3D; L &amp;&amp; r &#x3D;&#x3D; R) &#123; pushemp(k); return; &#125;
	int mid &#x3D; (L + R) &gt;&gt; 1;
	pushdown(k);
	if (r &lt;&#x3D; mid) mdy3(k &lt;&lt; 1, l, r, x, L, mid);
	else if (l &gt; mid) mdy3(k &lt;&lt; 1 | 1, l, r, x, mid + 1, R);
	else mdy3(k &lt;&lt; 1, l, mid, x, L, mid), mdy3(k &lt;&lt; 1 | 1, mid + 1, r, x, mid + 1, R);
	upd(k);
&#125;
int qry(int k, int l, int r, int x, int L, int R)
&#123;
	if (l &#x3D;&#x3D; L &amp;&amp; r &#x3D;&#x3D; R) return tree[k].ans;
	int mid &#x3D; (L + R) &gt;&gt; 1;
	pushdown(k);
	if (r &lt;&#x3D; mid)
		return qry(k &lt;&lt; 1, l, r, x, L, mid);
	else if (l &gt; mid)
		return qry(k &lt;&lt; 1 | 1, l, r, x, mid + 1, R);
	return max(qry(k &lt;&lt; 1, l, mid, x, L, mid), qry(k &lt;&lt; 1 | 1, mid + 1, r, x, mid + 1, R));
&#125;
int n, q, a[N];
void build(int k, int l, int r)
&#123;
	if (l &#x3D;&#x3D; r) &#123; tree[k].mx &#x3D; tree[k].ans &#x3D; a[l]; return; &#125;
	int mid &#x3D; (l + r) &gt;&gt; 1;
	build(k &lt;&lt; 1, l, mid);
	build(k &lt;&lt; 1 | 1, mid + 1, r);
	tree[k].mx &#x3D; tree[k].ans &#x3D; max(tree[k &lt;&lt; 1].mx, tree[k &lt;&lt; 1 | 1].mx);
&#125;
int main()
&#123;
	read(n); read(q); rep(i, 0, n - 1) read(a[i]);
	build(1, 0, n - 1);
	while (q--)
	&#123;
		int op, l, r, x;
		read(op); read(l); read(r); read(x);
		if (op &#x3D;&#x3D; 0) mdy1(1, l, r, x, 0, n - 1);
		else if (op &#x3D;&#x3D; 1) mdy2(1, l, r, x, 0, n - 1);
		else if (op &#x3D;&#x3D; 2) printf(&quot;%d\n&quot;, qry(1, l, r, 0, 0, n - 1));
		else mdy3(1, l, r, x, 0, n - 1);
	&#125;
	return 0;
&#125;
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre> #### 浮点数运算控制精度 直接全部转化成浮点数运算，三标记线段树。</p>
<p>考虑到浮点数自带精度损失，对于较大的除数，自动使得原数变成零，<code>long double</code> 的精度可以支持。</p>
<div class="note warning">
<p>
爆零小技巧：<code>ST</code>表空间开一倍 <pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">int ST[_][LOG + 3], Log[_];
void init_query()&#123;
	rep(i, 1, n) ST[i][0] &#x3D; A[i];
	rep(j, 1, LOG) rep(i, 1, n) ST[i][j] &#x3D; max(ST[i][j - 1], ST[i + (1 &lt;&lt; (j - 1))][j - 1]); &#x2F;&#x2F; ST[i + (1 &lt;&lt; (j - 1))][j - 1] 会访问 O( 2 * N )
	Log[1] &#x3D; 0; rep(i, 2, n) Log[i] &#x3D; Log[i &gt;&gt; 1] + 1;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
</p>
</div>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">const int _ &#x3D; 2e5 + 100;
int n, q; LL A[_];
namespace Acceptable_Solution&#123;
	const int _ &#x3D; 2e5 + 100;
	const int LOG &#x3D; 17;
	int ST[_][LOG + 3], Log[_];
	void init_query()&#123;
		rep(i, 1, n) ST[i][0] &#x3D; A[i];
		rep(j, 1, LOG) rep(i, 1, n) ST[i][j] &#x3D; max(ST[i][j - 1], ST[i + (1 &lt;&lt; (j - 1))][j - 1]);
		Log[1] &#x3D; 0; rep(i, 2, n) Log[i] &#x3D; Log[i &gt;&gt; 1] + 1;
	&#125;
	int Query_Max(int L, int R) &#123; int Lg &#x3D; Log[R - L + 1]; int Len &#x3D; (1 &lt;&lt; Lg); return max(ST[L][Lg], ST[R - Len + 1][Lg]); &#125;
	#define LB long double
	LB eps;
	void print(LB x) &#123; printf(&quot;%.20Lf\n&quot;, x); &#125;
	namespace SegmentTree&#123;
		bool same(LB x, LB y) &#123; return fabs(x - y) &lt;&#x3D; 1e-12; &#125;
		const int _ &#x3D; 6e5 + 100;
		int ch[_][2], tot &#x3D; 0;
		LB v[_], tag_add[_], tag_mul[_];
		bool tag_ret[_];
		#define ls(o) (ch[o][0])
		#define rs(o) (ch[o][1])
		#define maintain(o) (v[o] &#x3D; max(v[ls(o)], v[rs(o)]))
		#define make (tot++, ch[tot][0] &#x3D; ch[tot][1] &#x3D; 0, tag_add[tot] &#x3D; 0, tag_mul[tot] &#x3D; 1, tag_ret[tot] &#x3D; 0, tot)
		int Groot()&#123; return make; &#125;
		void build(int o, int L, int R)&#123;
			if(L &#x3D;&#x3D; R) return (void)(v[o] &#x3D; A[L]);
			int mid &#x3D; (L + R) &gt;&gt; 1; ls(o) &#x3D; make; rs(o) &#x3D; make;
			build(ls(o), L, mid); build(rs(o), mid + 1, R);
			maintain(o);
		&#125;
		void tar_ret(int o, int L, int R)&#123;
			v[o] &#x3D; Query_Max(L, R);
			tag_add[o] &#x3D; 0; tag_mul[o] &#x3D; 1;
			tag_ret[o] &#x3D; 1;
		&#125;
		void push_ret(int o, int L, int R)&#123;
			if(!tag_ret[o]) return ;
			int mid &#x3D; (L + R) &gt;&gt; 1;
			tar_ret(ls(o), L, mid); tar_ret(rs(o), mid + 1, R);
			tag_ret[o] &#x3D; 0;
		&#125;
		void tar_add(int o, LB Val, int L, int R)&#123;
			push_ret(o, L, R);
			v[o] +&#x3D; Val;
			tag_add[o] +&#x3D; Val;
		&#125;
		void tar_mul(int o, LB Val, int L, int R) &#123;
			push_ret(o, L, R);
			v[o] *&#x3D; Val;
			tag_mul[o] *&#x3D; Val;
			tag_add[o] *&#x3D; Val;
		&#125;
		void push(int o, int L, int R)&#123;
			push_ret(o, L, R);
			int mid &#x3D; (L + R) &gt;&gt; 1;
			if(!same(tag_mul[o], 1)) &#123;
				tar_mul(ls(o), tag_mul[o], L, mid);
				tar_mul(rs(o), tag_mul[o], mid + 1, R);
				tag_mul[o] &#x3D; 1;
			&#125;
			if(!same(tag_add[o], 0))&#123;
				tar_add(ls(o), tag_add[o], L, mid);
				tar_add(rs(o), tag_add[o], mid + 1, R);
				tag_add[o] &#x3D; 0;
			&#125;
		&#125;
		void update_add(int o, int nowl, int nowr, int L, int R, int Val)&#123;
			if(L &lt;&#x3D; nowl &amp;&amp; nowr &lt;&#x3D; R) return tar_add(o, Val, nowl, nowr);
			int mid &#x3D; (nowl + nowr) &gt;&gt; 1;
			push(o, nowl, nowr);
			if(L &lt;&#x3D; mid) update_add(ls(o), nowl, mid, L, R, Val);
			if(R  &gt; mid) update_add(rs(o), mid + 1, nowr, L, R, Val);
			maintain(o);
		&#125;
		void update_mul(int o, int nowl, int nowr, int L, int R, LB Val)&#123;
			if(L &lt;&#x3D; nowl &amp;&amp; nowr &lt;&#x3D; R) return tar_mul(o, Val, nowl, nowr);
			int mid &#x3D; (nowl + nowr) &gt;&gt; 1;
			push(o, nowl, nowr);
			if(L &lt;&#x3D; mid) update_mul(ls(o), nowl, mid, L, R, Val);
			if(R  &gt; mid) update_mul(rs(o), mid + 1, nowr, L, R, Val);
			maintain(o);
		&#125;
		void update_ret(int o, int nowl, int nowr, int L, int R)&#123;
			if(L &lt;&#x3D; nowl &amp;&amp; nowr &lt;&#x3D; R) return tar_ret(o, nowl, nowr);
			int mid &#x3D; (nowl + nowr) &gt;&gt; 1;
			push(o, nowl, nowr);
			if(L &lt;&#x3D; mid) update_ret(ls(o), nowl, mid, L, R);
			if(R  &gt; mid) update_ret(rs(o), mid + 1, nowr, L, R);
			maintain(o);
		&#125;
		LB query(int o, int nowl, int nowr, int L, int R)&#123;
			if(L &lt;&#x3D; nowl &amp;&amp; nowr &lt;&#x3D; R) return v[o];
			int mid &#x3D; (nowl + nowr) &gt;&gt; 1;
			push(o, nowl, nowr);
			LB ans &#x3D; LLONG_MIN;
			if(L &lt;&#x3D; mid) ans &#x3D; max(ans, query(ls(o), nowl, mid, L, R));
			if(R  &gt; mid) ans &#x3D; max(ans, query(rs(o), mid + 1, nowr, L, R));
			return ans;
		&#125;
	&#125;using SegmentTree::build;       using SegmentTree::query;       using SegmentTree::update_add;
	 using SegmentTree::update_mul;  using SegmentTree::update_ret;  using SegmentTree::Groot;
	void work()&#123;
		init_query();
		int root &#x3D; Groot(); build(root, 1, n); LB one &#x3D; 1;
		while(q--) &#123;
			int t, L, R, x; Read(t)(L)(R)(x); L ++, R ++;
			if(t &#x3D;&#x3D; 0) update_add(root, 1, n, L, R, x);
			if(t &#x3D;&#x3D; 1) update_mul(root, 1, n, L, R, one &#x2F; x);
			if(t &#x3D;&#x3D; 2) printf(&quot;%lld\n&quot;, (long long)(query(root, 1, n, L, R) + 1e-10));
			if(t &#x3D;&#x3D; 3) update_ret(root, 1, n, L, R);
		&#125;
	&#125;
&#125;
int main()&#123; &#x2F;&#x2F;freopen(&quot;in.txt&quot;, &quot;r&quot;, stdin);
	Read(n)(q); rep(i, 1, n) Read(A[i]);
	Acceptable_Solution::work();
	return 0;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

</details>
<h3 id="d.-four">D. four</h3>
<div class="note info"><p>你有 <span class="math inline">\(1..2n\)</span> 共 <span class="math inline">\(2n\)</span> 个数，有 <span class="math inline">\(n\)</span> 个人，你会给每个人分两个随机的数，这样就把 <span class="math inline">\(2n\)</span> 个数分完了，每个人获得的总数就是这两个数相加。这个随机过程可以认为是，先把 <span class="math inline">\(2n\)</span> 个数随机排列，将前2个数分给第一个人，将接下来前2个数分给第二个人……不难看出这个过程是没有歧义的</p>
<p>你想知道有多大概率，使得总和最大的人唯一（不存在两个相同的最大值），答案模 <span class="math inline">\(998244353\)</span></p>
</div>
<details class="note success"><summary><p>Solution</p>
</summary>
<p>没听懂…。</p>

</details>
<h2 id="round-3">Round 3</h2>
<h3 id="a.-diyiti">A. diyiti</h3>
<div class="note info"><p>有 <span class="math inline">\(n\)</span> 个物品，每个物品价格 <span class="math inline">\(A_i\)</span> ，收益为 <span class="math inline">\(B_i\)</span> ，由于一些奥妙重重的原因，当你买了一些物品，总价格为选择的 <span class="math inline">\(A_i\)</span> 的按位或而不是代数相加!</p>
<p>你身上只有 <span class="math inline">\(k\)</span> 元钱，你希望选择总价格不超过 <span class="math inline">\(k\)</span> 的一些物品，来获得最大的收益。</p>
<p>对于所有数据，<span class="math inline">\(1\leq n\leq 10^5,0\leq k &lt; 2^{30},0 \leq A_i &lt; 2^{30},0 \leq B_i \leq 10^9\)</span>。</p>
</div>
<details class="note success"><summary><p>Solution</p>
</summary>
<p>一种天然的想法就是考虑枚举，每一个 <span class="math inline">\(i \le k\)</span> 然后累加所有可以被选的物品求最大值，显然能保证正确性。得到一个 <span class="math inline">\(\mathcal{O}(k n)\)</span> 的优秀做法。 发现这样枚举的每一个 <span class="math inline">\(i\)</span> 有很多没有必要的枚举。</p>
<p>其实可以枚举放弃 <span class="math inline">\(k\)</span> 的哪一位 <code>1</code>。</p>
<p>例如: 若 <span class="math inline">\(k = (1001101001)_2\)</span> 那么有意义的 <span class="math inline">\(i\)</span> 就可能是： - <span class="math inline">\((0111111111)_2\)</span> - <span class="math inline">\((1000111111)_2\)</span> - <span class="math inline">\((1001011111)_2\)</span> - <span class="math inline">\((1001100111)_2\)</span> - <span class="math inline">\((1001101001)_2\)</span></p>
<p>也就是枚举某一位 <span class="math inline">\(1\)</span> 把这个 <span class="math inline">\(1\)</span> 变成 <span class="math inline">\(0\)</span>，然后把这后面的所有数字变成 <span class="math inline">\(1\)</span>。</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">int n, k;
int Lim[_], Pr[_];
LL calc(int x)&#123;
	LL ans &#x3D; 0;
	rep(i, 1, n) if((x | Lim[i]) &#x3D;&#x3D; x) ans +&#x3D; Pr[i];
	return ans;
&#125;
int main()&#123;
	Read(n)(k); rep(i, 1, n) Read(Lim[i])(Pr[i]);
	LL ans &#x3D; calc(k);
	for(int i &#x3D; 30; i &gt;&#x3D; 0; i--)&#123;
		if(k &amp; (1 &lt;&lt; i)) ; else continue;
		int Lit &#x3D; k;
		Lit ^&#x3D; (1 &lt;&lt; i); Lit |&#x3D; ((1 &lt;&lt; i) - 1);
		ans &#x3D; max(calc(Lit), ans);
	&#125;
	printf(&quot;%lld&quot;, ans);
	return 0;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

</details>
<h3 id="b.-dierti">B. dierti</h3>
<div class="note info"><p>给你一个长度为 <span class="math inline">\(n\)</span> 的数组 <span class="math inline">\(a_n\)</span>，你需要求出一个最长的子序列 <span class="math inline">\(C\)</span>，使得其相邻两项按位与的结果均非零 $(  i, C_i   C_{i+1} &gt; 0) $。</p>
</div>
<details class="note success"><summary><p>Solution</p>
</summary>
<p>这比第一题好想多了吧。 考虑 <span class="math inline">\(dp[n]\)</span> 表示 <span class="math inline">\([1, n]\)</span> 中强制 <span class="math inline">\(n\)</span> 一定选 符合要求的最长子序列，可以考虑枚举 <span class="math inline">\([1..n - 1]\)</span> 中上一个选择的是哪一个，即 <span class="math inline">\(dp[n] = 1 + \max_{i = 1}^{n - 1}\limits{dp[i][C_i \And C_n &gt; 0]}\)</span> 这样的复杂度是 <span class="math inline">\(\mathcal{O}(n^2)\)</span> 的。</p>
<p>考虑如果满足 <span class="math inline">\(C_i \And C_j &gt; 0\)</span> 那么需要 <span class="math inline">\(C_i, C_j\)</span> 至少一个二进制位置相同。那就维护一个数组，<span class="math inline">\(Bmax[i]\)</span> 表示 <span class="math inline">\(C\)</span> 的第 <span class="math inline">\(i\)</span> 位为 <span class="math inline">\(1\)</span> 的所有 <span class="math inline">\(C_j\)</span> 最大的 <span class="math inline">\(dp[j]\)</span>，即可实现 <span class="math inline">\(\mathcal{O}(\log C_{max})\)</span> 转移。同时需要 <span class="math inline">\(\mathcal{O}(\log C_{max})\)</span> 维护数组 <span class="math inline">\(Bmax\)</span>。</p>
<p>总复杂度 <span class="math inline">\(\mathcal{O}(n\log C_{max} )\)</span>。 <pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">int n, A[_];
int Bmax[60];
int dp[_];
int main()&#123;
	n &#x3D; read(); rep(i, 1, n) Read(A[i]);
	dp[1] &#x3D; 1; rep(j, 0, 30) if(A[1] &amp; (1 &lt;&lt; j)) Bmax[j] &#x3D; max(Bmax[j], dp[1]);
	rep(i, 2, n)&#123;
		int ans &#x3D; 0;
		rep(j, 0, 30) if(A[i] &amp; (1 &lt;&lt; j)) ans &#x3D; max(ans, Bmax[j]);
		dp[i] &#x3D; ans + 1;
		rep(j, 0, 30) if(A[i] &amp; (1 &lt;&lt; j)) Bmax[j] &#x3D; max(Bmax[j], dp[i]);
	&#125;
	int ans &#x3D; 0; rep(i, 1, n) ans &#x3D; max(ans, dp[i]);
	printf(&quot;%d&quot;, ans); cerr &lt;&lt; &quot;std&#39;s ans &#x3D; &quot; &lt;&lt; ans &lt;&lt; endl;
	return 0;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></p>

</details>
<h3 id="c.-disanti">C. disanti</h3>
<div class="note info"><h4 id="statement">statement</h4>
<p>你有 <span class="math inline">\(n\)</span> 个 <span class="math inline">\(10\)</span> 进制下的位数为 <span class="math inline">\(m\)</span> 的数</p>
<p>有些数字被抹去了，因此取值任意。</p>
<p>你希望这 <span class="math inline">\(n\)</span> 个数单调递增，请求出所有满足这个条件的方案下，这 <span class="math inline">\(n\)</span> 个数之和的总和。</p>
<p>答案对 <span class="math inline">\(998244353\)</span> 取模。</p>
<p><span class="math inline">\(n,m\leq 30\)</span> #### input</p>
<p>第一行两个整数 <span class="math inline">\(n,m(1\leq n,m\leq 50)\)</span></p>
<p>接下来 <span class="math inline">\(n\)</span> 行，每行 <span class="math inline">\(m\)</span> 个字符，字符为 <span class="math inline">\(0..9\)</span> 的数字或者<code>?</code>。 <pre class="line-numbers language-none"><code class="language-none">INPUT0:
4 1
0
?
4
8
OUTPUT0:
42<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre> <pre class="line-numbers language-none"><code class="language-none">INPUT1:
5 5
?1234
23333
???66
??666
?233?
OUTPUT1:
819525655<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></p>
</div>
<div class="note danger"><p>没听懂… 待补。</p>
</div>
<h3 id="d.-disiti">D. disiti</h3>
<div class="note info"><p>你有一堆<span class="math inline">\(n\)</span>个石子的石子堆，你想要把石子堆裂成<span class="math inline">\(n\)</span>个大小为<span class="math inline">\(1\)</span>的石子堆。为了达成这个目的，你每次可以进行如下操作：假设现在有<span class="math inline">\(k\)</span>堆石子，大小分别为<span class="math inline">\(a_1, a_2, ... ,a_k\)</span>，你可以指定一个非负整数序列<span class="math inline">\(b_1, b_2, ... ,b_k\)</span>，满足<span class="math inline">\(\sum b_i\leq m\)</span>，每堆石子就会分裂成两堆<span class="math inline">\(b_i, a_i-b_i\)</span>（如果为<span class="math inline">\(0\)</span>就认为不存在，显然还需要满足<span class="math inline">\(b_i \leq a_i\)</span>）。你想要知道最少几次操作可以达成目的。 对于所有数据，<span class="math inline">\(T\leq 1000,1\leq m\leq n\leq 10^9\)</span></p>
</div>
<div class="note danger"><p>没听懂… 待补。</p>
</div>
<h2 id="round-4">Round 4</h2>
<h3 id="a.-一">A. 一</h3>
<div class="note info"><div class="note danger">
<p>
你是能看到第一题的friends呢。 ——hja 众所周知，小葱同学擅长计算，尤其擅长计算组合数，但这个题和组合数没什么关系。
</p>
</div>
<p>
<p>现在我们要执行若干代码，代码为对于变量的操作，包含以下三种： - 1、变量名=变量值，变量名由小写字母组成，变量值有可能是正整数或者字符串（小写字母或者数字），例如：a=3,b="233"。 - 2、变量名，代表询问该变量的值，如果该变量未赋值，则输出no。 - 3、变量名+=值，如果该变量未定义，直接跳过该次操作。设该变量的值为x，加上的值为y，如果两者均为整数直接相加；如果x是整数y为字符串则跳过此次操作；如果x是字符串y是整数则将y转换为字符串进行字符串拼接；如果两者均为字符串直接进行字符串拼接。 -</p>
</div> <details class="note success"><summary><p>code</p>
</summary>
<p>全程 STL。 <pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">map&lt;string , string&gt; M;
map&lt;string , bool &gt; Type; &#x2F;&#x2F; true for string , false for int
string tmp;
pair&lt;string , string&gt; Res;
int split(string S)&#123;
	if(S.find(&#39;&#x3D;&#39;) &gt;&#x3D; S.size() || S.find(&#39;&#x3D;&#39;) &lt; 0)&#123; &#x2F;&#x2F; TODO: check
		return 2;
	&#125; else &#123;
		if(S.find(&#39;+&#39;) &lt; S.size() &amp;&amp; S.find(&#39;+&#39;) &gt;&#x3D; 0)&#123;
			Res &#x3D; make_pair(S.substr(0, S.find(&#39;+&#39;)), S.substr(S.find(&#39;&#x3D;&#39;) + 1, S.size() - S.find(&#39;&#x3D;&#39;) - 1));
			return 3;
		&#125; else &#123;
			Res &#x3D; make_pair(S.substr(0, S.find(&#39;&#x3D;&#39;)), S.substr(S.find(&#39;&#x3D;&#39;) + 1, S.size() - S.find(&#39;&#x3D;&#39;) - 1));
			return 1;
		&#125;
	&#125;
&#125;
string calc(string A, string B)&#123;
	long long ResA &#x3D; 0;
	rep(i, 0, A.size() - 1)&#123;
		ResA *&#x3D; 10;
		ResA +&#x3D; A[i] - &#39;0&#39;;
	&#125;
	long long ResB &#x3D; 0;
	rep(i, 0, B.size() - 1)&#123;
		ResB *&#x3D; 10;
		ResB +&#x3D; B[i] - &#39;0&#39;;
	&#125;
	ResA +&#x3D; ResB;
	string Res, ans ; Res &#x3D; &quot;&quot;;
	while(ResA) Res.push_back(ResA % 10 + &#39;0&#39;), ResA &#x2F;&#x3D; 10;
	for(int i &#x3D; Res.size() - 1; i &gt;&#x3D; 0; i--) ans.push_back(Res[i]);
	return ans;
&#125;
bool pdType(string &amp;S) &#123; return S[0] &#x3D;&#x3D; &#39;&quot;&#39;; &#125; &#x2F;&#x2F; true for string
int main()&#123; &#x2F;&#x2F;freopen(&quot;in.txt&quot;, &quot;r&quot;, stdin); freopen(&quot;out.txt&quot;, &quot;w&quot;, stdout);
	ios::sync_with_stdio(false);
	int q; cin &gt;&gt; q;
	while(q--)&#123;
		cin &gt;&gt; tmp;
		int r &#x3D; split(tmp);
		if(r &#x3D;&#x3D; 1)&#123;
			int re &#x3D; pdType(Res.second); if(re) Res.second &#x3D; (Res.second.size() &#x3D;&#x3D; 2 ? string(&quot;&quot;) : Res.second.substr(1, Res.second.size() - 2));
			M[Res.first] &#x3D; Res.second;
			Type[Res.first] &#x3D; re;
		&#125; else if(r &#x3D;&#x3D; 2)&#123;
			if(M.count(tmp))  cout &lt;&lt; M[tmp] &lt;&lt; endl;
			else cout &lt;&lt; &quot;no&quot; &lt;&lt; endl;
		&#125; else &#123;
			if(M.count(Res.first)) ; else continue;
			int ex_t &#x3D; pdType(Res.second); if(ex_t) Res.second &#x3D; Res.second.substr(1, Res.second.size() - 2);
			int no_t &#x3D; Type[Res.first];
			if( ex_t &amp;&amp;  no_t) M[Res.first] &#x3D; M[Res.first] + Res.second;
			if( ex_t &amp;&amp; !no_t) &#123; continue; &#125;
			if(!ex_t &amp;&amp;  no_t) M[Res.first] &#x3D; M[Res.first] + Res.second;
			if(!ex_t &amp;&amp; !no_t) M[Res.first] &#x3D; calc(M[Res.first], Res.second);
		&#125;
	&#125;
	return 0;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></p>

</details> ### B. 二 <div class="note info"><p>你是能看到第二题的friends呢。 ——aoao</p>
<p>众所周知，小葱同学擅长计算，尤其擅长计算组合数，但这个题和组合数没什么关系。 <span class="math inline">\(N\)</span> 个小写字母字符串， Alice 和 Bob 按照如下方法玩游戏： - 1、Alice选择一个字符串，并重新定义 <span class="math inline">\(26\)</span> 个字母的字典序，然后再将这个字符串内部字符按照任意顺序重排。 - 2、Bob从剩下的字符串中选择一个，并将这个字符串内部字符按照任意顺序重排。 他们的目标是使得自己字符串的字典序比对面小，谁的字符串字典序更小谁就赢了。问 Alice 有多少个可以选择的字符串能够使得自己获胜？ <span class="math inline">\(N \le 1000\)</span></p>
</div> <details class="note success"><summary><p>Solution</p>
</summary>
<p>因为可以重新排列字符串，所以对于每个字符串来说，有用的信息就是每个字符串中每个字符的出现次数。</p>
<p>可以考虑先枚举一个字符串，然后判断这个字符串是否能被 Alice 选。然后考虑确定字典序，可以以此考虑字典序最小的应该是哪个字符，确定了字典序最小的字符之后，可以排除掉一些字符串（字典序最小的字符在这些串中的出现次数 <span class="math inline">\(&lt;\)</span> 在枚举串中的出现次数），然后又转化成原来相同的问题。</p>
<p>关键在于如何确定当前情况下字典序最小的字符。显然，理想的字典序最小的字符 在当前枚举到的字符串中的出现次数一定不少于在其他串中的出现次数。但是这样的字符可能有多个，应该选哪个？</p>
<p>其实选哪个效果一样，本质上只是以此选择当前情况下字典序最小的字符，然后剔除一些字符串，但是剔除字符串的条件和剔除顺序无关。</p>
<p>最后判断是否所有字符串都被剔除掉即可。 <pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">#include &lt;cstdio&gt;
#include &lt;cstring&gt;
#include &lt;iostream&gt;
#include &lt;cmath&gt;
#include &lt;cstring&gt;
#include &lt;algorithm&gt;
#define rep(i, l, r) for(int i &#x3D; (l), __ &#x3D; (r); i &lt;&#x3D; __; i++)
const int _ &#x3D; 1010;
using namespace std;
inline int idx(char c) &#123; return c - &#39;a&#39; + 1; &#125;
int ch[_][30]; int n;
char S[_];
bool book[_];
bool bch[200];
int main()&#123;
	scanf(&quot;%d&quot;, &amp;n); rep(i, 1, n) &#123; scanf(&quot;%s&quot;, S + 1); int k &#x3D; strlen(S + 1); rep(j, 1, k) ch[i][idx(S[j])] ++; &#125;
	int ans &#x3D; 0;
	rep(i, 1, n)&#123;
		memset(book, 0, sizeof(book)); memset(bch, 0, sizeof(bch)); book[i] &#x3D; 1;
		rep(j, 1, 26) &#123;
			rep(k, &#39;a&#39;, &#39;z&#39;) &#123; if(bch[k]) continue;
				bool pass &#x3D; true;
				rep(l, 1, n) &#123;
					if(book[l]) continue;
					if(ch[l][idx(k)] &gt; ch[i][idx(k)]) &#123; pass &#x3D; false; break; &#125;
				&#125;
				if(pass)&#123;
					bch[k] &#x3D; 1;
					rep(l, 1, n) if(ch[l][idx(k)] &lt; ch[i][idx(k)]) book[l] &#x3D; 1;
					break;
				&#125;
			&#125;
		&#125;
		bool pass &#x3D; true; rep(i, 1, n) if(book[i] !&#x3D; 1) &#123; pass &#x3D; false; break; &#125;
		ans +&#x3D; pass;
	&#125;
	printf(&quot;%d&quot;, ans);
	return 0;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></p>

</details></p>
<h3 id="c.-三">C. 三</h3>
<div class="note info"><p>你是能看到第三题的friends呢。 ——laekov 众所周知，小葱同学擅长计算，尤其擅长计算组合数，但这个题和组合数没什么关系。</p>
<p>给定<span class="math inline">\(N\)</span>个数，设总共有<span class="math inline">\(M\)</span>个区间<span class="math inline">\(p_1=[l_1,r_1],p_2=[l_2,r_2 ],\cdots,p_M=[l_m,r_m]\)</span>的逆序对数量不少于<span class="math inline">\(K\)</span>个。定义函数<span class="math inline">\(f(p_i,p_j)\)</span>为计算两个区间的交集大小的函数（即共同覆盖了多少个数）。求 <span class="math inline">\(\sum_{i=1}^M\sum_{j=i+1}^M f(p_i,p_j)\)</span> <span class="math inline">\(N \le 10^6\)</span></p>
</div>
<details class="note success"><summary><p>Solution</p>
</summary>
<p>考虑每一个元素的贡献，不难发现，元素的贡献为 <span class="math inline">\(\binom{被覆盖的区间数}{2}\)</span> ，问题转化为怎么求每个元素被覆盖的次数。</p>
<p>考虑对于每一个左端点 <span class="math inline">\(L\)</span>，合法的右端点取值一定是一段连续的区间，且 如果存在上界一定是 <span class="math inline">\(n\)</span> ，对于每个左端点，求出其对应的最小的右端点，这里可以使用 <code>two-point</code> 。值域树状数组统计逆序对数。</p>
<p>考虑每个左端点为 <span class="math inline">\(L\)</span> 的区间对元素覆盖数的贡献，发现一定是一条平直线和一个下降直线，可以对差分数组的差分数组做修改，然后两次前缀和还原出原序列。</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">const int _ &#x3D; 2e6 + 100;
const int inv2 &#x3D; 500000004;
int n, k, A[_];
namespace BIT&#123;
	#define lowbit(x) (x &amp; (-x))
	int C[_];
	void add(int p, int x) &#123; if(p &#x3D;&#x3D; 0) return ; for(int i &#x3D; p; i &lt;&#x3D; n; i +&#x3D; lowbit(i)) C[i] +&#x3D; x; &#125;
	int  query(int p) &#123; int ans &#x3D; 0; for(int i &#x3D; p; i &gt;&#x3D; 1; i -&#x3D; lowbit(i)) ans +&#x3D; C[i]; return ans; &#125;
&#125; using BIT::add; using BIT::query;
int L &#x3D; 0, R &#x3D; 0;
int Rp[_];
int C[_];
int main()&#123;
	Read(n)(k); rep(i, 1, n) Read(A[i]);
	LL ans &#x3D; 0;
	rep(L, 1, n)&#123;
		if(L - 1 &gt; 0) add(A[L - 1], -1);
		if(L - 1 &gt; 0) ans -&#x3D; query(A[L - 1] - 1);
		while((R &lt; L) || (ans &lt; k &amp;&amp; R &lt;&#x3D; n)) &#123; if(R &#x3D;&#x3D; n) &#123; R++; break; &#125;; add(A[++R], 1); ans +&#x3D; query(n) - query(A[R]); &#125;
		Rp[L] &#x3D; R;
	&#125;
	rep(L, 1, n)&#123;
		if(Rp[L] &gt; n) continue; int cnt &#x3D; (n - Rp[L] + 1);
		C[L] &#x3D; (C[L] +0ll+ cnt) % MOD; C[L + 1] &#x3D; (C[L + 1] +0ll+ (MOD -0ll- cnt) % MOD) % MOD;
		C[Rp[L] + 1] &#x3D; (C[Rp[L] + 1] +0ll+ MOD - 1) % MOD;
	&#125;
	rep(i, 1, n) C[i] &#x3D; (C[i] +0ll+ C[i - 1]) % MOD;
	rep(i, 1, n) C[i] &#x3D; (C[i] +0ll+ C[i - 1]) % MOD;
	ans &#x3D; 0;
	rep(i, 1, n) ans &#x3D; (ans +0ll+ (C[i] *1ll* (C[i] - 1) % MOD *1ll* inv2 % MOD)) % MOD;
	printf(&quot;%lld&quot;, ans);
	return 0;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

</details>
<h3 id="d.-四">D. 四</h3>
<div class="note info"><p>你是能看到第四题的 friends 呢。 ——laekov</p>
<p>众所周知，小葱同学擅长计算，尤其擅长计算组合数，但这个题和组合数没什么关系。</p>
<p>今天也是皮克敏们打工的一天，你有 <span class="math inline">\(N\)</span> 只皮克敏，每只皮克敏有一颗炸弹。现在有一颗 <span class="math inline">\(N\)</span> 个点的树，同时皮克敏们可以从 <span class="math inline">\(p_1\)</span> 或者 <span class="math inline">\(p_2\)</span> 两个点中的任意一个进入树。每次你需要派一只皮克敏去到某个点，然后将炸弹连同皮克敏和这个点一起炸掉。一个点被炸掉了之后皮克敏就再也不能通过了。现在你需要决定皮克敏们炸点的顺序，问 <span class="math inline">\(n!\)</span> 种炸点方案中有多少种能炸掉所有点。 <span class="math inline">\(N \le 1000\)</span></p>
</div>
<details class="note success"><summary><p>Solution</p>
</summary>
<p>考虑 <code>DP</code> 。</p>
<p>首先考虑一个子树（子树内没有 <span class="math inline">\(p_1, p_2\)</span>）全部被清空应该是什么顺序，一定是每个儿子的子树先被清空然后清楚当前点。 这里可以使用树形 dp 处理。</p>
<p>先考虑 <span class="math inline">\(p_1 \leftrightarrow p_2\)</span> 这一条链上的点应该是按照什么顺序被清空，任意时刻，被清空的点一定是链上的连续的一段，这里可以区间 <span class="math inline">\(dp\)</span> 统计答案，转移考虑最后一次删除是删干净了链上最右边的点还是最左边的点。</p>
<p>然后和 <span class="math inline">\(p_1, p_2\)</span> 的每个不在链上的儿子合并答案，最后决策先删除 <span class="math inline">\(p_1\)</span> 还是 <span class="math inline">\(p_2\)</span>。 代码还没写。</p>

</details>
<h2 id="round-5">Round 5</h2>
<h3 id="a.-一-1">A. 一</h3>
<div class="note info"><p>现在有四种颜色的东西，各有<span class="math inline">\(n_1,n_2,n_3,n_4\)</span>个。你需要把他们放到一排里面，并且保证相邻的东西颜色不同，问方案数。 对于<span class="math inline">\(80\%\)</span>的数据，<span class="math inline">\(n_1+n_2+n_3+n_4\leq 10\)</span>。 对于另外<span class="math inline">\(10\%\)</span>的数据，<span class="math inline">\(n_1=0,n_2,n_3,n_4\leq 50\)</span>。 对于<span class="math inline">\(100\%\)</span>的数据，<span class="math inline">\(0\leq n_1,n_2\leq 200,0\leq n_3,n_4\leq50000\)</span>。</p>
</div>
<details class="note success"><summary><p>code</p>
</summary>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">namespace subtask1&#123;
	int dp[_][_][_][_][5];
	void work()&#123;
		memset(dp, 0, sizeof(dp));
		dp[1][0][0][0][1] &#x3D; dp[0][1][0][0][2] &#x3D; dp[0][0][1][0][3] &#x3D; dp[0][0][0][1][4] &#x3D; 1;
		rep(i, 0, A) rep(j, 0, B) rep(k, 0, C) rep(l, 0, D)&#123;
			if(i + j + k + l &#x3D;&#x3D; 1) continue;
			if(i &gt; 0) dp[i][j][k][l][1] &#x3D; (dp[i - 1][j][k][l][2] +0ll+ dp[i - 1][j][k][l][3] +0ll+  dp[i - 1][j][k][l][4]) % MOD;
			if(j &gt; 0) dp[i][j][k][l][2] &#x3D; (dp[i][j - 1][k][l][1] +0ll+ dp[i][j - 1][k][l][3] +0ll+  dp[i][j - 1][k][l][4]) % MOD;
			if(k &gt; 0) dp[i][j][k][l][3] &#x3D; (dp[i][j][k - 1][l][2] +0ll+ dp[i][j][k - 1][l][1] +0ll+  dp[i][j][k - 1][l][4]) % MOD;
			if(l &gt; 0) dp[i][j][k][l][4] &#x3D; (dp[i][j][k][l - 1][2] +0ll+ dp[i][j][k][l - 1][3] +0ll+  dp[i][j][k][l - 1][1]) % MOD;
		&#125;
		printf(&quot;%d\n&quot;, ans1 &#x3D; int((1ll* dp[A][B][C][D][1] +  dp[A][B][C][D][2] +  dp[A][B][C][D][3] +  dp[A][B][C][D][4]) % MOD));
	&#125;
&#125;
namespace subtask2&#123;
	const int _ &#x3D; 53;
	int dp[_][_][_][4];
	void work()&#123;
		memset(dp, 0, sizeof(dp));
		dp[1][0][0][1] &#x3D; dp[0][1][0][2] &#x3D; dp[0][0][1][3] &#x3D; 1;
		rep(i, 0, B) rep(j, 0, C) rep(k, 0, D)&#123;
			if(i + j + k &#x3D;&#x3D; 1) continue;
			if(i &gt; 0) dp[i][j][k][1] &#x3D; (dp[i - 1][j][k][2] +0ll+ dp[i - 1][j][k][3]) % MOD;
			if(j &gt; 0) dp[i][j][k][2] &#x3D; (dp[i][j - 1][k][1] +0ll+ dp[i][j - 1][k][3]) % MOD;
			if(k &gt; 0) dp[i][j][k][3] &#x3D; (dp[i][j][k - 1][2] +0ll+ dp[i][j][k - 1][1]) % MOD;
		&#125;
		printf(&quot;%d\n&quot;, ans2 &#x3D; int(( dp[B][C][D][1] +0ll+ dp[B][C][D][2] +0ll+ dp[B][C][D][3] ) % MOD));
	&#125;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

</details>
<h3 id="b.-二">B. 二</h3>
<div class="note info"><p><span class="math inline">\(N\)</span>个二元组<span class="math inline">\((a_i,b_i)\)</span>，定义<span class="math inline">\(c_1=a_1+b_1,c_i=b_i+max⁡(c_{i-1},\sum_{j=1}^ia_j)\)</span>。现在你可以随意重排这<span class="math inline">\(N\)</span>个二元组，求<span class="math inline">\(c_N\)</span>的最小值 <span class="math inline">\(N \le 10^6; A, B \le N\)</span></p>
</div>
<details class="note success"><summary><p>Solution</p>
</summary>
<p>考虑相邻两个二元组 <span class="math inline">\((a_1, b_1) (a_2, b_2)\)</span> 应该怎么比较大小。 分别列出 <span class="math inline">\((a_1, b_1)\)</span> 在 <span class="math inline">\((a_2, b_2)\)</span> 之前的答案和交换之后的答案。</p>
<p>如果 <span class="math inline">\((a_1, b_1)\)</span> 在 <span class="math inline">\((a_2, b_2)\)</span> 之前：设这两个二元组之前所有二元组中 <span class="math inline">\(a\)</span> 的和为 <span class="math inline">\(x\)</span>，设上一个二元组的 <span class="math inline">\(C\)</span> 值为 <span class="math inline">\(y\)</span>。 根据定义 <span class="math inline">\(C_1 = b_1 + \max(y, a_1 + x)\)</span>，<span class="math inline">\(C_2 = b_2 + max(C_1, x + a_1 + a_2)\)</span> 化简后得到 <span class="math inline">\(C_2 = \max(y + b_1 + b_2, x + a_1 + b_1 + b_2, x + a_1 + a_2 + b_2)\)</span> 易知 交换后 <span class="math inline">\(C_2&#39; = \max(y + b_1 + b_2, x + a_2 + b_1 + b_2, x + a_1 + a_2 + b_1)\)</span> 现在需要比较 <span class="math inline">\(C_2\)</span> 和 <span class="math inline">\(C_2&#39;\)</span> 的大小。相当于对 <span class="math inline">\(6\)</span> 个式子取最大值，看最大值出现在哪边。相同的项 <span class="math inline">\(y + b_1 + b_2\)</span> 可以消去，如果其为最大值，那么两个式子谁在前谁在后无所谓，如果其不是最大值，那么也没有影响。 消去每一项中相同的 <span class="math inline">\(x\)</span>。</p>
<p><span class="math inline">\(C_2 = \max(a_1 + b_1 + b_2, a_1 + a_2 + b_2)\)</span></p>
<p><span class="math inline">\(C_2&#39; = \max(a_2 + b_1 + b_2, a_1 + a_2 + b_1)\)</span></p>
<p>提出共同的项： <span class="math inline">\(C_2 = a_1 + b_2 + \max(b_1,a_2)\)</span></p>
<p><span class="math inline">\(C_2&#39; = a_2 + b_1 + \max(b_2, a_1)\)</span></p>
<p>假设 <span class="math inline">\(C_2 &lt; C_2&#39;\)</span></p>
<p>则 <span class="math inline">\(a_1 + b_2 + \max(b_1,a_2) &lt; a_2 + b_1 + \max(b_2, a_1)\)</span></p>
<p>移项得 <span class="math inline">\(a_1 + b_2 - \max(b_2,a_1) &lt; a_2 + b_1 - \max(b_1, a_2)\)</span></p>
<p>得出 <span class="math inline">\(\min(a_1, b_2) &lt; \min(a_2, b_1)\)</span></p>
<p>一种特殊情况是取等的时候：<del>举几个栗子得出</del> 结论是取等时比较 <span class="math inline">\(a_1 &lt; a_2\)</span>。 <pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">bool CMP(pair&lt;int, int&gt; x, pair&lt;int, int &gt; y)&#123;
	int r0 &#x3D; min(x.first, y.second);
	int r1 &#x3D; min(y.first, x.second);
	if(r0 !&#x3D; r1) return r0 &lt; r1;
	return x.first &lt; y.first;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></p>

</details>
<h3 id="c.-三-1">C. 三</h3>
<div class="note info"><p>给定 <span class="math inline">\(N\)</span> 个数，<span class="math inline">\(M\)</span> 次操作，操作有以下四种： - 1、区间加一个数。 - 2、区间乘一个数。 - 3、区间变成一个数。 - 4、求所有子区间的平均值的和(<span class="math inline">\(MOD = 10^9 + 7\)</span>)。 <span class="math inline">\(a_i, N,Q \le 10^5\)</span></p>
</div>
<details class="note success"><summary><p>Solution</p>
</summary>
<p><span class="math inline">\(Ans = \sum_{i=1}^{n}\limits{\sum_{j=i}^{n}\limits{\frac{\sum_{k=i}^{j}\limits{a_k}}{j-i+1}}}\)</span> 考虑每个数字的贡献 <span class="math inline">\(Ans = \sum_{k=1}^{n}\limits{a_k \times \sum_{i=1}^{n}\limits{\sum_{j=i}^{n}\limits{\frac{1}{j-i+1}}}}\)</span> 算出贡献，线段树维护即可。可以考虑 <span class="math inline">\(k\)</span> 每增加 1 贡献会变化多少。也可以发现贡献类似于一个梯形，可以直接算。 <pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">void work()&#123; cerr &lt;&lt; &quot;FUCK&quot; &lt;&lt; endl;
	S[1] &#x3D; 1; rep(i, 2, n) S[i] &#x3D; (S[i - 1] +0ll+ inv(i)) % MOD;
	int ans &#x3D; 0, dp &#x3D; 0;
	rep(i, 1, n)&#123;
		int last &#x3D; i - 1; dp &#x3D; (dp -0ll- S[last] + MOD) % MOD;
		dp &#x3D; (dp -0ll- (S[n] -0ll- S[n - last] +0ll+ MOD) % MOD +0ll+ MOD) % MOD;
		dp &#x3D; (dp +0ll+ (S[n] -0ll- S[i] +0ll+ MOD) % MOD) % MOD;
		dp &#x3D; ( dp +0ll+ S[i]) % MOD; &#x2F;&#x2F; 这里的 dp 就是位置为 i 的数字对答案贡献的系数。
		ans &#x3D; (ans +0ll+ dp *1ll* A[i] % MOD) % MOD;
	&#125;
	printf(&quot;%d&quot;, ans);
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></p>

</details>
<h3 id="d.-四-1">D. 四</h3>
<div class="note info"><p>众所周知，小葱同学擅长计算，尤其擅长计算组合数，但这个题和组合数没什么关系。</p>
<p>皮克敏们打完工了，是时候将所有皮克敏处理掉了。现在皮克敏们躲在一棵树上（点和边的任意位置都有可能），你可以选择若干叶子节点释放毒气，毒气会以每单位时间一单位的距离沿着边蔓延开来。为了能够灭绝皮克敏，你需要保证树上每个位置都充满了毒气。但是仅仅是求一个最小的灭绝皮克敏的时间实在太无趣了，你想要知道你有多少种不同的方法能够灭绝皮克敏，两个方法不同当且仅当两种方法灭绝所有皮克敏的时间不同。</p>
<p><span class="math inline">\(N \le 200\)</span> 第一行一个整数 <span class="math inline">\(N\)</span> 代表树上点的个数。</p>
<p>接下来 <span class="math inline">\(N−1\)</span> 行每行三个整数 <span class="math inline">\(s,e,d\)</span> 代表一条边的两端和长度。</p>
</div>
<details class="note success"><summary><p>Solution</p>
</summary>
<p>答案只能是某两个叶子之间的距离或者距离 $ / 2$ 。 枚举两个叶子，把 - 这个叶子之间的距离（只在一边放毒气）（如果能成为答案） - 两个叶子之间距离 $ / 2$（两个叶子上都放毒气）（如果能成为答案） 加入答案集合。 最后输出答案集合的大小。</p>
<p>枚举两个叶子，判断其距离是否能成为答案。考虑哪些其他叶子放毒气能让这个距离尽可能成为答案，就是那些放上毒气不会影响这两个枚举的叶子之间毒气传播时间的叶子都放上毒气，然后跑一遍最短路，算全树被毒气覆盖的时间是否等于当前枚举的叶子。 <pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">const int _ &#x3D; 510;
pair&lt;pair&lt;int, int&gt;, int &gt; E[_];
int n, m;
int M[_][_];
set&lt;int&gt; Ans;
queue&lt;int&gt;Q; bool inQ[_];
int SPFA()&#123;
	static int dis[_]; memset(dis, 0x3f, sizeof(dis));
	rep(i, 1, n) if(inQ[i]) dis[i] &#x3D; 0;
	while(!Q.empty())&#123;
		int now &#x3D; Q.front(); Q.pop(); inQ[now] &#x3D; 0;
		for(int i &#x3D; head[now]; i ;i &#x3D; edge[i].nxt)&#123;
			int ex &#x3D; edge[i].node;
			if(dis[now] + edge[i].w &lt; dis[ex]) &#123;
				dis[ex] &#x3D; dis[now] + edge[i].w;
				if(!inQ[ex]) Q.push(ex), inQ[ex] &#x3D; true;
			&#125;
		&#125;
	&#125;
	int MAX &#x3D; INT_MIN;
	rep(i, 1, n - 1) &#123;
		pair&lt;pair&lt;int, int&gt;, int&gt; now &#x3D; E[i];
		int T &#x3D; min(dis[now.first.first] + now.second, dis[now.first.second] + now.second, (dis[now.first.first] + dis[now.first.second] + now.second) &#x2F; 2);
		MAX &#x3D; max(MAX, T);
	&#125;
	return MAX;
&#125;
int ind[_];
bool work1(int x, int y, int D) &#123;
	Q.push(x); inQ[x] &#x3D; 1;
	rep(i, 1, n) &#123; if(i &#x3D;&#x3D; x || i &#x3D;&#x3D; y) continue; if(M[i][y] &gt;&#x3D; D &amp;&amp; ind[i] &#x3D;&#x3D; 1) Q.push(i), inQ[i] &#x3D; 1; &#125;
	return SPFA() &#x3D;&#x3D; D;
&#125;
bool work2(int x, int y, int D)&#123;
	Q.push(x); Q.push(y); inQ[x] &#x3D; inQ[y] &#x3D; 1;
	rep(i, 1, n)&#123;
		if(x &#x3D;&#x3D; i || y &#x3D;&#x3D; i) continue;
		if(max(M[x][i], M[y][i]) &#x2F; 2 &gt;&#x3D; D &amp;&amp; ind[i] &#x3D;&#x3D; 1) Q.push(i), inQ[i] &#x3D; 1;
	&#125;
	return SPFA() &#x3D;&#x3D; D;
&#125;

int main()&#123;
	memset(M, 0x3f, sizeof(M));
	rep(i, 1, n) M[i][i] &#x3D; 0;
	Read(n); rep(i, 1, n - 1) &#123; int u, v, w; Read(u)(v)(w); ind[u] ++; ind[v]++; w &lt;&lt;&#x3D; 1; add(u, v, w); add(v, u, w); M[u][v] &#x3D; M[v][u] &#x3D; w; E[i] &#x3D; make_pair(make_pair(u, v), w); &#125;
	rep(k, 1, n) rep(i, 1, n) rep(j, 1, n) M[i][j] &#x3D; M[j][i] &#x3D; min(M[i][j], M[i][k] + M[k][j]);
	rep(i, 1, n) rep(j, 1, n)&#123; if(i &#x3D;&#x3D; j) continue; if(ind[i] !&#x3D; 1 || ind[j] !&#x3D; 1) continue;
		if(!Ans.count(M[i][j])      &amp;&amp; work1(i, j, M[i][j]))      Ans.insert(M[i][j]);
		if(!Ans.count(M[i][j] &gt;&gt; 1) &amp;&amp; work2(i, j, M[i][j] &gt;&gt; 1)) Ans.insert(M[i][j] &gt;&gt; 1);

	&#125;
	printf(&quot;%d&quot;, int(Ans.size()));
	return 0;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></p>

</details>
<h2 id="round-6">Round 6</h2>
<h3 id="a.-一-2">A. 一</h3>
<div class="note info"><p>现在我们有两队皮克敏，个数分别为<span class="math inline">\(n_1,n_2\)</span>，现在我们要杀掉这些皮克敏，按照如下规则操作：对于第<span class="math inline">\(i\)</span>轮杀皮克敏的操作，我们首先选择皮克敏较多的那一队，如果一样就选择第一队，然后杀掉这队中的<span class="math inline">\(i\)</span>个皮克敏，如果不够，游戏结束，记做游戏在第<span class="math inline">\(i\)</span>轮结束。问最后两队各剩下多少个皮克敏？ <span class="math inline">\(n \le 10^{16}\)</span></p>
</div>
<details class="note success"><summary><p>Solution</p>
</summary>
<p>分成两阶段，一阶段是只杀多的那队，直到比另一队少。二阶段是两队交替着杀，可以证明，如果经过了第一阶段，那么第二阶段一定是交替着杀。 <del>杀就完了。</del> 分别二分即可，当然第一步也可以直接解方程。 <pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">LL A, B;
inline LL check(LL x) &#123; return x * (x + 1) &gt;&gt; 1; &#125;
LL Get(LL res)&#123;
	LL L &#x3D; 0, R &#x3D; 1e9, ans &#x3D; 0;
	while(L &lt; R)&#123;
		LL mid &#x3D; L + ((R - L + 1) &gt;&gt; 1);
		if(check(mid) &lt;&#x3D; res) ans &#x3D; mid, L &#x3D; mid;
		else R &#x3D; mid - 1;
	&#125;
	return ans;
&#125;
LL Start &#x3D; 0; LL tA, tB;
bool check0(LL Round, LL A, LL B)&#123;
	LL dA, dB; bool sf &#x3D; false;
	if(A &lt; B) sf &#x3D; true, swap(A, B);
	if(Round &amp; 1) &#123;
		dA &#x3D; (Start + (Start + Round - 1)) * (Round &#x2F; 2 + 1) &gt;&gt; 1;
		dB &#x3D; (Start + 1 + (Start + Round - 2)) * (Round &#x2F; 2) &gt;&gt; 1;
	&#125; else &#123;
		dA &#x3D; (Start + (Start + Round - 2)) * (Round &#x2F; 2) &gt;&gt; 1;
		dB &#x3D; (Start + 1 + (Start + Round - 1)) * (Round &#x2F; 2) &gt;&gt; 1;
	&#125; A -&#x3D; dA; B -&#x3D; dB;
	if(sf) swap(A, B);
	tA &#x3D; A; tB &#x3D; B;
	return A &gt;&#x3D; 0 &amp;&amp; B &gt;&#x3D; 0;
&#125;
void doit()&#123;
	Read(A)(B);
	LL d &#x3D; max(A, B) - min(A, B);
	LL Round &#x3D; Get(d); LL del &#x3D; check(Round);
	if(A &lt; B) B -&#x3D; del; else A -&#x3D; del;
	if(A &#x3D;&#x3D; B) &#123;
		if(A &lt; Round + 1) return (void)printf(&quot;%lld %lld %lld\n&quot;, Round + 1, A, B);
		else Round ++, A -&#x3D; Round;
	&#125; else &#123;
		if(max(A, B) &lt; Round + 1) return (void)printf(&quot;%lld %lld %lld\n&quot;, Round + 1, A, B);
		else Round ++, (A &gt; B ? A -&#x3D; Round : B -&#x3D; Round);
	&#125;
	LL L &#x3D; 0, R &#x3D; 1e9, ans &#x3D; 0; Start &#x3D; Round + 1;
	while(L &lt; R) &#123;
		LL mid &#x3D; L + ((R - L + 1) &gt;&gt; 1);
		if(check0(mid, A, B)) ans &#x3D; mid, L &#x3D; mid;
		else R &#x3D; mid - 1;
	&#125; check0(ans, A, B);
	printf(&quot;%lld %lld %lld\n&quot;, ans + Round + 1, tA, tB);
&#125;
int main()&#123;
	int T &#x3D; read(); cerr &lt;&lt; &quot;std&#39;s T &#x3D; &quot; &lt;&lt; T &lt;&lt; endl;
	while(T--) doit();
	return 0;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></p>

</details>
<h3 id="b.-二-1">B. 二</h3>
<div class="note info"><p>现在有三组N个数记做<span class="math inline">\(A,B,C\)</span>，定义函数<span class="math inline">\(f(A,B)=\sum_{i=1}^NA_i\times B_i\)</span>。现在给定<span class="math inline">\(A,B\)</span>，并告诉你<span class="math inline">\(f(A,C)=x\)</span>，现在想求在满足<span class="math inline">\(∑_{i=1}^NC_i=1,0\leq C_i\leq1\)</span>的情况下<span class="math inline">\(f(B,C)\)</span>的最大值。 对于<span class="math inline">\(100\%\)</span>的数据，<span class="math inline">\(1\leq N,M\leq 100,1\leq A_i,B_i\leq100\)</span></p>
</div>
<details class="note success"><summary><p>Solution</p>
</summary>
<p>[skip] 结论是只有两个点有用，只枚举两个点即可。 <pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></p>

</details>
<h3 id="c.-三-2">C. 三</h3>
<div class="note info"><p>众所周知，小葱同学擅长计算，尤其擅长计算组合数，但这个题和组合数没什么关系。</p>
<p>现在有一个 <span class="math inline">\(N\)</span> 的排列，将其每个数看做一个集合。定义一种对两个集合的运算为：<span class="math inline">\(f(s_1,s_2 )=\sum_{x\in s_1}[\exists y\in s_2,y &lt; x]\)</span> 也可以用这样一段伪代码去理解： <pre class="line-numbers language-python" data-language="python"><code class="language-python">Ans&#x3D;0
For x in s1:
    Able &#x3D; False
    For y in s2:
        If y&lt;x:
            Able&#x3D;True
    If Able:
        Ans++
Return Ans<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre> 现在你每次可以合并两个相邻的集合将其变为两个集合的并集，其代价为<span class="math inline">\(f(s_1,s_2)+f(s_2,s_1)\)</span>。求最小代价，将所有集合合并为一个集合。 <span class="math inline">\(N \le 10^2\)</span></p>
</div>
<details class="note success"><summary><p>Solution</p>
</summary>
<p>函数 <span class="math inline">\(f(A, B)\)</span> 其实就是 <span class="math inline">\(A\)</span> 中有多少元素大于 <span class="math inline">\(\min{B_i}\)</span> 。按照定义区间 dp 即可，由于是小于 <span class="math inline">\(\mathcal{O}(n^2)\)</span> 级别的二维数点，可以使用二维前缀和。 查询最小值随手预处理一下 <code>ST</code> 表即可。 <pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">const int _ &#x3D; 600;
int dp[_][_];
int S[_][_];
int n, A[_];
int query(int L, int R, int up)&#123; &#x2F;&#x2F; how many elements in range[L, R] which is &gt; up
	return S[n][R] - S[up][R] - S[n][L - 1] + S[up][L - 1];
&#125;
const int _S &#x3D; 4000;
const int LOG &#x3D; 10;
int ST[_S][LOG + 2];
int Log[_S];
void initQuery()&#123;
	rep(i, 1, n) ST[i][0] &#x3D; A[i];
	rep(j, 1, LOG) rep(i, 1, n) ST[i][j] &#x3D; min(ST[i][j - 1], ST[i + (1 &lt;&lt; (j - 1))][j - 1]);
	Log[1] &#x3D; 0; rep(i, 2, n) Log[i] &#x3D; Log[i &gt;&gt; 1] + 1;
&#125;
int RMQ(int L, int R)&#123;
	int Ln &#x3D; Log[R - L + 1];
	return min(ST[L][Ln], ST[R - (1 &lt;&lt; Ln) + 1][Ln]);
&#125;
int calc(int L0, int R0, int L1, int R1)&#123;
	int min0 &#x3D; RMQ(L0, R0), min1 &#x3D; RMQ(L1, R1);
	return query(L0, R0, min1) + query(L1, R1, min0);
&#125;
int main()&#123;
	Read(n); rep(i, 1, n) Read(A[i]); initQuery();
	rep(i, 1, n) S[A[i]][i]++;
	rep(i, 1, n) rep(j, 1, n) S[i][j] +&#x3D; S[i - 1][j] + S[i][j - 1] - S[i - 1][j - 1];
	memset(dp, 0x3f, sizeof(dp)); rep(i, 1, n) dp[i][i] &#x3D; 0;
	rep(Len, 2, n)&#123;
		rep(L, 1, n)&#123;
			int R &#x3D; L + Len - 1; if(R &gt; n) break;
			int &amp;ans &#x3D; dp[L][R];
			rep(k, L, R - 1) ans &#x3D; min(ans, dp[L][k] + dp[k + 1][R] + calc(L, k, k + 1, R));
		&#125;
	&#125;
	printf(&quot;%d&quot;, dp[1][n]);
	return 0;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></p>

</details>
<h3 id="d.-四-2">D. 四</h3>
<div class="note info"><p>给定 <span class="math inline">\(1-N\)</span> 的排列但其中 <span class="math inline">\(M\)</span> 个位置的值被删去了（用 <span class="math inline">\(0\)</span> 表示），现在你需要将其复原，问有多少种方案能够使得复原的序列的逆序对个数在 <span class="math inline">\([L,R]\)</span> 之间</p>
</div>
<details class="note success"><summary><p>Solution</p>
</summary>
<p>折半搜索，中间 <span class="math inline">\(\mathcal{O}(n^2)\)</span> 合并。 <pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></p>

</details>
<h2 id="round-7">Round 7</h2>
<p>AK。 ### A. 一 <div class="note info"><p>有一个<span class="math inline">\(n\times n\)</span>的矩阵，矩阵中的每个数都是整数。现在要从矩阵中取<span class="math inline">\(m\)</span>个数，要求每一行最多取一个数，每一列也最多取一个数。这<span class="math inline">\(m\)</span>个数的和最大能是多少？ <span class="math inline">\(n \le 15, m \le 3, A_{i,j} \le 10^5\)</span></p>
</div> <details class="note success"><summary><p>Solution</p>
</summary>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">const int _ &#x3D; 20;
int n, m, A[_][_];
int main()&#123;
	Read(n)(m); rep(i, 1, n) rep(j, 1, n) Read(A[i][j]);
	if(m &#x3D;&#x3D; 1) &#123;
		int MAX &#x3D; 0; rep(i, 1, n) rep(j, 1, n) MAX &#x3D; max(MAX, A[i][j]);
		printf(&quot;%d&quot;, MAX);
	&#125; else if(m &#x3D;&#x3D; 2)&#123;
		int MAX &#x3D; 0;
		rep(a, 1, n) rep(b, 1, n) rep(c, 1, n) rep(d, 1, n)&#123;
			if(a &#x3D;&#x3D; c || b &#x3D;&#x3D; d) continue;
			MAX &#x3D; max(MAX, A[a][b] + A[c][d]);
		&#125;
		printf(&quot;%d&quot;, MAX);
	&#125; else if(m &#x3D;&#x3D; 3)&#123;
		int MAX &#x3D; 0;
		rep(a, 1, n) rep(b, 1, n) rep(c, 1, n) rep(d, 1, n) rep(e, 1, n) rep(f, 1, n)&#123;
			if(a &#x3D;&#x3D; c || c &#x3D;&#x3D; e || a &#x3D;&#x3D; e || b &#x3D;&#x3D; d || d &#x3D;&#x3D; f || b &#x3D;&#x3D; f) continue;
			MAX &#x3D; max(MAX, A[a][b] + A[c][d] + A[e][f]);
		&#125;
		printf(&quot;%d&quot;, MAX);
	&#125;
	return 0;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

</details> ### B. 二 <div class="note info"><p>有多少整数大于等于<span class="math inline">\(x\)</span>，小于等于<span class="math inline">\(y\)</span>，而且是7的倍数，又不是2,3,5的倍数呢？ <span class="math inline">\(x,y \le 10^{18}\)</span></p>
</div> <details class="note success"><summary><p>Solution</p>
</summary>
<p>容斥原理 <pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">LL calc(LL R)&#123;
	LL ans &#x3D; 0;
	ans +&#x3D; R &#x2F; 7; ans -&#x3D; R &#x2F; 14; ans -&#x3D; R &#x2F; 21; ans -&#x3D; R &#x2F; 35; ans +&#x3D; R &#x2F; 42; ans +&#x3D; R &#x2F; 70; ans +&#x3D; R &#x2F; 105; ans -&#x3D; R &#x2F; 210;
	return ans;
&#125;
int main()&#123;
	LL L, R; Read(L)(R);
	printf(&quot;%lld&quot;, calc(R) - calc(L - 1));
	return 0;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></p>

</details> ### C. 三 <div class="note info"><p>给出一个<span class="math inline">\(n\)</span>个点<span class="math inline">\(m\)</span>条边的图。</p>
<p>现在想要选择两个整数<span class="math inline">\(a\)</span>和<span class="math inline">\(b\)</span>，满足<span class="math inline">\(1 \leq a &lt; b &lt; n\)</span>，然后把编号在区间<span class="math inline">\([1,a]\)</span>中的点染成蓝色，把编号在区间<span class="math inline">\([a+1,b]\)</span>中的点染成红色，编号在区间<span class="math inline">\([b+1,n]\)</span>中的点染成蓝色。</p>
<p>如果一条边的两个端点颜色不同，我们称这条边为双色边，否则称之为单色边。</p>
<p>如何选择<span class="math inline">\(a,b\)</span>，能够最小化双色边的数量？ <span class="math inline">\(n, m \le 10^5\)</span></p>
</div></p>
<details class="note success"><summary><p>Solution</p>
</summary>
<p>经典套路，按顺序枚举 <span class="math inline">\(a\)</span>，线段树维护 <span class="math inline">\(b\)</span> 的每一个取值时的双色边数量，枚举 <span class="math inline">\(a\)</span> 的过程中维护 <span class="math inline">\(b\)</span> 的取值，更新答案即可。 <pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">int n, m;
const int _ &#x3D; 3e5 + 100;
vector&lt;int&gt; ToL[_];
vector&lt;int&gt; ToR[_];
namespace SegmentTree&#123;	&#x2F;&#x2F; maintain the number of double-color edge;
					  	&#x2F;&#x2F; the min number ;
	const int _ &#x3D; 2e6 + 100;
	int ch[_][2], v[_], tag_add[_], tot &#x3D; 0;
	#define ls(o) (ch[o][0])
	#define rs(o) (ch[o][1])
	#define maintain(o) (v[o] &#x3D; min(v[ls(o)], v[rs(o)]))
	#define make (tot++, ch[tot][0] &#x3D; ch[tot][1] &#x3D; v[tot] &#x3D; tag_add[tot] &#x3D; 0, tot)
	int Groot()&#123; return make; &#125;
	void build(int o, int L, int R)&#123;
		if(L &#x3D;&#x3D; R) return (void)(v[o] &#x3D; 0); int mid &#x3D; (L + R) &gt;&gt; 1;
		ls(o) &#x3D; make; rs(o) &#x3D; make;
		build(ls(o), L, mid); build(rs(o), mid + 1, R);
		maintain(o);
	&#125;
	void tar(int o, int _v)&#123; tag_add[o] +&#x3D; _v; v[o] +&#x3D; _v; &#125;
	void push(int o) &#123; if(!tag_add[o]) return ; tar(ls(o), tag_add[o]); tar(rs(o), tag_add[o]); tag_add[o] &#x3D; 0; &#125;
	void update(int o, int nowl, int nowr, int L, int R, int Val)&#123;
		if(L &lt;&#x3D; nowl &amp;&amp; nowr &lt;&#x3D; R) return tar(o, Val);
		int mid &#x3D; (nowl + nowr) &gt;&gt; 1; push(o);
		if(L &lt;&#x3D; mid) update(ls(o), nowl, mid, L, R, Val);
		if(R  &gt; mid) update(rs(o), mid + 1, nowr, L, R, Val);
		maintain(o);
	&#125;
	int query(int o, int nowl, int nowr, int L, int R)&#123;
		if(L &lt;&#x3D; nowl &amp;&amp; nowr &lt;&#x3D; R) return v[o];
		int mid &#x3D; (nowl + nowr) &gt;&gt; 1; push(o);
		int ans &#x3D; INT_MAX;
		if(L &lt;&#x3D; mid) ans &#x3D; min(ans, query(ls(o), nowl, mid, L, R));
		if(R  &gt; mid) ans &#x3D; min(ans, query(rs(o), mid + 1, nowr, L, R));
		return ans;
	&#125;
&#125; 	using SegmentTree::update; 	using SegmentTree::build;
  	using SegmentTree::query;	using SegmentTree::Groot;
int main()&#123;
	Read(n)(m);
	int root &#x3D; Groot(); build(root, 1, n); int ans &#x3D; INT_MAX;
	rep(i, 1, m)&#123;
		int u, v; Read(u)(v); if(u &gt; v) swap(u, v);
		ToL[v].push_back(u); ToR[u].push_back(v); update(root, 1, n, u, v - 1, 1);
	&#125;
	rep(i, 1, n - 2) &#123;
		update(root, 1, n, i + 1, n - 1, -int(ToL[i].size()));
		rep(j, 0, ToR[i].size() - 1) update(root, 1, n, i, ToR[i][j] - 1, -1), update(root, 1, n, ToR[i][j], n, 1);
		ans &#x3D; min(ans, query(root, 1, n, i + 1, n - 1));
	&#125;
	printf(&quot;%d&quot;, ans);
	return 0;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></p>

</details>
<h3 id="d.-四-3">D. 四</h3>
<div class="note info"><p><span class="math inline">\(n\)</span>个小伙伴（编号从0到<span class="math inline">\(n−1\)</span>）围坐一圈玩游戏。按照顺时针方向给<span class="math inline">\(n\)</span>个位置编号，从0到<span class="math inline">\(n−1\)</span>。最初，第0号小伙伴在第0号位置，第1号小伙伴在第1号位置，<span class="math inline">\(\dots\)</span>，依此类推。游戏规则如下： - 有一个序列<span class="math inline">\(A=\{a_1,\dots,a_m\}\)</span>，其中每个数互不相同，且都是<span class="math inline">\([1,n-1]\)</span>中的正整数。 - 每一轮从<span class="math inline">\(A\)</span>中选择一个数<span class="math inline">\(a\)</span>，第0号位置上的小伙伴顺时针走到第<span class="math inline">\(a\)</span>号位置，第1号位置小伙伴走到第<span class="math inline">\(a+1\)</span>号位置。依此类推，第<span class="math inline">\(n-a\)</span>号位置上的小伙伴走到第0号位置，第<span class="math inline">\(n-a+1\)</span>号位置上的小伙伴走到第1号位置，<span class="math inline">\(\dots\)</span>，第<span class="math inline">\(n-1\)</span>号位置上的小伙伴顺时针走到第<span class="math inline">\(a-1\)</span>号位置。也就是说，第<span class="math inline">\(i\)</span>号位置上的小伙伴走到第<span class="math inline">\((i+a)\mod\ n\)</span>号位置</p>
<p>游戏进行<span class="math inline">\(t\)</span>轮。由于每一轮都需要从<span class="math inline">\(A\)</span>中的<span class="math inline">\(m\)</span>个数中选一个数，所以游戏共有<span class="math inline">\(m^t\)</span>种玩法。其中有多少种玩法能够使得游戏结束时，第0号小伙伴所在的位置编号是<span class="math inline">\(d\)</span>的倍数？（0也是<span class="math inline">\(d\)</span>的倍数）、 对 <span class="math inline">\(10^9 + 7\)</span>取模。 <span class="math inline">\(1\le m \le n \le 1000, 1 \le t \le 10^9, 1 \le d \le n\)</span>。</p>
</div>
<details class="note success"><summary><p>Solution</p>
</summary>
<p>设 <span class="math inline">\(dp[i]\)</span> 为进行若干轮之后在位置 <span class="math inline">\(i\)</span> 的方案数。 转移显然是卷积。 包装了循环卷积的定义。 <pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">namespace subtask_acceptable_solution&#123;
	const int _ &#x3D; 1500;
	struct Matrix&#123;
		int dp[_];
		Matrix ()&#123; memset(dp, 0, sizeof(dp)); &#125;
		Matrix operator * (const Matrix &amp; rhs) &#123;
			Matrix Res;
			rep(i, 0, n - 1) rep(j, 0, n - 1) Res.dp[(i + j) % n] &#x3D; (Res.dp[(i + j) % n] +0ll+ dp[i] *1ll* rhs.dp[j] % MOD) % MOD;
			return Res;
		&#125;
	&#125;;
	Matrix pow(Matrix a, int b)&#123;
		Matrix ans &#x3D; a; b--;
		while(b)&#123;
			if(b &amp; 1) ans &#x3D; ans * a;
			a &#x3D; a * a;
			b &gt;&gt;&#x3D; 1;
		&#125;
		return ans;
	&#125;
	void work()&#123;
		Matrix a;
		rep(i, 1, m) a.dp[A[i]] ++;
		Matrix Ans &#x3D; pow(a, t);
		int ans &#x3D; 0;
		for(int i &#x3D; 0; i &lt; n; i +&#x3D; d) ans &#x3D; (ans +0ll+ Ans.dp[i]) % MOD;
		printf(&quot;%d\n&quot;, ans);
	&#125;
&#125;
int main()&#123; &#x2F;&#x2F;freopen(&quot;in.txt&quot;, &quot;r&quot;, stdin);
	Read(n)(m)(t)(d); rep(i, 1, m) A[i] &#x3D; read() % n;
	subtask_acceptable_solution::work();
	return 0;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></p>

</details>
<h2 id="round-8">Round 8</h2>
<h3 id="a.-双挂">A. 双挂</h3>
<div class="note info"><p>今年期中考试考了《程序设计》、《算法设计》和《数据结构》共三门课。由于考试太难了，好多同学都挂科了。班里一共<span class="math inline">\(n\)</span>个人，其中<span class="math inline">\(a\)</span>个人挂了《程序设计》，<span class="math inline">\(b\)</span>个人挂了《算法设计》，<span class="math inline">\(c\)</span>个人挂了《数据结构》。</p>
<p>如果一个同学挂了恰好两门课，那么我们就说他“双挂”了。 给出<span class="math inline">\(n,a,b,c\)</span>，问最少有多少同学“双挂”了。</p>
<p><span class="math inline">\(0 \le a, b, c \le n, n \le 10^9\)</span></p>
</div>
<details class="note success"><summary><p>solution</p>
</summary>
<p>设三门课挂科的人对应集合分别为 <span class="math inline">\(\mathbb{A}, \mathbb{B}, \mathbb{C}\)</span></p>
<p>显然并不是所有人都会挂科目。</p>
<p><span class="math inline">\(|\mathbb{A} \cup \mathbb{B} \cup \mathbb{C}| = |\mathbb{A}| + |\mathbb{B}| + |\mathbb{C}| - |\mathbb{A} \cap \mathbb{B}| - |\mathbb{A} \cap \mathbb{C}| - |\mathbb{B} \cap \mathbb{C}| + |\mathbb{A} \cap \mathbb{B} \cap \mathbb{C}| \le n\)</span></p>
<p>移项得</p>
<p>为了方便：设 <span class="math inline">\(S = \mathbb{A} \cap \mathbb{B} \cap \mathbb{C}\)</span></p>
<p><span class="math inline">\(\left(|\mathbb{A} \cap \mathbb{B}| - |S|\right) + \left(|\mathbb{A} \cap \mathbb{C}| - |S|\right) + \left(|\mathbb{B} \cap \mathbb{C}| - |S|\right) \ge |\mathbb{A}| + |\mathbb{B}| + |\mathbb{C}| + |S| - n - 3|S|\)</span></p>
<p>答案取值为 <span class="math inline">\(|\mathbb{A}| + |\mathbb{B}| + |\mathbb{C}| -2|S| - n\)</span>，其中 <span class="math inline">\(|S|\)</span> 越大 答案越小，其最大取值就是 <span class="math inline">\(\max{ \{ \mathbb{A}, \mathbb{B}, \mathbb{C} \} }\)</span> <pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">LL n, a, b, c; Read(n)(a)(b)(c);
printf(&quot;%lld&quot;, max(0LL, a + b + c - 2 * min(a, min(b, c)) - n));<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></p>

</details>
<h3 id="b.-ddl选手">B. DDL选手</h3>
<div class="note info"><p>DDL选手总是在最后做作业。</p>
<p>有<span class="math inline">\(n\)</span>个作业，第<span class="math inline">\(i\)</span>个作业的DDL时间是<span class="math inline">\(d_i\)</span>，做这个作业需要<span class="math inline">\(t_i\)</span>的时间。</p>
<p>做作业要一心一意，所以不能同时做两个作业。如果现在开始做第<span class="math inline">\(i\)</span>个作业，那么接下来<span class="math inline">\(t_i\)</span>的时间都要做这个作业，不能做别的。</p>
<p>DDL选手总是先做DDL时间早的作业。如果两个作业的DDL时间一样，那么DDL选手会先做其中编号小的</p>
<p>为DDL选手设计每个作业开始做的时间，使得DDL选手先做DDL早的作业（如果两个作业的DDL时间一样，那么先做其中编号小的），而且每个作业都能在DDL时间之前做完（时间是连续的，“之前”的意思是，最晚恰好这个时间完成。）。在保证完成的前提下，尽可能把开始做作业的时间往后推。（也就是如果有多个方案可以做完作业，选择开始时间最晚的方案。可以证明，最优方案中，每一个作业的开始时间都不早于其他方案的开始时间。输出这个最优方案。）</p>
<p><span class="math inline">\(n \le 10^5, t_i \le 10^4\)</span></p>
</div>
<details class="note success"><summary><p>solution</p>
</summary>
<p>依照题意反向模拟。</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">const int _ &#x3D; 2e5 + 100;
#define int long long
struct HomeWork_t&#123;
	int d, t, id;
&#125;H[_]; int n ;
int Ans[_];
bool CMP(const HomeWork_t &amp; A, const HomeWork_t &amp; B) &#123; return (A.d &lt; B.d) || (A.d &#x3D;&#x3D; B.d &amp;&amp; A.id &lt; B.id); &#125;
#undef int
int main()&#123;
	Read(n); rep(i, 1, n) Read(H[i].d)(H[i].t), H[i].id &#x3D; i;
	sort(H + 1, H + 1 + n, CMP);
	#define int long long
	int Last &#x3D; LLONG_MAX;
	for(int i &#x3D; n; i &gt;&#x3D; 1; i--)&#123;
		if(Last &gt;&#x3D; H[i].d) &#123;
			Last &#x3D; H[i].d - H[i].t;
			Ans[H[i].id] &#x3D; Last;
		&#125; else &#123;
			Last &#x3D; (Last) - H[i].t;
			Ans[H[i].id] &#x3D; Last;
		&#125;
	&#125;
	rep(i, 1, n) printf(&quot;%lld\n&quot;, Ans[i]);
	#undef int
	return 0;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

</details>
<h3 id="c.-约数链">C. 约数链</h3>
<div class="note info"><p>如果<span class="math inline">\(n\)</span>个数<span class="math inline">\(a_1,\dots,a_n\)</span>满足：对于<span class="math inline">\(1\leq i &lt; n\)</span>，<span class="math inline">\(a_i\)</span>是<span class="math inline">\(a_{i+1}\)</span>的约数，那么<span class="math inline">\(a_1,\dots,a_n\)</span>被称为一个约数链。一个约数链的权值是它所包含的<span class="math inline">\(n\)</span>个数的乘积。</p>
<p>给出<span class="math inline">\(n,m\)</span>，只允许使用不超过<span class="math inline">\(m\)</span>的正整数组成长为<span class="math inline">\(n\)</span>的约数链，会有非常多的方式。求所有这些方式得到的约数链的权值之和。 <span class="math inline">\(n \le 10, m \le 10^7\)</span></p>
</div>
<details class="note success"><summary><p>solution</p>
</summary>
<p>可以 <strong>dp</strong> 一下，设 <span class="math inline">\(dp[n][k]\)</span> 为长度为 <span class="math inline">\(n\)</span> 的约数链，结尾是 <span class="math inline">\(k\)</span> 的权值和。 转移为刷表。复杂度做到 <span class="math inline">\(\mathcal{O}(nm\log m)\)</span>。根本过不去。</p>
<p>设 <span class="math inline">\(f_n(k) = dp[n][k]\)</span> 其中 函数 <span class="math inline">\(f_k(x)\)</span> 为积性函数。</p>
<p>对于 <span class="math inline">\(a \perp b\)</span> 设 <span class="math inline">\(c = a \times b\)</span> 对于 <span class="math inline">\(f_n(c)\)</span> 所统计的方案中的每一个数字都可以质因数分解成两组，一组是只属于 <span class="math inline">\(a\)</span> 的质因子，另一组是只属于 <span class="math inline">\(b\)</span> 的质因子。手举几个栗子就能发现符合积性函数的性质。</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">const int _ &#x3D; 1e7 + 100;
const int MOD &#x3D; 1e9 + 7;
int np[_], prime[int(1e6)], tot &#x3D; 0, Mid[_];
void Init(int n)&#123;
	Mid[1] &#x3D; 0; np[1] &#x3D; 1;
	for(int i &#x3D; 2; i &lt;&#x3D; n; i++)&#123;
		if(!np[i]) prime[++tot] &#x3D; i, Mid[i] &#x3D; i;
		for(int j &#x3D; 1; j &lt;&#x3D; tot &amp;&amp; prime[j] * i &lt;&#x3D; n; j++)&#123;
			int x &#x3D; prime[j] * i;
			np[x] &#x3D; 1; Mid[x] &#x3D; prime[j];
			if(i % prime[j] &#x3D;&#x3D; 0) break;
		&#125;
	&#125;

&#125;
int n, m;
int dp[int(20)][int(30)]; int Ans[_];
long long t &#x3D; 1;
int main()&#123; &#x2F;&#x2F;freopen(&quot;in.txt&quot;, &quot;r&quot;, stdin);
	Init(1e7 + 2); Read(n)(m);
	rep(S, 1, tot)&#123;
		int now &#x3D; prime[S];
		memset(dp, 0, sizeof(dp));
		t &#x3D; 1; for(int j &#x3D; 0; t &lt;&#x3D; m; j++, t *&#x3D; now) dp[1][j] &#x3D; t;
		rep(i, 2, n)&#123;
			t &#x3D; 1; for(int j &#x3D; 0; t &lt;&#x3D; m; j++, t *&#x3D; now) &#123;
				int &amp;ans &#x3D; dp[i][j] &#x3D; 0;
				rep(k, 0, j) ans &#x3D; (ans +0ll+ dp[i - 1][k] *1ll* t % MOD) % MOD;
			&#125;
		&#125;
		t &#x3D; 1; for(int j &#x3D; 0; t &lt;&#x3D; m; j++, t *&#x3D; now) Ans[t] &#x3D; dp[n][j];
	&#125;
	Ans[1] &#x3D; 1;
	rep(i, 2, m)&#123;
		if(Ans[i]) continue;
		int A &#x3D; i, B &#x3D; 1;
		while(A % Mid[i] &#x3D;&#x3D; 0) A &#x2F;&#x3D; Mid[i], B *&#x3D; Mid[i];
		Ans[i] &#x3D; (Ans[A] *1ll* Ans[B]) % MOD;
	&#125;
	int ans &#x3D; 0;
	rep(i, 1, m) ans &#x3D; (ans +0ll+ Ans[i]) % MOD;
	printf(&quot;%d&quot;, ans);

	return 0;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

</details>
<h3 id="d.-连通">D. 连通</h3>
<div class="note info"><p>给出一张无向图，求有多少种方案使得删除三条边，使原图不连通。</p>
<p><span class="math inline">\(n,m \le 2000\)</span></p>
</div>
<details class="note success"><summary><p>solution</p>
</summary>
<p>考虑枚举删除的第一条边是那条，然后问题转化成了 求在一张图中删除两条边使图不连通的方案数。 先删去一条边，考虑剩下的图的形态， - 图已经不连通了，那答案的贡献就是每条边两两配对的方案数 - 图是联通的，考虑对图建一个生成树，考虑删边的方式 - 删除两条非树边 一定不合法，之前的树仍然存在，保证了图的连通性。 - 删除一条树边，一条非树边 被计入答案，当且仅当，这条树边被这条非树边唯一覆盖。这里的正确性显然。 - 删除两条非树边 被计入答案，当且仅当，这两条边被相同的一组非树边覆盖。 - 证明可以考虑，对于原树来说，如果删除两条树边，断成三份，如果两条边被相同的一组非树边覆盖，没有边可以联通断开的中间部分。 - 考虑如何实现，对每一条非树边赋一个随机权值，然后树边的权值定义为覆盖其的每一条非树边的权值异或和。统计删除两条边后图不联通的方案数，就转化为，统计有多少种方案选出两条边，使其权值相同。 树上差分即可，异或有自反性，其标记在 LCA 处自动消失。</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">const int _ &#x3D; 4100;
int head[_];
struct edges&#123;
	int node;
	int nxt;
&#125;edge[_]; int tot &#x3D; 1;
const int MOD &#x3D; 1e9 + 7;
int n, m;
int ToEid[_];
int ToNid[_];
int book[_];
u64 tag[int(2100)];
bool vis[int(2100)];
u64 EVal[int(2100)];
void add(int u, int v)&#123;
	tot++;
	edge[tot].node &#x3D; v;
	edge[tot].nxt  &#x3D; head[u];
	head[u]        &#x3D; tot;
&#125;
u64 gen()&#123;
	u64 A &#x3D; rand() *1ull* rand() * rand() *1ull* rand();
	u64 B &#x3D; rand() *1ull* rand() * rand() *1ull* rand();
	return A + B + rand();
&#125;
void dfs0(int now, int f)&#123;
	vis[now] &#x3D; 1;
	for(int i &#x3D; head[now]; i ; i &#x3D; edge[i].nxt)&#123;
		int ex &#x3D; edge[i].node; if(ex &#x3D;&#x3D; f) continue; if(book[i]) continue;
		if(!vis[ex]) dfs0(ex, now);
		else &#123;
			if( EVal[ToNid[i]]) continue;
			u64 g &#x3D; EVal[ToNid[i]] &#x3D; gen();
			tag[now] ^&#x3D; g; tag[ex] ^&#x3D; g;
		&#125;
	&#125;
&#125;
void dfs1(int now, int f)&#123;
	u64 &amp;ntag &#x3D; tag[now];
	for(int i &#x3D; head[now]; i ; i &#x3D; edge[i].nxt)&#123;
		int ex &#x3D; edge[i].node; if(ex &#x3D;&#x3D; f) continue; if(book[i]) continue;
		if(!EVal[ToNid[i]]) dfs1(ex, now), EVal[ToNid[i]] &#x3D; tag[ex], ntag ^&#x3D; tag[ex];
	&#125;
&#125;
map&lt;u64, int&gt; M;
const int inv6 &#x3D; 166666668;
int main()&#123;&#x2F;&#x2F; freopen(&quot;in.txt&quot;, &quot;r&quot;, stdin);
	Read(n)(m); int *seed &#x3D; new int; srand(*seed + n + m);
	rep(i, 1, m)&#123;
		int u, v; Read(u)(v);
		ToEid[i] &#x3D; tot + 1; ToNid[tot + 1] &#x3D; ToNid[tot + 2] &#x3D; i;
		add(u, v); add(v, u);
	&#125;
	int Pans &#x3D; 0;
	rep(i, 1, m)&#123;
		int rs &#x3D; ToEid[i];
		book[rs] &#x3D; book[rs ^ 1] &#x3D; 1;
		memset(tag, 0, sizeof(tag)); memset(vis, 0, sizeof(vis)); memset(EVal, 0, sizeof(EVal)); M.clear();
		dfs0(1, 1);

		bool pass &#x3D; true;
		rep(j, 1, n)  if(!vis[j]) &#123; pass &#x3D; false; break; &#125;
		if(!pass) &#123; int t &#x3D; m - 1; Pans &#x3D; (Pans +0ll+ (t * (t - 1))) % MOD; book[rs] &#x3D; book[rs ^ 1] &#x3D; 0; continue; &#125;
		dfs1(1, 1);
		rep(j, 1, m) if(i !&#x3D; j) M[EVal[j]] ++;
		int ans &#x3D; 0;
		for(map&lt;u64, int&gt; :: iterator i &#x3D; M.begin(); i !&#x3D; M.end(); i++)&#123;
			if(i-&gt;first &#x3D;&#x3D; 0ull)
				ans &#x3D; (ans +0ll+ (i-&gt;second *1ll* (i-&gt;second - 1)) % MOD) % MOD,
				ans &#x3D; (ans +0ll+ (((m - 1) - (i-&gt;second)) *2ll* (i-&gt;second)) % MOD) % MOD;
			else
				ans &#x3D; (ans +0ll+ (i-&gt;second *1ll* (i-&gt;second - 1)) % MOD) % MOD;
		&#125;
		Pans &#x3D; (ans +0ll+ Pans) % MOD;
		book[rs] &#x3D; book[rs ^ 1] &#x3D; 0;
	&#125;
	printf(&quot;%d&quot;, int(Pans *1ll* inv6 % MOD));
	return 0;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

</details>
<h2 id="round-9">Round 9</h2>
<p>降智场。 ### A. 最大公约数 <div class="note info"><p>给出一个长度为 <span class="math inline">\(n\)</span> 的序列。 设 <span class="math inline">\(k = \max_{i &lt; j}{\operatorname{gcd}(A_i, A_j)}\)</span>， 求出： - <span class="math inline">\(k\)</span> - <span class="math inline">\(\sum_{i &lt; j}\limits{[\operatorname{gcd}(A_i, A_j)=k]}\)</span> - <span class="math inline">\(\sum_{i &lt; j}\limits{[\operatorname{gcd}(A_i, A_j)=k]A_i \times A_j}\)</span></p>
</div> <details class="note success"><summary><p>Solution</p>
</summary>
<p>枚举一下 <span class="math inline">\(gcd\)</span> 可能以这个数字为 <span class="math inline">\(gcd\)</span> 的两个数字一定是 <span class="math inline">\(gcd\)</span> 的倍数。 从大到小枚举 <span class="math inline">\(gcd\)</span> 查询有多少倍数，如果大于 <span class="math inline">\(2\)</span> ，这个 <span class="math inline">\(gcd\)</span> 就可以。 剩余的两项在得到 <span class="math inline">\(k\)</span> 的基础上判断即可。</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">const int MOD &#x3D; 998244353;
const int _ &#x3D; 2e6 + 100;
const int inv2 &#x3D; 499122177;
int book[_];
int A[_], n, MAX &#x3D; 0;
int K &#x3D; 0;
int main()&#123;
	Read(n); rep(i, 1, n) Read(A[i]), book[A[i]]++, MAX &#x3D; max(MAX, A[i]);
	for(int i &#x3D; MAX; i &gt;&#x3D; 1; i--)&#123;
		int cnt &#x3D; 0;
		for(int j &#x3D; i; j &lt;&#x3D; MAX; j +&#x3D; i) cnt +&#x3D; book[j];
		if(cnt &gt;&#x3D; 2) &#123; K &#x3D; i; break; &#125;
	&#125;
	int SUM &#x3D; 0, ans1 &#x3D; 0, ans2 &#x3D; 0;
	for(int i &#x3D; K; i &lt;&#x3D; MAX; i +&#x3D; K)&#123;
		if(!book[i]) continue;
		ans1 +&#x3D; book[i]; SUM &#x3D; (SUM +0ll+ book[i] *1ll* i % MOD) % MOD;
	&#125;
	ans1 &#x3D; ((ans1 *1ll* (ans1 - 1)) % MOD *1ll* inv2) % MOD;
	for(int i &#x3D; K; i &lt;&#x3D; MAX; i +&#x3D; K)&#123;
		if(!book[i]) continue;
		ans2 &#x3D; (ans2 +0ll+ ( (SUM -0ll- i + MOD) % MOD *1ll* i % MOD *1ll* book[i]) % MOD ) % MOD;
	&#125;
	printf(&quot;%d %d %d\n&quot;, K, ans1, ans2 *1ll* inv2 % MOD);
	return 0;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

</details></p>
<h3 id="b.-紧急出口">B. 紧急出口</h3>
<div class="note info"><p>在一个走廊里共有 <span class="math inline">\(N\)</span> 个楼梯，其中 <span class="math inline">\(N\)</span> 个楼梯之间有 <span class="math inline">\(N-1\)</span> 个间隔， 个间隔会贴有一个紧急出口的指示牌指向左侧或者右侧。</p>
<p>问在所有的 <span class="math inline">\(2N−1\)</span> 种指示牌的贴法当中，有多少种贴法满足恰好有 <span class="math inline">\(M\)</span> 个楼梯(包括最左最右)的左右侧的紧急出口标识都不指向自己。</p>
<p>输出的答案对 <span class="math inline">\(998244353\)</span> 取模。 <span class="math inline">\(N \le 10^3, M \le 10^9\)</span></p>
</div>
<details class="note success"><summary><p>Solutiuon</p>
</summary>
<h4 id="倍增dp">倍增DP</h4>
<div class="note danger">
<p>
待填
</p>
</div>
<h4 id="隔板法">
隔板法
</h4>
<p>
称 “左右侧的紧急出口标识都不指向自己的点” 为关键点。
</p>
<p>
考虑如果选定了一个点是关键点，那么他们两边就形如 <code>&lt; o &gt;</code> ，可以发现相邻的两个关键点 <span class="math inline">(O_1, O_2)</span> 之间贴牌的方案一定形如 <span class="math inline">(...&lt; O_1 &gt; o &gt; ... &gt; o &lt; ... &lt; o &lt; O_2 &gt;...)</span> 显然，其实是把原序列分成连续的 <span class="math inline">(2m)</span> 段，每段内方向相同，相邻两段方向相反。 隔板即可。
</p>
<p>
<p>考虑组合数的通项公式，项数只有 <span class="math inline">(m)</span> 项。 <pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">int n, m; Read(n)(m); printf(&quot;%d&quot;, C(n, 2 * m - 1));<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></p>

</details></p>
<h3 id="c.-合影">C. 合影</h3>
<div class="note info"><p>众所周知， ACM ICPC 是三人组队参赛的比赛。现在在 ICPC WF2020 现场，有 <span class="math inline">\(k\)</span> 支参赛队伍要站成一排拍照！</p>
<p>摄影师小Z想促进队伍间的交流，于是小Z要求每个队伍的3个队员不能都挨在一起</p>
<p>现在小Z想问一问你，这 <span class="math inline">\(k\)</span> 支队伍有多少种拍照方式呢？由于数字很大，所以对 <span class="math inline">\(998244353\)</span> 取模就好~ <span class="math inline">\(k \le 10^6\)</span></p>
</div>
<details class="note success"><summary><p>Solution</p>
</summary>
<p>要求是每一队的三个队员不能全部挨在一起。 无法直接全部满足，考虑容斥。</p>
<p>假如所有人按任意顺序排列有 <span class="math inline">\((3k)!\)</span> 种排列方式。</p>
<p>显然会算入了不合法的情况，考虑去除这些 钦定哪一队全部挨在一起了，如果强制某一队挨在一起可以吧那一队捆成一个人 这样的方案数为 <span class="math inline">\((3k - 2)!\)</span>，算入答案就是 <span class="math inline">\(\dbinom{k}{1}(3k - 2)!(3!)^1\)</span> 最后一个是因为同一队中的队员也有顺序。</p>
<p>显然会去除多了，如果有多队同时不合法，这些方案会被去除多次，钦定哪两队全部挨在一起了，算入答案就是 <span class="math inline">\(\dbinom{k}{2}(3k - 4)!(3!)^2\)</span>。</p>
<p>显然加多了……</p>
<p>然后就是容斥原理了。</p>
<p>答案应该是 <span class="math inline">\(\sum_{i=0}^{k}\limits{(-1)^i\dbinom{k}{i}(3k - 2i)!(3!)^i}\)</span></p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">int C(int n, int m)&#123; return frac[n] *1ll* ifrac[n - m] % MOD *1ll* ifrac[m] % MOD; &#125;
int main()&#123;
	int k; Read(k); Init((k + 1) * 3);
	int ans &#x3D; 0;
	rep(i, 0, k)&#123;
		int tans &#x3D; 0;
		tans &#x3D; C(k, i) *1ll* frac[3 * k - 2 * i] % MOD *1ll* pow(6, i, MOD) % MOD;
		tans &#x3D; (i &amp; 1) ? MOD - tans : tans;
		ans &#x3D; (ans +0ll+ tans) % MOD;
	&#125;
	printf(&quot;%d&quot;, ans);
	return 0;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

</details>
<h3 id="d.-路径">D. 路径</h3>
<div class="note info"><p>给定一个<span class="math inline">\(n\)</span>个顶点的无根树，顶点编号 <span class="math inline">\(1 ~ n\)</span>。</p>
<p>同时给定树上的 <span class="math inline">\(k\)</span> 条带权路径，要求支持以下操作:</p>
<ul>
<li><code>1 k</code> ，删除第 <span class="math inline">\(k\)</span> 条带权路径。</li>
<li><code>2 k v</code> ，将第 <span class="math inline">\(k\)</span> 条带权路径的权值修改为 <span class="math inline">\(v\)</span> 。</li>
<li><code>3 p</code> ，给定一个树上节点 <span class="math inline">\(p\)</span> ，询问所有没有被删去的带权路径中，不与该节点相交的所有路径中的最小权值。 <span class="math inline">\(n, k, q \le 10^5\)</span></li>
</ul>
</div>
<details class="note success"><summary><p>solution</p>
</summary>
<h4 id="做法一树剖-stdset-维护标记-标记永久化线段树">做法一：树剖 + <code>std::set</code> 维护标记 标记永久化线段树</h4>
<span class="math inline">\(\mathcal{O}((k + q)\log_2^3{n})\)</span> 先树剖，路径补集仍然是线段树上 <span class="math inline">\(\log_2(n)\)</span> 段，可以在这些段里面加入可选的边，为了防止删除重复，<code>std::set</code> 内层数据类型为 <code>pair&lt;int, int&gt;</code> 分别存储路径的权值和编号。然后就直接做就好了。 <del>后记：被出题人卡成了 <span class="math inline">\(30\)</span> ……。</del>
<details class="note warning">
<summary>
<p>
code
</p>
<p></summary> <pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">#define rep(i, l, r) for(int i &#x3D; l, __ &#x3D; r; i &lt;&#x3D; __; i++)
using namespace std;
int n, k, p;
const int _ &#x3D; 2e6 + 100;
int head[_];
struct edges&#123;
	int node;
	int nxt;
&#125;edge[_]; int tot &#x3D; 0;
void add(int u, int v) &#123;
	tot++;
	edge[tot].node &#x3D; v;
	edge[tot].nxt  &#x3D; head[u];
	head[u]        &#x3D; tot;
&#125;
struct Path&#123; int u, v, Val; Path(int a, int b, int c) &#123; u &#x3D; a; v &#x3D; b; Val &#x3D; c; &#125; Path()&#123;&#125; &#125; P[_];

int dfn[_], rnk[_], dfc, dep[_], top[_], fa[_], si[_], son[_];
void dfs0(int now, int f, int dp)&#123;
	fa[now] &#x3D; f;  dep[now] &#x3D; dp; int &amp;Mid &#x3D; son[now] &#x3D; 0; int &amp;Si &#x3D; si[now] &#x3D; 1;
	for(int i &#x3D; head[now]; i ; i &#x3D; edge[i].nxt)&#123;
		int ex &#x3D; edge[i].node; if(ex &#x3D;&#x3D; f) continue;
		dfs0(ex, now, dp + 1); Si +&#x3D; si[ex]; if(si[ex] &gt; si[Mid]) Mid &#x3D; ex;
	&#125;
&#125;
void dfs1(int now, int f, int tp)&#123;
	dfn[now] &#x3D; ++dfc;  top[now] &#x3D; tp;
	if(son[now]) dfs1(son[now], now, tp);
	for(int i &#x3D; head[now]; i ; i &#x3D; edge[i].nxt)&#123;
		int ex &#x3D; edge[i].node; if(ex &#x3D;&#x3D; f || ex &#x3D;&#x3D; son[now]) continue;
		dfs1(ex, now, ex);
	&#125;
&#125;

namespace SegmentTree&#123;
	const int _ &#x3D; 3e6 + 100;
	int ch[_][2]; set&lt;pair&lt;int ,int&gt;, less &lt;pair&lt;int ,int&gt; &gt; &gt; v[_];
	int tot &#x3D; 0;
	#define ls(o) (ch[o][0])
	#define rs(o) (ch[o][1])
	#define make (tot++, ch[tot][0] &#x3D; ch[tot][1] &#x3D; 0, v[tot].clear(), tot)
	int Groot()&#123; return make; &#125;
	void build(int o, int L, int R)&#123;
		if(L &#x3D;&#x3D; R) return (void)v[o].insert(make_pair(INT_MAX, -1));
		int mid &#x3D; (L + R) &gt;&gt; 1;
		ls(o) &#x3D; make; rs(o) &#x3D; make; v[o].insert(make_pair(INT_MAX, -1));
		build(ls(o), L, mid); build(rs(o), mid + 1, R);
	&#125;
	void update_add(int o, int nowl, int nowr, int L, int R, int V, int id)&#123;
		if(L &gt; R) return ;
		if(L &lt;&#x3D; nowl &amp;&amp; nowr &lt;&#x3D; R) return (void)v[o].insert(make_pair(V, id));
		int mid &#x3D; (nowl + nowr) &gt;&gt; 1;
		if(L &lt;&#x3D; mid) update_add(ls(o), nowl, mid, L, R, V, id);
		if(R  &gt; mid) update_add(rs(o), mid + 1, nowr, L, R, V, id);
	&#125;
	void update_del(int o, int nowl, int nowr, int L, int R, int V, int id)&#123;
		if(L &gt; R) return ;
		if(L &lt;&#x3D; nowl &amp;&amp; nowr &lt;&#x3D; R) return (void)v[o].erase(make_pair(V, id));
		int mid &#x3D; (nowl + nowr) &gt;&gt; 1;
		if(L &lt;&#x3D; mid) update_del(ls(o), nowl, mid, L, R, V, id);
		if(R  &gt; mid) update_del(rs(o), mid + 1, nowr, L, R, V, id);
	&#125;
	pair&lt;int, int &gt; query(int o, int nowl, int nowr, int p, pair&lt;int, int &gt; ans &#x3D; make_pair(INT_MAX, -1))&#123;
		if(nowl &#x3D;&#x3D; nowr) return min(ans, *(v[o].begin()));
		int mid &#x3D; (nowl + nowr) &gt;&gt; 1; ans &#x3D; min(ans, *(v[o].begin()));
		return p &lt;&#x3D; mid ? query(ls(o), nowl, mid, p, ans) : query(rs(o), mid + 1, nowr, p, ans);
	&#125;
&#125; using SegmentTree::query; 	using SegmentTree::update_add; using SegmentTree::Groot;
  using SegmentTree::build;		using SegmentTree::update_del;
#define fi first
#define se second
vector&lt;pair&lt;int, int &gt; &gt; TMP;
int root &#x3D; 0;
void AddWithoutPath(int u, int v, int Val, int id)&#123;
	TMP.clear();
	while(top[u] !&#x3D; top[v])&#123;
		if(dep[top[u]] &lt; dep[top[v]]) swap(u, v);
		TMP.push_back(make_pair(dfn[top[u]], dfn[u])); u &#x3D; fa[top[u]];
	&#125;
	if(dep[u] &lt; dep[v]) swap(u, v);
	TMP.push_back(make_pair(dfn[v], dfn[u]));
	sort(TMP.begin(), TMP.end());
	rep(i, 0, TMP.size() - 2) update_add(root, 1, n, TMP[i].se + 1, TMP[i + 1].fi - 1, Val, id);
	update_add(root, 1, n, 1, TMP[0].fi - 1, Val, id);
	update_add(root, 1, n, TMP[TMP.size() - 1].se + 1, n, Val, id);
&#125;
void DelWithoutPath(int u, int v, int Val, int id)&#123;
	TMP.clear();
	while(top[u] !&#x3D; top[v])&#123;
		if(dep[top[u]] &lt; dep[top[v]]) swap(u, v);
		TMP.push_back(make_pair(dfn[top[u]], dfn[u])); u &#x3D; fa[top[u]];
	&#125;
	if(dep[u] &lt; dep[v]) swap(u, v);
	TMP.push_back(make_pair(dfn[v], dfn[u]));
	sort(TMP.begin(), TMP.end());
	rep(i, 0, TMP.size() - 2) update_del(root, 1, n, TMP[i].se + 1, TMP[i + 1].fi - 1, Val, id);
	update_del(root, 1, n, 1, TMP[0].fi - 1, Val, id);
	update_del(root, 1, n, TMP[TMP.size() - 1].se + 1, n, Val, id);
&#125;
int main()&#123; &#x2F;&#x2F; freopen(&quot;in.txt&quot;, &quot;r&quot;, stdin);
	Read(n)(k)(p);
	rep(i, 1, n - 1)&#123;
		int u, v; Read(u)(v);
		add(u, v); add(v, u);
	&#125;
	rep(i, 1, k) &#123;
		int p, q, v; Read(p)(q)(v);
		P[i] &#x3D; Path(p, q, v);
	&#125;
	dfs0(1, 1, 1); dfs1(1, 1, 1);
	root &#x3D; Groot(); build(root, 1, n);
	rep(i, 1, k) AddWithoutPath(P[i].u, P[i].v, P[i].Val, i);
	while(p--)&#123;
		int opt, k; Read(opt)(k);
		if(opt &#x3D;&#x3D; 1)&#123;
			DelWithoutPath(P[k].u, P[k].v, P[k].Val, k);
		&#125; else if(opt &#x3D;&#x3D; 2)&#123;
			DelWithoutPath(P[k].u, P[k].v, P[k].Val, k);
			Read(P[k].Val);
			AddWithoutPath(P[k].u, P[k].v, P[k].Val, k);
		&#125; else &#123;
			pair&lt;int, int &gt; r &#x3D; query(root, 1, n, dfn[k]);
			printf(&quot;%d\n&quot;, r.first &lt; INT_MAX ? r.first : -1);
		&#125;
	&#125;
	return 0;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></p>
</details>
<h4 id="做法二线段树维护路径交集-二分最小值">
做法二：线段树维护路径交集 + 二分最小值
</h4>
<blockquote>
<p>
巧妙绝伦的做法。
</p>
</blockquote>
<p>
要求回答的是：不与节点 <span class="math inline">(p)</span> 相交的所有路径中的最小权值。
</p>
<p>
考虑二分一个最小权值 <span class="math inline">(x)</span>，然后判断是所有权值小于 <span class="math inline">(x)</span> 的路径是不是全都和点 <span class="math inline">(p)</span> 有交。
</p>
<p>
如果把所有路径按照权值排序，那么成为答案的那条路径之前的路径一定都和点 <span class="math inline">(p)</span> 有交，这就可以直接二分答案了。
</p>
<p>
但是路径需要支持删除和修改。 显然需要数据结构。
</p>
<p>
一个显然的事实是：两条路径的交 也是一条路径（定义一个点或者空都属于路径）。
</p>
<p>
线段树就可以快速求出一段路径区间内所有路径的交集路径。
</p>
<p>
所有路径按照权值排好序后的一个前缀全部和点 <span class="math inline">(p)</span> 有交，等价于，这个前缀所有的路径的交集和点 <span class="math inline">(p)</span> 有交。
</p>
<p>
对于删除操作，可以考虑在线段树对应操作上打删除标记。对于修改操作，因为没有强制在线，可以考虑一开始把这条路径的所有权值排好序后加入线段树，然后对于当前无用的版本，打上删除标记即可。对于一次修改，转化成一次删除和一次恢复操作。
</p>
<p>
当然平衡树可以轻易完成这样的工作，在平衡树上维护树上路径交集，写不出来啊…
</p>
<p>
这样就可以直接用线段树求出某个前缀的所有路径的交集路径了。线段树合并信息时，需要询问 <code>LCA</code>，算上二分，这样的单次询问复杂度可以做到 <span class="math inline">((k w n))</span>（倍增 <code>LCA</code>），或者 <span class="math inline">((k w))</span>（<span class="math inline">((n) - (1))</span> <code>LCA</code>）。
</p>
<p>
注意到线段树本身就是一个分治的结构，可以直接在线段树上二分，这样就可以做到 <span class="math inline">((k n))</span>（倍增 <code>LCA</code>），或者 <span class="math inline">((k))</span>（<span class="math inline">((n) - (1))</span> <code>LCA</code>）。
</p>
<p>
我的实现是 倍增 <code>LCA</code> + 线段树二分，算上预处理，总时间复杂度为 <span class="math inline">((n(n) + q(q+k)n))</span>
<details class="note warning">
<summary>
<p>
code
</p>
<p></summary> <pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">const int _ &#x3D; 2e5 + 100;
int head[_], tot &#x3D; 0;
struct edges&#123;
	int node;
	int nxt;
&#125;edge[_];
void add(int u, int v)&#123;
	tot++;
	edge[tot].node &#x3D; v;
	edge[tot].nxt  &#x3D; head[u];
	head[u]        &#x3D; tot;
&#125;
int n, k, q;
const int LOG &#x3D; 18;
int fa[_][LOG + 2], dep[_];
void dfs0(int now, int f, int dp)&#123;
	fa[now][0] &#x3D; f; dep[now] &#x3D; dp;
	for(int i &#x3D; head[now]; i ; i &#x3D; edge[i].nxt)&#123;
		int ex &#x3D; edge[i].node; if(ex &#x3D;&#x3D; f) continue;
		dfs0(ex, now, dp + 1);
	&#125;
&#125;
map &lt; pair&lt;int, int&gt; , int &gt;  Mem;
int LCA(int u, int v)&#123;
	pair&lt;int, int&gt; P &#x3D; make_pair(min(u, v), max(u, v));
	if(Mem.count(P)) return Mem[P];
	if(dep[u] &lt; dep[v]) swap(u, v);
	int d &#x3D; dep[u] - dep[v];
	int x &#x3D; u, y &#x3D; v;
	rep(i, 0, LOG) if(d &amp; (1 &lt;&lt; i)) x &#x3D; fa[x][i];
	if(x &#x3D;&#x3D; y) return x;
	for(int i &#x3D; LOG; i &gt;&#x3D; 0; i--)&#123;
		if(fa[x][i] &#x3D;&#x3D; fa[y][i]) continue;
		x &#x3D; fa[x][i]; y &#x3D; fa[y][i];
	&#125;
	return Mem[P] &#x3D; fa[x][0];
&#125;

void InitQuery()&#123;
	dfs0(1, 1, 1);
	rep(j, 1, LOG) rep(i, 1, n) fa[i][j] &#x3D; fa[fa[i][j - 1]][j - 1];
&#125;
struct Path_t&#123;
	int id, u, v, w, ver;
	Path_t(int a, int b, int c, int d, int e) &#123; id &#x3D; a; u &#x3D; b; v &#x3D; c; w &#x3D; d; ver &#x3D; e; &#125;
	Path_t() &#123; &#125;
&#125;;
bool CMP(const Path_t &amp; A, const Path_t &amp; B) &#123; return A.w &lt; B.w; &#125;
struct Q_t&#123;
	int type, a, b;
	Q_t(int x, int y, int z) &#123; type &#x3D; x; a &#x3D; y; b &#x3D; z; &#125;
	Q_t() &#123;&#125;
&#125;Q[_];
int nowv[_];
vector&lt;Path_t&gt; P;
vector&lt;int&gt; Pv[_];
int dis(int u, int v) &#123; return dep[u] + dep[v] - (dep[LCA(u, v)] &lt;&lt; 1); &#125;
pair&lt;int, int&gt; cross(int u0, int v0, int u1, int v1) &#123;
	int t0 &#x3D; LCA(u0, v0);
	int t1 &#x3D; LCA(u0, u1);
	int t2 &#x3D; LCA(u0, v1);
	int t3 &#x3D; LCA(v0, u1);
	int t4 &#x3D; LCA(v0, v1);
	int target0 &#x3D; t0; &#x2F;&#x2F; t0 t1 t3
	if(dep[target0] &lt; dep[t1]) target0 &#x3D; t1;
	if(dep[target0] &lt; dep[t3]) target0 &#x3D; t3;
	int target1 &#x3D; t0; &#x2F;&#x2F; t0 t2 t4
	if(dep[target1] &lt; dep[t2]) target1 &#x3D; t2;
	if(dep[target1] &lt; dep[t4]) target1 &#x3D; t4;
	if(target1 &#x3D;&#x3D; target0 &amp;&amp; dis(target1, u1) + dis(target1, v1) !&#x3D; dis(u1, v1)) return make_pair(-1, -1);
	else return make_pair(target0, target1);
&#125;
bool crossx(int u, int v, int x) &#123; if(u &#x3D;&#x3D; -1 || v &#x3D;&#x3D; -1) return false;  return dis(u, v) &#x3D;&#x3D; dis(u, x) + dis(v, x); &#125;
namespace SegmentTree&#123; &#x2F;&#x2F; To maintain the merge path
	struct Node_t&#123;
		int u, v;
		bool isDel, isNul;
		void clear()&#123;
			isDel &#x3D; false; isNul &#x3D; true; u &#x3D; v &#x3D; 0;
		&#125;
	&#125;;
	const int _ &#x3D; 1e6 + 100;
	int ch[_][2], tot &#x3D; 0; Node_t v[_];
	#define ls(o) (ch[o][0])
	#define rs(o) (ch[o][1])
	#define make (tot++, ch[tot][0] &#x3D; ch[tot][1] &#x3D; 0, v[tot].clear(), tot)
	int Groot() &#123; return make; &#125;
	void maintain(int o) &#123;
		v[o].isDel &#x3D; (v[ls(o)].isDel &amp;&amp; v[rs(o)].isDel);
		v[o].isNul &#x3D; (v[ls(o)].isNul || v[rs(o)].isNul);
		if(!v[o].isDel &amp;&amp; !v[o].isNul)&#123;
			if(v[ls(o)].isDel &amp;&amp; !v[rs(o)].isDel) v[o].u &#x3D; v[rs(o)].u, v[o].v &#x3D; v[rs(o)].v;
			else if(v[rs(o)].isDel &amp;&amp; !v[ls(o)].isDel) v[o].u &#x3D; v[ls(o)].u, v[o].v &#x3D; v[ls(o)].v;
			else &#123;
				pair&lt;int, int&gt; R &#x3D; cross(v[ls(o)].u, v[ls(o)].v, v[rs(o)].u, v[rs(o)].v);
				if(R.first &#x3D;&#x3D; -1) &#123;
					v[o].isNul &#x3D; true;
				&#125;
				v[o].u &#x3D; R.first; v[o].v &#x3D; R.second;
			&#125;
		&#125;
	&#125;
	void build(int o, int L, int R)&#123;
		if(L &#x3D;&#x3D; R) &#123;
			v[o].isNul &#x3D; false;
			v[o].isDel &#x3D; (P[L - 1].ver !&#x3D; 1);
			v[o].u     &#x3D; P[L - 1].u;
			v[o].v     &#x3D; P[L - 1].v;
			return ;
		&#125; ls(o) &#x3D; make; rs(o) &#x3D; make;
		int mid &#x3D; (L + R) &gt;&gt; 1;
		build(ls(o), L, mid); build(rs(o), mid + 1, R);
		maintain(o);
	&#125;
	void update(int o, int nowl, int nowr, int p, bool V)&#123;
		if(nowl &#x3D;&#x3D; nowr) return (void)(v[o].isDel &#x3D; V);
		int mid &#x3D; (nowl + nowr) &gt;&gt; 1;
		if(p &lt;&#x3D; mid) update(ls(o), nowl, mid, p, V);
		if(p  &gt; mid) update(rs(o), mid + 1, nowr, p, V);
		maintain(o);
	&#125;
	int query(int o, int nowl, int nowr, int x)&#123;
		if(!v[o].isNul &amp;&amp; !v[o].isDel &amp;&amp; crossx(v[o].u, v[o].v, x)) return -1;
		if(nowl &#x3D;&#x3D; nowr) return P[nowl - 1].w;
		bool r0 &#x3D; !(v[ls(o)].isNul || !crossx(v[ls(o)].u, v[ls(o)].v, x)) || v[ls(o)].isDel;
		bool r1 &#x3D; !(v[rs(o)].isNul || !crossx(v[rs(o)].u, v[rs(o)].v, x)) || v[rs(o)].isDel;
		int mid &#x3D; (nowl + nowr) &gt;&gt; 1;
		if(!r0) return query(ls(o), nowl, mid, x); else if(!r1) return query(rs(o), mid + 1, nowr, x); else return -1;
	&#125;
&#125;  using SegmentTree::build; using SegmentTree::Groot;
   using SegmentTree::query; using SegmentTree::update;

int main() &#123; freopen(&quot;in.txt&quot;, &quot;r&quot;, stdin);
	Read(n)(k)(q); rep(i, 1, n - 1) &#123; int u, v; Read(u)(v); add(u, v); add(v, u); &#125; InitQuery();
	rep(i, 1, k)&#123;
		int u, v, w; Read(u)(v)(w);
		P.push_back(Path_t(i, u, v, w, 1)); nowv[i] &#x3D; 1;
	&#125;
	rep(i, 1, q)&#123;
		int type, a, b; Read(type)(a);
		if(type &#x3D;&#x3D; 2) Read(b), Q[i] &#x3D; Q_t(type, a, b);
		else Q[i] &#x3D; Q_t(type, a, 0);
	&#125;
	rep(i, 1, q)&#123;
		Q_t &amp;now &#x3D; Q[i];
		if(now.type &#x3D;&#x3D; 2) P.push_back(Path_t(now.a, P[now.a - 1].u, P[now.a - 1].v, now.b, ++nowv[now.a]));
	&#125;

	rep(i, 1, k) Pv[i].resize(nowv[i] + 2);
	sort(P.begin(), P.end(), CMP);
	rep(i, 0, P.size() - 1) Pv[P[i].id][P[i].ver] &#x3D; i + 1;
	int root &#x3D; Groot(), U; U &#x3D; P.size(); build(root, 1, U);
	rep(i, 1, k) nowv[i] &#x3D; 1;
	rep(i, 1, q)&#123;
		Q_t &amp;now &#x3D; Q[i];
		if(now.type &#x3D;&#x3D; 1)&#123;
			int Pl &#x3D; Pv[now.a][nowv[now.a]];
			update(root, 1, U, Pl, 1);
		&#125; else if(now.type &#x3D;&#x3D; 2)&#123;
			int Pl0 &#x3D; Pv[now.a][  nowv[now.a]];
			int Pl1 &#x3D; Pv[now.a][++nowv[now.a]];
			update(root, 1, U, Pl0, 1);
			update(root, 1, U, Pl1, 0);
		&#125; else &#123;
			printf(&quot;%d\n&quot;, query(root, 1, U, now.a));
		&#125;
	&#125;
	return 0;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></p>
</details>
#### 做法三：CDQ 分治
<div class="note warning">
<p>
学了再说。
</p>
</div>
</p>

</details>
<p>QAQ /kel</p>
]]></content>
      <categories>
        <category>学习总结</category>
      </categories>
  </entry>
</search>
